//! Implementation of [`Dynamic`].

use super::super::List;
use super::Array;
use super::Collection;
use super::Linear;

use core::mem::MaybeUninit;
use core::ptr::NonNull;

/// An [`Array`] which can store a runtime defined number of elements.
///
/// Similar to [`Fixed`], this stores elements contiguously in a single
/// allocated object; however, [`Self`] stores them within 'heap' memory that
/// is dynamically allocated rather than being sorted in 'stack' memory that is
/// statically allocated. Moreover, while [`Fixed`] allocates only enough
/// memory to store the predefined elements, [`Self`] can allocate additional
/// 'capacity' such that elements can be inserted during runtime. This capacity
/// can be before and/or after the contained elements as illustrated below:
///
/// ```
/// +----------------+--------------------+---------------+
/// | front capacity | contained elements | back capacity |
/// +----------------+--------------------+---------------+
/// ```
///
/// See also: [Wikipedia](https://en.wikipedia.org/wiki/Dynamic_array).
pub struct Dynamic<T> {
    /// Underlying buffer storing initialized _and_ uninitialized elements.
    buffer: NonNull<MaybeUninit<T>>,

    /// The number of uninitialized elements before the initialized ones.
    front_capacity: usize,

    /// The number of elements which are initialized.
    initialized: usize,

    /// The number of uninitialized elements after the initialized ones.
    back_capacity: usize,
}

impl<T> Dynamic<T> {
    /// Attempt to allocate enough memory to store exactly `count` elements.
    ///
    /// # Panics
    /// The Rust runtime might panic or otherwise abort if allocation fails.
    ///
    /// # Errors
    /// Yields [`FailedAllocation`] when memory allocation fails.
    ///
    /// # Performance
    /// This method always consumes O(N) memory and takes O(1) time.
    ///
    /// # Examples
    /// ```
    /// use rust::structure::collection::linear::List;
    /// use rust::structure::collection::linear::array::Dynamic;
    ///
    /// let Ok(mut instance) = Dynamic::<usize>::with_capacity(256) else {
    ///     panic!("allocation failed");
    /// };
    ///
    /// for element in 0..256 {
    ///     // This is done in constant time without reallocating memory.
    ///     let Ok(_inserted) = instance.append(element) else {
    ///         unreachable!("using capacity cannot fail");
    ///     };
    /// }
    /// ```
    pub fn with_capacity(count: usize) -> Result<Self, FailedAllocation> {
        let mut instance = Dynamic::<T>::default();

        match instance.reserve_back(count) {
            Ok(_) => Ok(instance),
            Err(_) => Err(FailedAllocation),
        }
    }

    /// Query how many elements could be inserted without reallocation.
    ///
    /// This many elements can be inserted without possibility of error.
    /// However, adding this many elements might still require rearranging the
    /// underlying buffer in non-constant time, thereby invalidating pointers.
    ///
    /// See also: [`Self::capacity_front`] and [`Self::capacity_back`] to know
    /// how many elements can can be inserted at a specific end without
    /// reallocation and without invalidating pointers.
    ///
    /// # Performance
    /// This method always consumes O(1) memory and takes O(1) time.
    ///
    /// # Examples
    /// ```
    /// use rust::structure::collection::linear::List;
    /// use rust::structure::collection::linear::array::Dynamic;
    ///
    /// let Ok(mut instance) = Dynamic::<i32>::with_capacity(6) else {
    ///     panic!("memory allocation failed");
    /// };
    ///
    /// // Yields the shared front/back capacity when empty.
    /// assert_eq!(instance.capacity(), 6);
    ///
    /// // Decreases when elements are inserted.
    /// instance.extend([0, 1, 2, 3, 4, 5]);
    /// assert_eq!(instance.capacity(), 0);
    ///
    /// // Sums end specific capacities when not empty.
    /// instance.reserve_front(256).expect("successful allocation");
    /// instance.reserve_back(256).expect("successful allocation");
    /// assert_eq!(instance.capacity(), 512);
    ///
    /// for element in 0..512 {
    ///     // This is done without reallocating memory.
    ///     let Ok(_inserted) = instance.append(element) else {
    ///         unreachable!("using capacity cannot fail");
    ///     };
    /// }
    /// ```
    #[must_use]
    pub fn capacity(&self) -> usize {
        let Some(total) = usize::checked_add(self.front_capacity, self.back_capacity) else {
            unreachable!("cannot allocate more than `isize::MAX` bytes");
        };

        total
    }

    /// How many elements can be [`Self::prepend`] without reallocation.
    ///
    /// This many end-specific insertions will be constant time without
    /// possibility of error. Moreover, pointers to already contained elements
    /// remain valid.
    ///
    /// # Performance
    /// This method always consumes O(1) memory and takes O(1) time.
    ///
    /// # Examples
    /// ```
    /// use rust::structure::collection::linear::List;
    /// use rust::structure::collection::linear::array::Dynamic;
    ///
    /// let Ok(mut instance) = Dynamic::<i32>::with_capacity(6) else {
    ///     panic!("memory allocation failed");
    /// };
    ///
    /// // Yields the shared front/back capacity when empty.
    /// assert_eq!(instance.capacity_front(), 6);
    ///
    /// // Decreases when elements are inserted.
    /// instance.extend([12345, 1, 2, 3, 4, 5]);
    /// assert_eq!(instance.capacity_front(), 0);
    ///
    /// // Does not yield capacity from the other end when not empty.
    /// instance.reserve_back(256).expect("successful memory allocation");
    /// assert_eq!(instance.capacity_front(), 0);
    ///
    /// // But does yield capacity from this end when not empty.
    /// instance.reserve_front(256).expect("successful memory allocation");
    /// assert_eq!(instance.capacity_front(), 256);
    ///
    /// // This pointer remains valid for that many end specific insertions.
    /// let pointer = core::ptr::from_ref(&instance[0]);
    ///
    /// for element in 0..256 {
    ///     // This is done in constant time without reallocating memory.
    ///     let Ok(_inserted) = instance.prepend(element) else {
    ///         unreachable!("using capacity cannot fail");
    ///     };
    /// }
    ///
    /// assert_eq!(unsafe { *pointer }, 12345);
    /// ```
    #[must_use]
    pub fn capacity_front(&self) -> usize {
        if self.initialized == 0 {
            self.capacity()
        } else {
            self.front_capacity
        }
    }

    /// How many elements can be [`Self::append`] without reallocation.
    ///
    /// This many end-specific insertions will be constant time without
    /// possibility of error. Moreover, pointers to already contained elements
    /// remain valid.
    ///
    /// # Performance
    /// This method always consumes O(1) memory and takes O(1) time.
    ///
    /// # Examples
    /// ```
    /// use rust::structure::collection::linear::List;
    /// use rust::structure::collection::linear::array::Dynamic;
    ///
    /// let Ok(mut instance) = Dynamic::<i32>::with_capacity(6) else {
    ///     panic!("memory allocation failed");
    /// };
    ///
    /// // Yields the shared front/back capacity when empty.
    /// assert_eq!(instance.capacity_back(), 6);
    ///
    /// // Decreases when elements are inserted.
    /// instance.extend([12345, 1, 2, 3, 4, 5]);
    /// assert_eq!(instance.capacity_back(), 0);
    ///
    /// // Does not yield capacity from the other end when not empty.
    /// instance.reserve_front(256).expect("successful memory allocation");
    /// assert_eq!(instance.capacity_back(), 0);
    ///
    /// // But does yield capacity from this end when not empty.
    /// instance.reserve_back(256).expect("successful memory allocation");
    /// assert_eq!(instance.capacity_back(), 256);
    ///
    /// // This pointer remains valid for that many end specific insertions.
    /// let pointer = core::ptr::from_ref(&instance[0]);
    ///
    /// for element in 0..256 {
    ///     // This is done in constant time without reallocating memory.
    ///     let Ok(_inserted) = instance.append(element) else {
    ///         unreachable!("using capacity cannot fail");
    ///     };
    /// }
    ///
    /// assert_eq!(unsafe { *pointer }, 12345);
    /// ```
    #[must_use]
    pub fn capacity_back(&self) -> usize {
        if self.initialized == 0 {
            self.capacity()
        } else {
            self.back_capacity
        }
    }

    /// Allocate space for _at least_ `capacity` additional elements.
    ///
    /// This method is similar to [`Self::reserve_back`] in that it will
    /// increase [`Self::capacity_back`] so elements can be [`Self::append`]
    /// in constant time without reallocating memory. However, in contrast,
    /// this method exists to emulate the behaviour of [`Vec::reserve`] so it
    /// will first [`Self::shift`] already contained elements to consume
    /// any [`Self::capacity_front`] before then (re)allocating additional
    /// memory if necessary so [`Self::capacity_back`] is at least `capacity`.
    /// Furthermore, while [`Self::reserve_back`] allocates memory exactly
    /// proportional to the requested `capacity`, this method may allocate
    /// additional memory such that the maximum number of elements `self` can
    /// hold within the allocation is a power of two (2) thereby allowing
    /// [amortized analysis](https://en.wikipedia.org/wiki/Amortized_analysis).
    ///
    /// See also: [`Self::reserve_front`] or [`Self::reserve_back`] to reserve
    /// an exact amount of elements at a specific end whilst preserving
    /// existing capacity at the other end.
    ///
    /// # Panics
    /// The Rust runtime might panic or otherwise abort if allocation fails.
    ///
    /// # Errors
    /// Yields [`FailedAllocation`] when memory (re)allocation fails.
    ///
    /// # Performance
    /// In the best case when [`Self::capacity_back`] is already `capacity`
    /// or greater, this method consumes 𝛀(1) memory and takes 𝛀(1) time. In
    /// the worst case when [`Self::capacity`] is less than `capacity`, this
    /// method consumes O(N) memory and takes O(N) time.
    ///
    /// # Examples
    /// ```
    /// use rust::structure::collection::linear::List;
    /// use rust::structure::collection::linear::array::Dynamic;
    ///
    /// let mut instance = Dynamic::from_iter([0, 1, 2, 3, 4, 5]);
    ///
    /// instance.reserve_front(256).expect("successful memory allocation");
    /// instance.reserve_back(256).expect("successful memory allocation");
    ///
    /// // Does nothing if already enough back capacity.
    /// let Ok(_) = instance.reserve(256) else {
    ///     unreachable!("will not reallocate so cannot fail");
    /// };
    /// assert_eq!(instance.capacity_front(), 256);
    /// assert_eq!(instance.capacity_back(), 256);
    ///
    /// // Shifts contained elements to reclaim front capacity without
    /// // reallocating when that creates enough back capacity.
    /// let Ok(_) = instance.reserve(256 + 1) else {
    ///     unreachable!("will not reallocate so cannot fail");
    /// };
    /// assert_eq!(instance.capacity_front(), 0);
    /// assert_eq!(instance.capacity_back(), 512);
    ///
    /// // Otherwise, will reallocate memory.
    /// let Ok(_) = instance.reserve(512 + 1) else {
    ///     panic!("memory allocation failed");
    /// };
    /// assert!(instance.capacity_back() >= 512 + 1);
    ///
    /// // But may allocate more than requested.
    /// // The 6 comes from the number of contained elements.
    /// assert_eq!(instance.capacity_front(), 0);
    /// assert_eq!(instance.capacity_back(), 1024 - 6);
    /// ```
    pub fn reserve(&mut self, capacity: usize) -> Result<&mut Self, FailedAllocation> {
        // Prevent amortized growth when unnecessary.
        if self.back_capacity >= capacity {
            return Ok(self);
        }

        // Reclaim any front capacity.
        if self.front_capacity > 0 {
            let Ok(front_capacity) = isize::try_from(self.front_capacity) else {
                unreachable!("cannot allocate more than `isize::MAX` bytes");
            };

            let Some(front_capacity) = front_capacity.checked_neg() else {
                unreachable!("is positive number => cannot be `isize::MIN`");
            };

            let Ok(_) = self.shift(front_capacity) else {
                unreachable!("exactly that much front capacity");
            };

            // Prevent amortized growth if now enough capacity.
            if self.back_capacity >= capacity {
                return Ok(self);
            }
        }

        // Attempt to do amortized growth, but fall back to requested capacity.
        let amortized = self.amortized(capacity).unwrap_or(capacity);

        if self.reserve_back(amortized).is_ok() {
            Ok(self)
        } else {
            self.reserve_back(capacity)
        }
    }

    /// Allocate space for exactly `capacity` elements to be [`Self::prepend`].
    ///
    /// # Panics
    /// The Rust runtime might panic or otherwise abort if allocation fails.
    ///
    /// # Errors
    /// Yields [`FailedAllocation`] when memory (re)allocation fails.
    ///
    /// # Performance
    /// In the best case when [`Self::capacity_front`] is `capacity` or more,
    /// then this method consumes 𝛀(1) memory and takes 𝛀(1) time. Otherwise,
    /// it is the the worst case when reallocation is necessary, so this
    /// method consumes O(N) memory and takes O(N) time.
    ///
    /// # Examples
    /// ```
    /// use rust::structure::collection::linear::List;
    /// use rust::structure::collection::linear::array::Dynamic;
    ///
    /// let mut instance = Dynamic::from_iter([0, 1, 2, 3, 4, 5]);
    /// _ = instance.reserve_back(256).expect("successful reallocation");
    ///
    /// // Will reallocate if no capacity at that specific end.
    /// let Ok(_) = instance.reserve_front(256) else {
    ///     panic!("memory allocation failed");
    /// };
    /// assert_eq!(instance.capacity_front(), 256);
    ///
    /// // Will not reallocate if already enough capacity.
    /// let Ok(_) = instance.reserve_front(256) else {
    ///     unreachable!("will not reallocate so cannot fail");
    /// };
    /// assert_eq!(instance.capacity_front(), 256);
    ///
    /// // Will not alter capacity on the other end.
    /// assert_eq!(instance.capacity_back(), 256);
    /// ```
    pub fn reserve_front(&mut self, capacity: usize) -> Result<&mut Self, FailedAllocation> {
        let Some(capacity) = capacity.checked_sub(self.capacity_front()) else {
            debug_assert!(self.capacity_front() > capacity, "enough capacity");

            return Ok(self);
        };

        let Ok(capacity) = isize::try_from(capacity) else {
            debug_assert!(capacity > isize::MAX as usize, "cannot allocate more than `isize::MAX` bytes");

            return Err(FailedAllocation);
        };

        _ = self.resize(capacity)?;

        let Ok(_) = self.shift(capacity) else {
            unreachable!("enough back capacity to shift into");
        };

        Ok(self)
    }

    /// Allocate space for exactly `capacity` elements to be [`Self::append`].
    ///
    /// # Panics
    /// The Rust runtime might panic or otherwise abort if allocation fails.
    ///
    /// # Errors
    /// Yields [`FailedAllocation`] when memory (re)allocation fails.
    ///
    /// # Performance
    /// In the best case when [`Self::capacity_back`] is `capacity` or more,
    /// then this method consumes 𝛀(1) memory and takes 𝛀(1) time. Otherwise,
    /// it is the the worst case when reallocation is necessary, so this
    /// method consumes O(N) memory and takes O(N) time.
    ///
    /// # Examples
    /// ```
    /// use rust::structure::collection::linear::List;
    /// use rust::structure::collection::linear::array::Dynamic;
    ///
    /// let mut instance = Dynamic::from_iter([0, 1, 2, 3, 4, 5]);
    /// _ = instance.reserve_front(256).expect("successful reallocation");
    ///
    /// // Will reallocate if no capacity at that specific end.
    /// let Ok(_) = instance.reserve_back(256) else {
    ///     panic!("memory allocation failed");
    /// };
    /// assert_eq!(instance.capacity_back(), 256);
    ///
    /// // Will not reallocate if already enough capacity.
    /// let Ok(_) = instance.reserve_back(256) else {
    ///     unreachable!("will not reallocate so cannot fail");
    /// };
    /// assert_eq!(instance.capacity_back(), 256);
    ///
    /// // Will not alter capacity on the other end.
    /// assert_eq!(instance.capacity_front(), 256);
    /// ```
    pub fn reserve_back(&mut self, capacity: usize) -> Result<&mut Self, FailedAllocation> {
        let Some(capacity) = capacity.checked_sub(self.capacity_back()) else {
            debug_assert!(self.capacity_back() > capacity, "enough capacity");

            return Ok(self);
        };

        let Ok(capacity) = isize::try_from(capacity) else {
            debug_assert!(capacity > isize::MAX as usize, "cannot allocate more than `isize::MAX` bytes");

            return Err(FailedAllocation);
        };

        self.resize(capacity)
    }

    /// Reduce [`Self::capacity`] to exactly `capacity`.
    ///
    /// This method is similar to [`Self::shrink_back`] in that it will
    /// decrease [`Self::capacity_back`] to reduce the memory overhead.
    /// However, in contrast, this method exists to emulate the behaviour of
    /// [`Vec::shrink`] so it will first [`Self::shift`] already contained
    /// elements to consume any [`Self::capacity_front`] before then
    /// reallocating if necessary to reduce [`Self::capacity_back`].
    ///
    /// See also: [`Self::shrink_front`] or [`Self::shrink_back`] to reduce
    /// capacity at a specific end whilst preserving existing capacity at the
    /// other end.
    ///
    /// # Panics
    /// The Rust runtime might panic or otherwise abort if allocation fails.
    ///
    /// # Errors
    /// Yields [`FailedAllocation`] when memory (re)allocation fails.
    ///
    /// # Performance
    /// In the best case when [`Self::capacity`] is `capacity` or less, this
    /// method consumes 𝛀(1) memory and takes 𝛀(1) time. Otherwise it is the
    /// worst case when reallocation is necessary, so this method consumes O(N)
    /// memory and takes O(N) time.
    ///
    /// # Examples
    /// ```
    /// use rust::structure::collection::linear::List;
    /// use rust::structure::collection::linear::array::Dynamic;
    ///
    /// let mut instance = Dynamic::<usize>::with_capacity(256).expect("successful allocation");
    ///
    /// // Half fill with elements.
    /// for element in 0..128 {
    ///     instance.prepend(element).expect("enough capacity");
    /// }
    ///
    /// assert_eq!(instance.capacity_front(), 128);
    /// assert_eq!(instance.capacity_back(), 0);
    ///
    /// // Shrink to have capacity of 128 elements at the back.
    /// instance.shrink(Some(128)).expect("successful reallocation");
    /// assert_eq!(instance.capacity_front(), 0);
    /// assert_eq!(instance.capacity_back(), 128);
    ///
    /// // Shrink to have no capacity (shrink to fit).
    /// instance.shrink(None).expect("successful deallocation");
    /// assert_eq!(instance.capacity_back(), 0);
    /// ```
    pub fn shrink(&mut self, capacity: usize) -> Result<&mut Self, FailedAllocation> {
        let Ok(offset) = isize::try_from(self.front_capacity) else {
            unreachable!("cannot allocate more than `isize::MAX` bytes");
        };

        let Some(offset) = offset.checked_neg() else {
            unreachable!("is a positive number => cannot be `isize::MIN`");
        };

        if self.shift(offset).is_err() {
            unreachable!("there is enough front capacity to shift into");
        }

        self.shrink_back(capacity)
    }

    /// Reallocate to reduce [`Self::capacity_front`] to exactly `capacity`.
    ///
    /// # Panics
    /// The Rust runtime might panic or otherwise abort if allocation fails.
    ///
    /// # Errors
    /// Yields [`FailedAllocation`] when memory (re)allocation fails.
    ///
    /// # Performance
    /// #### Time Complexity
    /// | Worst | Best | Average |
    /// | :-: | :-: | :-: |
    /// | O(N) | 𝛀(1) | 𝚯(N) |
    ///
    /// #### Memory Complexity
    /// | Worst | Best | Average |
    /// | :-: | :-: | :-: |
    /// | O(N) | 𝛀(1) | 𝚯(N) |
    ///
    /// # Examples
    /// ```
    /// use rust::structure::collection::linear::List;
    /// use rust::structure::collection::linear::array::Dynamic;
    ///
    /// let mut instance = Dynamic::<usize>::with_capacity(256).expect("successful allocation");
    ///
    /// // Half fill with elements.
    /// for element in 0..128 {
    ///     instance.prepend(element).expect("enough capacity");
    /// }
    ///
    /// assert_eq!(instance.capacity_front(), 128);
    /// assert_eq!(instance.capacity_back(), 0);
    ///
    /// // Shrink to have capacity of 64 elements at the front.
    /// instance.shrink_front(Some(64)).expect("successful reallocation");
    /// assert_eq!(instance.capacity_front(), 64);
    /// assert_eq!(instance.capacity_back(), 0);
    ///
    /// // Shrink to have no capacity (shrink to fit).
    /// instance.shrink_front(None).expect("successful reallocation");
    /// assert_eq!(instance.capacity_front(), 0);
    /// assert_eq!(instance.capacity_back(), 0);
    /// ```
    pub fn shrink_front(&mut self, capacity: usize) -> Result<&mut Self, FailedAllocation> {
        // When empty, there is do distinction between front and back capacity
        // instead referring to one continuous buffer of uninitialized
        // elements. To simplify the logic of this function, transparently
        // move all capacity to the back end.
        if self.initialized == 0 {
            let Some(total) = usize::checked_add(self.front_capacity, self.back_capacity) else {
                unreachable!("cannot allocate more than `isize::MAX` bytes")
            };

            self.front_capacity = 0;
            self.back_capacity = total;
        }

        let Some(extra) = self.capacity_front().checked_sub(capacity) else {
            debug_assert!(self.capacity_front() < capacity, "fewer capacity");

            return Err(FailedAllocation);
        };

        let Ok(extra) = isize::try_from(extra) else {
            unreachable!("cannot allocate more than `isize::MAX` bytes");
        };

        let Some(extra) = extra.checked_neg() else {
            unreachable!("positive number => cannot be `isize::MIN`");
        };

        if self.initialized != 0 {
            let Ok(_) = self.shift(extra) else {
                unreachable!("enough front capacity to shift into");
            };
        }

        self.resize(extra)
    }

    /// Reallocate to reduce back capacity to exactly `capacity` elements.
    ///
    /// # Panics
    /// The Rust runtime might panic or otherwise `abort` if allocation fails.
    ///
    /// # Errors
    /// Yields [`FailedAllocation`] when memory (re)allocation fails.
    ///
    /// # Performance
    /// #### Time Complexity
    /// | Worst | Best | Average |
    /// | :-: | :-: | :-: |
    /// | O(N) | 𝛀(1) | 𝚯(N) |
    ///
    /// #### Memory Complexity
    /// | Worst | Best | Average |
    /// | :-: | :-: | :-: |
    /// | O(N) | 𝛀(1) | 𝚯(N) |
    ///
    /// # Examples
    /// ```
    /// use rust::structure::collection::linear::array::Dynamic;
    /// use rust::structure::collection::linear::List;
    ///
    /// let mut instance = Dynamic::<usize>::with_capacity(256).expect("successful allocation");
    ///
    /// // Half fill with elements.
    /// instance.extend(0..128);
    ///
    /// assert_eq!(instance.capacity_front(), 0);
    /// assert_eq!(instance.capacity_back(), 128);
    ///
    /// // Shrink to have capacity of 64 elements at the front.
    /// instance.shrink_back(Some(64)).expect("successful reallocation");
    /// assert_eq!(instance.capacity_front(), 0);
    /// assert_eq!(instance.capacity_back(), 64);
    ///
    /// // Shrink to have no capacity (shrink to fit).
    /// instance.shrink_back(None).expect("successful reallocation");
    /// assert_eq!(instance.capacity_front(), 0);
    /// assert_eq!(instance.capacity_back(), 0);
    /// ```
    pub fn shrink_back(&mut self, capacity: usize) -> Result<&mut Self, FailedAllocation> {
        // When empty, there is do distinction between front and back capacity
        // instead referring to one continuous buffer of uninitialized
        // elements. To simplify the logic of this function, transparently
        // move all capacity to the back end.
        if self.initialized == 0 {
            let Some(total) = usize::checked_add(self.front_capacity, self.back_capacity) else {
                unreachable!("cannot allocate more than `isize::MAX` bytes")
            };

            self.front_capacity = 0;
            self.back_capacity = total;
        }

        let Some(extra) = self.capacity_back().checked_sub(capacity) else {
            debug_assert!(self.capacity_back() < capacity, "fewer capacity");

            return Err(FailedAllocation);
        };

        let Ok(extra) = isize::try_from(extra) else {
            unreachable!("cannot allocate more than `isize::MAX` bytes");
        };

        let Some(extra) = extra.checked_neg() else {
            unreachable!("is positive => cannot be `isize::MIN`");
        };

        self.resize(extra)
    }

    /// Shift the initialized elements `offset` positions within the buffer.
    ///
    /// This method maintains the order of initialized elements, but shifts
    /// them thereby converting some portion of the capacity from front to
    /// back, or vice versa.
    ///
    /// # Errors
    /// Yields [`OutOfBounds`] is there is not enough capacity to shift into.
    ///
    /// # Performance
    /// #### Time Complexity
    /// | Worst | Best | Average |
    /// | :-: | :-: | :-: |
    /// | O(N) | 𝛀(1) | 𝚯(N) |
    ///
    /// #### Memory Complexity
    /// | Worst | Best | Average |
    /// | :-: | :-: | :-: |
    /// | O(1) | 𝛀(1) | 𝚯(1) |
    ///
    /// # Examples
    /// ```
    /// use rust::structure::collection::linear::List;
    /// use rust::structure::collection::linear::array::Dynamic;
    ///
    /// let mut instance = Dynamic::<usize>::with_capacity(256).expect("successful allocation");
    ///
    /// // Fill with elements.
    /// instance.extend(0..256);
    ///
    /// // Allocate capacity at both ends.
    /// instance.reserve_front(256).expect("successful allocation");
    /// instance.reserve_back(256).expect("successful allocation");
    ///
    /// // Shift initialized elements to the front of the buffer.
    /// instance.shift(-256).expect("offset <= capacity_front()");
    /// instance.shift(-1).expect_err("offset out of bounds");
    /// assert_eq!(instance.capacity_front(), 0);
    /// assert_eq!(instance.capacity_back(), 512);
    ///
    /// // Shift initialized elements to the end of the buffer.
    /// instance.shift(512).expect("offset <= capacity_back()");
    /// instance.shift(1).expect_err("offset out of bounds");
    /// assert_eq!(instance.capacity_front(), 512);
    /// assert_eq!(instance.capacity_back(), 0);
    /// ```
    pub fn shift(&mut self, offset: isize) -> Result<&mut Self, OutOfBounds> {
        match offset.cmp(&0) {
            // Shifting to the left.
            core::cmp::Ordering::Less => {
                if let Some(capacity) = self.front_capacity.checked_sub(offset.unsigned_abs()) {
                    self.front_capacity = capacity;
                } else {
                    debug_assert!(
                        offset.unsigned_abs() > self.front_capacity,
                        "not enough capacity to shift into"
                    );

                    return Err(OutOfBounds);
                }

                if let Some(capacity) = self.back_capacity.checked_add(offset.unsigned_abs()) {
                    self.back_capacity = capacity;
                } else {
                    unreachable!("cannot allocate more than `isize::MAX` bytes");
                }
            }
            // Shifting to the right.
            core::cmp::Ordering::Greater => {
                if let Some(capacity) = self.back_capacity.checked_sub(offset.unsigned_abs()) {
                    self.back_capacity = capacity;
                } else {
                    debug_assert!(
                        offset.unsigned_abs() > self.back_capacity,
                        "not enough capacity to shift into"
                    );

                    return Err(OutOfBounds);
                }

                if let Some(capacity) = self.front_capacity.checked_add(offset.unsigned_abs()) {
                    self.front_capacity = capacity;
                } else {
                    unreachable!("cannot allocate more than `isize::MAX` bytes");
                }
            }
            // No shifting.
            core::cmp::Ordering::Equal => return Ok(self),
        }

        let destination = self.as_mut_ptr();

        let Some(offset) = offset.checked_neg() else {
            return Err(OutOfBounds);
        };

        // SAFETY: offset is in bounds => aligned within the allocated object.
        let source = unsafe { destination.offset(offset) };

        // SAFETY:
        // * owned memory => source/destination valid for read/writes.
        // * no aliasing restrictions => source and destination can overlap.
        // * underlying buffer is aligned => both pointers are aligned.
        unsafe {
            core::ptr::copy(source, destination, self.initialized);
        }

        Ok(self)
    }

    /// Remove an element by swapping it with the first element.
    ///
    /// In contrast to [`Self::remove`], this method takes constant time and
    /// does _NOT_ preserve order.
    ///
    /// # Performance
    /// #### Time Complexity
    /// | Worst | Best | Average |
    /// | :-: | :-: | :-: |
    /// | O(1) | 𝛀(1) | 𝚯(1) |
    ///
    /// #### Memory Complexity
    /// | Worst | Best | Average |
    /// | :-: | :-: | :-: |
    /// | O(1) | 𝛀(1) | 𝚯(1) |
    ///
    /// # Examples
    /// ```
    /// use rust::structure::collection::linear::array::Dynamic;
    ///
    /// let mut instance = Dynamic::from_iter([0, 1, 2, 3, 4, 5]);
    ///
    /// assert_eq!(instance.remove_via_front(3), Some(3));
    /// assert_eq!(instance.capacity_front(), 1);
    /// assert_eq!(instance[2], 0);
    /// ```
    #[must_use]
    pub fn remove_via_front(&mut self, index: usize) -> Option<T> {
        if index >= self.initialized {
            return None;
        }

        // SAFETY: valid capacity => aligned within the allocated object.
        let mut first = unsafe { self.buffer.add(self.front_capacity) };

        // SAFETY: index in bounds => aligned within the allocated object.
        let index = unsafe { first.add(index) };

        // SAFETY:
        // * Both pointers are valid for reads and write.
        // * Both pointers are aligned.
        // * No aliasing restrictions.
        unsafe { NonNull::swap(first, index); }

        // SAFETY:
        // * Owned memory => valid for reads and writes.
        // * Underlying `MaybeUninit<T>` is initialized.
        // * Has mutable reference to self => no other reference exists.
        let element = unsafe { first.as_mut() };

        // SAFETY:
        // * Index in bounds => underlying `T` is initialized.
        // * Element is prevented from being read after this move.
        let element = unsafe { element.assume_init_read() };

        if let Some(decremented) = self.initialized.checked_sub(1) {
            self.initialized = decremented;
        } else {
            unreachable!("there is at least the element being removed");
        }

        if let Some(incremented) = self.front_capacity.checked_add(1) {
            self.front_capacity = incremented;
        } else {
            unreachable!("cannot allocate more that `isize::MAX` bytes");
        }

        Some(element)
    }

    /// Remove an element by swapping it with the last element.
    ///
    /// In contrast to [`Self::remove`], this method takes constant time and
    /// does _NOT_ preserve order.
    ///
    /// # Performance
    /// #### Time Complexity
    /// | Worst | Best | Average |
    /// | :-: | :-: | :-: |
    /// | O(1) | 𝛀(1) | 𝚯(1) |
    ///
    /// #### Memory Complexity
    /// | Worst | Best | Average |
    /// | :-: | :-: | :-: |
    /// | O(1) | 𝛀(1) | 𝚯(1) |
    ///
    /// # Examples
    /// ```
    /// use rust::structure::collection::linear::array::Dynamic;
    ///
    /// let mut instance = Dynamic::from_iter([0, 1, 2, 3, 4, 5]);
    ///
    /// assert_eq!(instance.remove_via_back(3), Some(3));
    /// assert_eq!(instance.capacity_back(), 1);
    /// assert_eq!(instance[3], 5);
    /// ```
    #[must_use]
    pub fn remove_via_back(&mut self, index: usize) -> Option<T> {
        if index >= self.initialized {
            return None;
        }

        // SAFETY: valid capacity => aligned within the allocated object.
        let first = unsafe { self.buffer.add(self.front_capacity) };

        let mut last = {
            let Some(offset) = self.initialized.checked_sub(1) else {
                unreachable!("at least one initialized element");
            };

            // SAFETY: aligned within the allocated object.
            unsafe { first.add(offset) }
        };

        // SAFETY: index in bounds => aligned within the allocated object.
        let index = unsafe { first.add(index) };

        // SAFETY:
        // * Both pointers are valid for reads and write.
        // * Both pointers are aligned.
        // * No aliasing restrictions.
        unsafe { NonNull::swap(last, index); }

        // SAFETY:
        // * Owned memory => valid for reads and writes.
        // * Underlying `MaybeUninit<T>` is initialized.
        // * Has mutable reference to self => no other reference exists.
        let element = unsafe { last.as_mut() };

        // SAFETY:
        // * Index in bounds => underlying `T` is initialized.
        // * Element is prevented from being read after this move.
        let element = unsafe { element.assume_init_read() };

        if let Some(decremented) = self.initialized.checked_sub(1) {
            self.initialized = decremented;
        } else {
            unreachable!("there is at least the element being removed");
        }

        if let Some(incremented) = self.back_capacity.checked_add(1) {
            self.back_capacity = incremented;
        } else {
            unreachable!("cannot allocate more that `isize::MAX` bytes");
        }

        Some(element)
    }

    /// Exactly how much back capacity to allocate to apply amortized analysis.
    ///
    /// See also: [amortized analysis][amortized] and [dynamic array application][dynamic].
    ///
    /// # Performance
    /// #### Time Complexity
    /// | Worst | Best | Average |
    /// | :-: | :-: | :-: |
    /// | O(1) | 𝛀(1) | 𝚯(1) |
    ///
    /// #### Memory Complexity
    /// | Worst | Best | Average |
    /// | :-: | :-: | :-: |
    /// | O(1) | 𝛀(1) | 𝚯(1) |
    ///
    /// [amortized]: https://en.wikipedia.org/wiki/Amortized_analysis
    /// [dynamic]: https://en.wikipedia.org/wiki/Dynamic_array#Geometric_expansion_and_amortized_cost
    #[inline]
    #[must_use]
    fn amortized(&self, capacity: usize) -> Option<usize> {
        let Some(retained) = self.front_capacity.checked_add(self.initialized) else {
            unreachable!("cannot allocate more the `isize::MAX` bytes");
        };

        let total = retained.checked_add(capacity)?;

        let total = total.checked_next_power_of_two()?;

        total.checked_sub(retained)
    }

    /// Shift the elements within `range` left or right by `offset`.
    ///
    /// Note this does _NOT_ modify internal capacity state.
    ///
    /// # Safety
    /// * The `range` must refer to initialized elements.
    /// * Must remain in the allocated object whe moved `offset` positions.
    /// * Must not overwrite initialized elements outside of the `range`.
    ///
    /// # Performance
    /// #### Time Complexity
    /// | Worst | Best | Average |
    /// | :-: | :-: | :-: |
    /// | O(N) | 𝛀(1) | 𝚯(N) |
    ///
    /// #### Memory Complexity
    /// | Worst | Best | Average |
    /// | :-: | :-: | :-: |
    /// | O(1) | 𝛀(1) | 𝚯(1) |
    #[inline]
    unsafe fn shift_range(&mut self, range: impl core::ops::RangeBounds<usize>, offset: isize) {
        // TODO: various debug asserts have been added to verify safety within
        // debug builds (tests). However, these are themselves untested and
        // have had some equal signs added to inequalities to make existing
        // tests pass so are not full thought out.

        // TODO: assert will not overwrite other initialized elements.

        let start = match range.start_bound() {
            core::ops::Bound::Unbounded => 0,
            core::ops::Bound::Included(start) => *start,
            core::ops::Bound::Excluded(start) => start.saturating_add(1),
        };

        let end = match range.end_bound() {
            core::ops::Bound::Unbounded => self.initialized,
            core::ops::Bound::Included(end) => end.saturating_add(1),
            core::ops::Bound::Excluded(end) => *end,
        };

        debug_assert!(end >= start, "range must be a positive number of elements");

        let elements = end.abs_diff(start);

        debug_assert!(self.front_capacity > 0 || self.initialized > 0 || self.back_capacity > 0, "there must be an allocation for the following pointer operations to be safe");

        // SAFETY: allocation exists => aligned within the allocated object.
        let first = unsafe { self.buffer.add(self.front_capacity) };

        debug_assert!(start <= self.initialized && end <= self.initialized, "range must be within bounds of initialized elements");

        // SAFETY: valid range => stay aligned within the allocated object.
        let source = unsafe { first.add(start) };

        debug_assert!(if offset.is_negative() {
            self.front_capacity.checked_add(start) >= Some(offset.unsigned_abs())
        } else {
            start.checked_add(elements).and_then(|sum| sum.checked_add(offset.unsigned_abs())) <= self.initialized.checked_add(self.back_capacity)
        }, "offsetting the elements must stay within the allocated object");

        // SAFETY: stays aligned within the allocated object.
        let destination = unsafe { source.offset(offset) };

        // SAFETY:
        // * Source is valid to read `elements` instances of `T`.
        // * Destination is valid to write `elements` instance of `T`.
        // * No aliasing restrictions because ranges can overlap.
        unsafe { source.copy_to(destination, elements); }
    }

    /// (Re)allocate the buffer to modify back capacity by `capacity`.
    ///
    /// This method is the underlying way to modify the allocation. It works by
    /// increasing or decreasing the amount of back capacity hence it will not
    /// modify front capacity of overwrite initialized elements. Back capacity
    /// will be increased by `capacity` if positive and decreased by `capacity`
    /// if negative. Not only will this reallocate to change the size of the
    /// buffer, but it will also do the initial allocation if none exists, and
    /// deallocation if there is no front capacity and initialized elements.
    ///
    /// Note that failed allocation will _NOT_ modify the underlying buffer.
    ///
    /// # Panics
    /// The Rust runtime might panic or otherwise abort if allocation fails.
    ///
    /// # Performance
    /// #### Time Complexity
    /// | Worst | Best | Average |
    /// | :-: | :-: | :-: |
    /// | O(N) | 𝛀(1) | 𝚯(N) |
    ///
    /// #### Memory Complexity
    /// | Worst | Best | Average |
    /// | :-: | :-: | :-: |
    /// | O(N) | 𝛀(1) | 𝚯(N) |
    #[inline]
    fn resize(&mut self, capacity: isize) -> Result<&mut Self, FailedAllocation> {
        let capacity = self
            .back_capacity
            .checked_add_signed(capacity)
            .ok_or(FailedAllocation)?;

        let Some(unchanged) = usize::checked_add(self.front_capacity, self.initialized) else {
            unreachable!("cannot allocate more than `isize::MAX` bytes");
        };

        // Zero-size types do _NOT_ occupy memory, so no (re/de)allocation.
        if size_of::<T>() == 0 {
            // The global allocator API limits allocations to at most
            // `isize::MAX` bytes. Although this limit could be ignored for
            // ZSTs since they do not occupy memory, there are various
            // restrictions to pointer arithmetic based on the assumption no
            // single allocated object will exceed `isize::MAX` bytes.
            // Accordingly, we limit the number of ZST elements to match so
            // all arithmetic can be consistent regardless of underlying type.
            if usize::checked_add(unchanged, capacity).is_some_and(|total| total > isize::MAX as usize) {
                return Err(FailedAllocation);
            }

            self.back_capacity = capacity;

            return Ok(self);
        }

        let new = {
            let total = unchanged.checked_add(capacity).ok_or(FailedAllocation)?;

            match core::alloc::Layout::array::<T>(total) {
                Ok(layout) => layout,
                Err(_) => return Err(FailedAllocation),
            }
        };

        let Some(total) = unchanged.checked_add(self.back_capacity) else {
            unreachable!("cannot allocate more than `isize::MAX` bytes");
        };

        let ptr = {
            // No previous allocation exists, so create one.
            if total == 0 {
                if new.size() > 0 {
                    // SAFETY: layout has non-zero size.
                    unsafe { alloc::alloc::alloc(new) }.cast::<T>()
                } else {
                    debug_assert_eq!(capacity, 0, "otherwise occupies memory");

                    // self is empty => pointer will _NOT_ be read/written to.
                    NonNull::<T>::dangling().as_ptr()
                }
            }
            // Modify an existing buffer allocation.
            else {
                let Ok(existing) = core::alloc::Layout::array::<T>(total) else {
                    unreachable!("this is the layout of the existing allocation");
                };

                let ptr = self.buffer.as_ptr().cast::<u8>();

                // Deallocate.
                if unchanged == 0 && capacity == 0 {
                    // SAFETY:
                    // * Allocated using the corresponding allocator.
                    // * `existing` is the layout of the current allocation.
                    // * `existing` has non-zero size.
                    unsafe {
                        alloc::alloc::dealloc(ptr, existing);
                    }

                    // self is empty => pointer will _NOT_ be read/written to.
                    NonNull::<T>::dangling().as_ptr()
                }
                // Reallocate.
                else {
                    // SAFETY:
                    // * Allocated using the corresponding allocator.
                    // * `existing` is the layout of the current allocation.
                    // * `new` has non-zero size.
                    // * `new` is fewer than `isize::MAX` bytes.
                    unsafe { alloc::alloc::realloc(ptr, existing, new.size()) }.cast::<T>()
                }
            }
        };

        // `MaybeUninit<T>` has the same layout as `T`.
        let ptr = ptr.cast::<MaybeUninit<T>>();

        // Null pointer => allocation failed.
        self.buffer = match NonNull::new(ptr) {
            Some(ptr) => ptr,
            None => return Err(FailedAllocation),
        };

        self.back_capacity = capacity;

        Ok(self)
    }
}

impl<T> Default for Dynamic<T> {
    /// Construct an instance with no elements and no capacity/allocation.
    ///
    /// # Performance
    /// #### Time Complexity
    /// | Worst | Best | Average |
    /// | :-: | :-: | :-: |
    /// | O(1) | 𝛀(1) | 𝚯(1) |
    ///
    /// #### Memory Complexity
    /// | Worst | Best | Average |
    /// | :-: | :-: | :-: |
    /// | O(1) | 𝛀(1) | 𝚯(1) |
    ///
    /// # Examples
    /// ```
    /// use rust::structure::collection::linear::array::Dynamic;
    ///
    /// let instance = Dynamic::<()>::default();
    ///
    /// assert_eq!(instance.len(), 0);
    /// assert_eq!(instance.capacity(), 0);
    /// ```
    fn default() -> Self {
        Self {
            buffer: NonNull::dangling(),
            front_capacity: 0,
            initialized: 0,
            back_capacity: 0,
        }
    }
}

impl<'a, T: 'a + Clone> TryFrom<&'a [T]> for Dynamic<T> {
    type Error = FailedAllocation;

    /// Construct by cloning elements from an existing slice.
    ///
    /// # Panics
    /// The Rust runtime might panic or otherwise abort if allocation fails.
    ///
    /// # Performance
    /// #### Time Complexity
    /// | Worst | Best | Average |
    /// | :-: | :-: | :-: |
    /// | O(N) | 𝛀(N) | 𝚯(N) |
    ///
    /// #### Memory Complexity
    /// | Worst | Best | Average |
    /// | :-: | :-: | :-: |
    /// | O(N) | 𝛀(N) | 𝚯(N) |
    ///
    /// # Examples
    /// ```
    /// use rust::structure::collection::linear::array::Dynamic;
    ///
    /// let expected = [0, 1, 2, 3, 4, 5];
    /// let actual = Dynamic::try_from(expected.as_slice()).expect("successful allocation");
    ///
    /// assert!(actual.eq(expected));
    /// ```
    fn try_from(slice: &'a [T]) -> Result<Self, Self::Error> {
        let mut instance = Self::with_capacity(slice.len())?;

        instance.extend(slice.iter().cloned());

        Ok(instance)
    }
}

impl<T> FromIterator<T> for Dynamic<T> {
    /// Construct by moving elements from an iterator.
    ///
    /// # Panics
    /// The Rust runtime might abort if allocation fails, panics otherwise.
    ///
    /// # Performance
    /// #### Time Complexity
    /// | Worst | Best | Average |
    /// | :-: | :-: | :-: |
    /// | O(N) | 𝛀(N) | 𝚯(N) |
    ///
    /// #### Memory Complexity
    /// | Worst | Best | Average |
    /// | :-: | :-: | :-: |
    /// | O(N) | 𝛀(N) | 𝚯(N) |
    ///
    /// # Examples
    /// ```
    /// use rust::structure::collection::linear::array::Dynamic;
    ///
    /// let expected = [0, 1, 2, 3, 4, 5];
    ///
    /// let actual: Dynamic<_> = expected.clone().into_iter().collect();
    ///
    /// assert!(actual.eq(expected))
    /// ```
    fn from_iter<Iter: IntoIterator<Item = T>>(iter: Iter) -> Self {
        let mut instance = Self::default();

        instance.extend(iter);

        instance
    }
}

impl<T> Extend<T> for Dynamic<T> {
    /// Append elements of an iterator in order.
    ///
    /// # Panics
    /// The Rust runtime might abort if allocation fails, panics otherwise.
    ///
    /// # Performance
    /// #### Time Complexity
    /// | Worst | Best | Average |
    /// | :-: | :-: | :-: |
    /// | O(N) | 𝛀(N) | 𝚯(N) |
    ///
    /// #### Memory Complexity
    /// | Worst | Best | Average |
    /// | :-: | :-: | :-: |
    /// | O(N) | 𝛀(N) | 𝚯(N) |
    ///
    /// # Examples
    /// ```
    /// use rust::structure::collection::linear::array::Dynamic;
    ///
    /// let expected = [0, 1, 2, 3, 4, 5];
    ///
    /// let mut instance = Dynamic::<i32>::default();
    ///
    /// instance.extend(expected.iter().cloned());
    ///
    /// assert!(instance.eq(expected))
    /// ```
    fn extend<Iter: IntoIterator<Item = T>>(&mut self, iter: Iter) {
        let iter = iter.into_iter();

        // `size_hint` can _NOT_ be trusted.
        let count = {
            let (min, max) = iter.size_hint();
            max.unwrap_or(min)
        };

        // Append will allocate for each realized element if reserve fails.
        drop(self.reserve_back(count));

        for element in iter {
            assert!(self.append(element).is_ok(), "allocation failed");
        }
    }
}

impl<T: Clone> Clone for Dynamic<T> {
    /// Construct and instance with clones of all elements.
    ///
    /// # Panics
    /// The Rust runtime might abort if allocation fails, panics otherwise.
    ///
    /// # Performance
    /// #### Time Complexity
    /// | Worst | Best | Average |
    /// | :-: | :-: | :-: |
    /// | O(N) | 𝛀(N) | 𝚯(N) |
    ///
    /// #### Memory Complexity
    /// | Worst | Best | Average |
    /// | :-: | :-: | :-: |
    /// | O(N) | 𝛀(N) | 𝚯(N) |
    ///
    /// # Examples
    /// ```
    /// use rust::structure::collection::linear::array::Dynamic;
    ///
    /// let expected = Dynamic::from_iter([0, 1, 2, 3, 4, 5]);
    ///
    /// assert_eq!(expected.clone(), expected)
    /// ```
    fn clone(&self) -> Self {
        let mut clone = Self::default();

        clone.extend(self.iter().cloned());

        clone
    }
}

impl<T: PartialEq> PartialEq for Dynamic<T> {
    /// Query if the elements contained are the same as `other`.
    ///
    /// # Performance
    /// #### Time Complexity
    /// | Worst | Best | Average |
    /// | :-: | :-: | :-: |
    /// | O(N) | 𝛀(N) | 𝚯(N) |
    ///
    /// #### Memory Complexity
    /// | Worst | Best | Average |
    /// | :-: | :-: | :-: |
    /// | O(1) | 𝛀(1) | 𝚯(1) |
    ///
    /// # Examples
    /// ```
    /// use rust::structure::collection::linear::array::Dynamic;
    ///
    /// let left = [0, 1, 2, 3, 4, 5];
    /// let right = left.clone();
    ///
    /// let left = Dynamic::from_iter(left);
    /// let right = Dynamic::from_iter(right);
    ///
    /// assert_eq!(left, right);
    /// ```
    fn eq(&self, other: &Self) -> bool {
        self.iter().eq(other.iter())
    }
}

impl<T: Eq> Eq for Dynamic<T> {}

impl<T> core::ops::Index<usize> for Dynamic<T> {
    type Output = T;

    /// Obtain a reference to the element `index` positions from the start.
    ///
    /// # Panics
    /// This method has the precondition that the `index` is within bounds.
    ///
    /// # Performance
    /// #### Time Complexity
    /// | Worst | Best | Average |
    /// | :-: | :-: | :-: |
    /// | O(1) | 𝛀(1) | 𝚯(1) |
    ///
    /// #### Memory Complexity
    /// | Worst | Best | Average |
    /// | :-: | :-: | :-: |
    /// | O(1) | 𝛀(1) | 𝚯(1) |
    ///
    /// # Examples
    /// ```
    /// use rust::structure::collection::linear::array::Dynamic;
    ///
    /// let expected = [0, 1, 2, 3, 4, 5];
    /// let actual = Dynamic::from_iter(expected.iter().copied());
    ///
    /// for index in 0..expected.len() {
    ///     use core::ops::Index;
    ///     assert_eq!(actual.index(index), expected.index(index));
    /// }
    /// ```
    fn index(&self, index: usize) -> &Self::Output {
        assert!(index < self.initialized, "index out of bounds");

        let buffer = self.buffer;

        // SAFETY: allocation exists => aligned within the allocated object.
        let first = unsafe { buffer.add(self.front_capacity) };

        // SAFETY: index in bounds => aligned within the allocated object.
        let index = unsafe { first.add(index) };

        // SAFETY:
        // * The `MaybeUninit<T>` is initialized.
        // * The lifetime is bound to self.
        let element = unsafe { index.as_ref() };

        // SAFETY: The underlying `T` is initialized.
        unsafe { element.assume_init_ref() }
    }
}

impl<T> core::ops::IndexMut<usize> for Dynamic<T> {
    /// Obtain a reference to the element `index` positions from the start.
    ///
    /// # Panics
    /// This method has the precondition that the `index` is within bounds.
    ///
    /// # Performance
    /// #### Time Complexity
    /// | Worst | Best | Average |
    /// | :-: | :-: | :-: |
    /// | O(1) | 𝛀(1) | 𝚯(1) |
    ///
    /// #### Memory Complexity
    /// | Worst | Best | Average |
    /// | :-: | :-: | :-: |
    /// | O(1) | 𝛀(1) | 𝚯(1) |
    ///
    /// # Examples
    /// ```
    /// use rust::structure::collection::linear::array::Dynamic;
    ///
    /// let mut expected = [0, 1, 2, 3, 4, 5];
    /// let mut actual = Dynamic::from_iter(expected.iter().copied());
    ///
    /// for index in 0..expected.len() {
    ///     use core::ops::IndexMut;
    ///     assert_eq!(actual.index_mut(index), expected.index_mut(index));
    /// }
    /// ```
    fn index_mut(&mut self, index: usize) -> &mut Self::Output {
        assert!(index < self.initialized, "index out of bounds");

        let buffer = self.buffer;

        // SAFETY: allocation exists => aligned within the allocated object.
        let first = unsafe { buffer.add(self.front_capacity) };

        // SAFETY: index in bounds => aligned within the allocated object.
        let mut index = unsafe { first.add(index) };

        // SAFETY:
        // * The `MaybeUninit<T>` is initialized.
        // * The lifetime is bound to self.
        let element = unsafe { index.as_mut() };

        // SAFETY: The underlying `T` is initialized.
        unsafe { element.assume_init_mut() }
    }
}

impl<T> Iterator for Dynamic<T> {
    type Item = T;

    /// Remove the leftmost element, if any.
    ///
    /// # Performance
    /// #### Time Complexity
    /// | Worst | Best | Average |
    /// | :-: | :-: | :-: |
    /// | O(1) | 𝛀(1) | 𝚯(1) |
    ///
    /// #### Memory Complexity
    /// | Worst | Best | Average |
    /// | :-: | :-: | :-: |
    /// | O(1) | 𝛀(1) | 𝚯(1) |
    ///
    /// # Examples
    /// ```
    /// use rust::structure::collection::linear::array::Dynamic;
    ///
    /// let mut instance = Dynamic::from_iter([0, 1, 2, 3, 4, 5]).into_iter();
    ///
    /// assert_eq!(instance.next(), Some(0));
    /// assert_eq!(instance.next(), Some(1));
    /// assert_eq!(instance.next(), Some(2));
    /// assert_eq!(instance.next(), Some(3));
    /// assert_eq!(instance.next(), Some(4));
    /// assert_eq!(instance.next(), Some(5));
    /// assert_eq!(instance.next(), None);
    /// ```
    fn next(&mut self) -> Option<Self::Item> {
        (self.initialized > 0).then(|| {
            // SAFETY: stays aligned within the allocated object.
            let mut first = unsafe { self.buffer.add(self.front_capacity) };

            if let Some(decremented) = self.initialized.checked_sub(1) {
                self.initialized = decremented;
            } else {
                unreachable!("at least one initialized element");
            }

            if let Some(incremented) = self.front_capacity.checked_add(1) {
                self.front_capacity = incremented;
            } else {
                unreachable!("cannot allocate more than `isize::MAX` bytes");
            }

            // SAFETY:
            // * The `MaybeUninit<T>` is initialized.
            // * We have a unique mutable reference to self and the element.
            let element = unsafe { first.as_mut() };

            // SAFETY:
            // * The underlying `T` is initialized.
            // * Element is prevented from being read after this move.
            unsafe { element.assume_init_read() }
        })
    }

    /// Query how many elements have yet to be yielded.
    ///
    /// # Performance
    /// #### Time Complexity
    /// | Worst | Best | Average |
    /// | :-: | :-: | :-: |
    /// | O(1) | 𝛀(1) | 𝚯(1) |
    ///
    /// #### Memory Complexity
    /// | Worst | Best | Average |
    /// | :-: | :-: | :-: |
    /// | O(1) | 𝛀(1) | 𝚯(1) |
    ///
    /// # Examples
    /// ```
    /// use rust::structure::collection::linear::array::Dynamic;
    ///
    /// let mut instance = Dynamic::from_iter([0, 1, 2, 3, 4, 5]).into_iter();
    ///
    /// assert_eq!(instance.size_hint(), (6, Some(6)));
    /// ```
    fn size_hint(&self) -> (usize, Option<usize>) {
        (self.initialized, Some(self.initialized))
    }
}

impl<T> DoubleEndedIterator for Dynamic<T> {
    /// Remove the rightmost element, if any.
    ///
    /// # Performance
    /// #### Time Complexity
    /// | Worst | Best | Average |
    /// | :-: | :-: | :-: |
    /// | O(1) | 𝛀(1) | 𝚯(1) |
    ///
    /// #### Memory Complexity
    /// | Worst | Best | Average |
    /// | :-: | :-: | :-: |
    /// | O(1) | 𝛀(1) | 𝚯(1) |
    ///
    /// # Examples
    /// ```
    /// use rust::structure::collection::linear::array::Dynamic;
    ///
    /// let mut instance = Dynamic::from_iter([0, 1, 2, 3, 4, 5]).into_iter();
    ///
    /// assert_eq!(instance.next_back(), Some(5));
    /// assert_eq!(instance.next_back(), Some(4));
    /// assert_eq!(instance.next_back(), Some(3));
    /// assert_eq!(instance.next_back(), Some(2));
    /// assert_eq!(instance.next_back(), Some(1));
    /// assert_eq!(instance.next_back(), Some(0));
    /// assert_eq!(instance.next_back(), None);
    /// ```
    fn next_back(&mut self) -> Option<Self::Item> {
        (self.initialized > 0).then(|| {
            if let Some(decremented) = self.initialized.checked_sub(1) {
                self.initialized = decremented;
            } else {
                unreachable!("at least one initialized element");
            }

            if let Some(incremented) = self.back_capacity.checked_add(1) {
                self.back_capacity = incremented;
            } else {
                unreachable!("cannot allocate more than `isize::MAX` bytes");
            }

            // SAFETY: stays aligned within the allocated object.
            let first = unsafe { self.buffer.add(self.front_capacity) };

            // SAFETY: stays aligned within the allocated object.
            let mut last = unsafe { first.add(self.initialized) };

            // SAFETY:
            // * The `MaybeUninit<T>` is initialized.
            // * We have a unique mutable reference to self and the element.
            let element = unsafe { last.as_mut() };

            // SAFETY:
            // * The underlying `T` is initialized.
            // * Element is prevented from being read after this move.
            unsafe { element.assume_init_read() }
        })
    }
}

impl<T> ExactSizeIterator for Dynamic<T> {}

impl<T> core::iter::FusedIterator for Dynamic<T> {}

impl<T> Drop for Dynamic<T> {
    /// Drops the elements that are initialized and deallocates memory.
    ///
    /// # Performance
    /// #### Time Complexity
    /// | Worst | Best | Average |
    /// | :-: | :-: | :-: |
    /// | O(N) | 𝛀(N) | 𝚯(N) |
    ///
    /// #### Memory Complexity
    /// | Worst | Best | Average |
    /// | :-: | :-: | :-: |
    /// | O(1) | 𝛀(1) | 𝚯(1) |
    ///
    /// # Examples
    /// ```
    /// use rust::structure::collection::linear::array::Dynamic;
    ///
    /// let mut instance = Dynamic::from_iter([0, 1, 2, 3, 4, 5]);
    ///
    /// instance.next();      // Consumes the element with value `0`.
    /// instance.next_back(); // Consumes the element with value `5`.
    ///
    /// core::mem::drop(instance); // Drops the elements with values `[1, 2, 3, 4]`.
    /// ```
    fn drop(&mut self) {
        self.by_ref().for_each(drop);

        let Ok(_) = self.shrink(0) else {
            unreachable!("deallocation cannot fail");
        };
    }
}

impl<T: core::fmt::Debug> core::fmt::Debug for Dynamic<T> {
    /// List the elements contained.
    ///
    /// # Performance
    /// #### Time Complexity
    /// | Worst | Best | Average |
    /// | :-: | :-: | :-: |
    /// | O(N) | 𝛀(N) | 𝚯(N) |
    ///
    /// #### Memory Complexity
    /// | Worst | Best | Average |
    /// | :-: | :-: | :-: |
    /// | O(N) | 𝛀(N) | 𝚯(N) |
    ///
    /// # Examples
    /// ```
    /// use rust::structure::collection::linear::array::Dynamic;
    ///
    /// let mut expected = [0, 1, 2, 3, 4, 5];
    /// let actual = Dynamic::from_iter(expected.iter());
    ///
    /// assert_eq!(format!("{actual:?}"), format!("{expected:?}"));
    /// ```
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.debug_list().entries(self.iter()).finish()
    }
}

impl<T> Collection for Dynamic<T> {
    type Element = T;

    /// Query the number of initialized elements contained.
    ///
    /// # Performance
    /// #### Time Complexity
    /// | Worst | Best | Average |
    /// | :-: | :-: | :-: |
    /// | O(1) | 𝛀(1) | 𝚯(1) |
    ///
    /// #### Memory Complexity
    /// | Worst | Best | Average |
    /// | :-: | :-: | :-: |
    /// | O(1) | 𝛀(1) | 𝚯(1) |
    ///
    ///
    /// # Examples
    /// ```
    /// use rust::structure::Collection;
    /// use rust::structure::collection::linear::array::Dynamic;
    ///
    /// let expected = [0, 1, 2, 3, 4, 5];
    /// let instance = Dynamic::from_iter(expected.clone());
    ///
    /// assert_eq!(Collection::count(&instance), expected.len());
    /// ```
    fn count(&self) -> usize {
        self.initialized
    }
}

impl<T> Linear for Dynamic<T> {
    /// Create an immutable iterator over the initialized elements.
    ///
    /// # Performance
    /// #### Time Complexity
    /// | Worst | Best | Average |
    /// | :-: | :-: | :-: |
    /// | O(1) | 𝛀(1) | 𝚯(1) |
    ///
    /// #### Memory Complexity
    /// | Worst | Best | Average |
    /// | :-: | :-: | :-: |
    /// | O(1) | 𝛀(1) | 𝚯(1) |
    ///
    /// # Examples
    /// ```
    /// use rust::structure::collection::Linear;
    /// use rust::structure::collection::linear::array::Dynamic;
    ///
    /// let expected = [0, 1, 2, 3, 4, 5];
    /// let actual = Dynamic::from_iter(expected.clone());
    ///
    /// for (actual, expected) in actual.iter().zip(expected.iter()) {
    ///     assert_eq!(actual, expected);
    /// }
    /// ```
    fn iter(
        &self,
    ) -> impl DoubleEndedIterator<Item = &Self::Element> + ExactSizeIterator + core::iter::FusedIterator
    {
        let ptr = if self.initialized > 0 {
            // SAFETY: stays aligned with the allocated object.
            unsafe { self.buffer.add(self.front_capacity) }
        } else {
            // The pointer will not be read.
            NonNull::dangling()
        };

        // `MaybeUninit<T>` has the same memory layout as `T`.
        let ptr = ptr.cast::<T>();

        // SAFETY: points to a contigious buffer of initialized elements.
        unsafe { super::Iter::new(ptr, self.initialized) }
    }

    /// Create a mutable iterator over the initialized elements.
    ///
    /// # Performance
    /// #### Time Complexity
    /// | Worst | Best | Average |
    /// | :-: | :-: | :-: |
    /// | O(1) | 𝛀(1) | 𝚯(1) |
    ///
    /// #### Memory Complexity
    /// | Worst | Best | Average |
    /// | :-: | :-: | :-: |
    /// | O(1) | 𝛀(1) | 𝚯(1) |
    ///
    /// # Examples
    /// ```
    /// use rust::structure::collection::Linear;
    /// use rust::structure::collection::linear::array::Dynamic;
    ///
    /// let mut expected = [0, 1, 2, 3, 4, 5];
    /// let mut actual = Dynamic::from_iter(expected.clone());
    ///
    /// for (actual, expected) in actual.iter_mut().zip(expected.iter_mut()) {
    ///     assert_eq!(actual, expected);
    /// }
    /// ```
    fn iter_mut(
        &mut self,
    ) -> impl DoubleEndedIterator<Item = &mut Self::Element>
    + ExactSizeIterator
    + core::iter::FusedIterator {
        let ptr = if self.initialized > 0 {
            // SAFETY: stays aligned with the allocated object.
            unsafe { self.buffer.add(self.front_capacity) }
        } else {
            // The pointer will not be read.
            NonNull::dangling()
        };

        // `MaybeUninit<T>` has the same memory layout as `T`.
        let ptr = ptr.cast::<T>();

        // SAFETY: points to a contigious buffer of initialized elements.
        unsafe { super::IterMut::new(ptr, self.initialized) }
    }
}

impl<T> Array for Dynamic<T> {
    /// Obtain a pointer to the contigious initialized elements.
    ///
    /// # Safety
    /// * `self` must outlive the pointer.
    /// * The pointer must never be written to.
    /// * Modifying `self` might invalidate the pointer.
    ///
    /// # Panics
    /// If there is no underlying allocation to point to. Note that a dangling
    /// pointer will be given for zero-size types despite not occupying an
    /// allocation because Rust guarantees it is still valid to interact with.
    ///
    /// # Performance
    /// #### Time Complexity
    /// | Worst | Best | Average |
    /// | :-: | :-: | :-: |
    /// | O(1) | 𝛀(1) | 𝚯(1) |
    ///
    /// #### Memory Complexity
    /// | Worst | Best | Average |
    /// | :-: | :-: | :-: |
    /// | O(1) | 𝛀(1) | 𝚯(1) |
    ///
    /// # Examples
    /// ```
    /// use rust::structure::collection::linear::Array;
    /// use rust::structure::collection::linear::array::Dynamic;
    ///
    /// let mut instance = Dynamic::from_iter([0, 1, 2, 3, 4, 5]);
    ///
    /// let expected = core::ptr::from_ref(&instance[0]);
    /// let actual = unsafe { instance.as_ptr() };
    ///
    /// assert_eq!(actual, expected);
    /// ```
    fn as_ptr(&self) -> *const Self::Element {
        assert!(self.front_capacity > 0 || self.initialized > 0 || self.back_capacity > 0, "no allocation to point to");

        // SAFETY: aligned within the allocated object.
        let ptr = unsafe { self.buffer.add(self.front_capacity) };

        // `MaybeUninit<T>` has the same layout as `T`.
        let ptr = ptr.cast::<T>();

        ptr.as_ptr()
    }

    /// Obtain a pointer to the contigious initialized elements.
    ///
    /// # Safety
    /// * `self` must outlive the pointer.
    /// * Modifying `self` might invalidate the pointer.
    ///
    /// # Panics
    /// If there is no underlying allocation to point to. Note that a dangling
    /// pointer will be given for zero-size types despite not occupying an
    /// allocation because Rust guarantees it is still valid to interact with.
    ///
    /// # Performance
    /// #### Time Complexity
    /// | Worst | Best | Average |
    /// | :-: | :-: | :-: |
    /// | O(1) | 𝛀(1) | 𝚯(1) |
    ///
    /// #### Memory Complexity
    /// | Worst | Best | Average |
    /// | :-: | :-: | :-: |
    /// | O(1) | 𝛀(1) | 𝚯(1) |
    ///
    /// # Examples
    /// ```
    /// use rust::structure::collection::linear::Array;
    /// use rust::structure::collection::linear::array::Dynamic;
    ///
    /// let mut instance = Dynamic::from_iter([0, 1, 2, 3, 4, 5]);
    ///
    /// let expected = core::ptr::from_ref(&instance[0]).cast_mut();
    /// let actual = unsafe { instance.as_mut_ptr() };
    ///
    /// assert_eq!(actual, expected);
    /// ```
    fn as_mut_ptr(&mut self) -> *mut Self::Element {
        assert!(self.front_capacity > 0 || self.initialized > 0 || self.back_capacity > 0, "no allocation to point to");

        // SAFETY: aligned within the allocated object.
        let ptr = unsafe { self.buffer.add(self.front_capacity) };

        // `MaybeUninit<T>` has the same layout as `T`.
        let ptr = ptr.cast::<T>();

        ptr.as_ptr()
    }
}

impl<T> List for Dynamic<T> {
    /// Insert an `element` at `index`.
    ///
    /// # Panics
    /// The Rust runtime might panic or otherwise abort if allocation fails.
    ///
    /// # Performance
    /// #### Time Complexity
    /// | Worst | Best | Average |
    /// | :-: | :-: | :-: |
    /// | O(N) | 𝛀(1) | 𝚯(N) |
    ///
    /// #### Memory Complexity
    /// | Worst | Best | Average |
    /// | :-: | :-: | :-: |
    /// | O(N) | 𝛀(1) | 𝚯(N) |
    ///
    /// # Examples
    /// ```
    /// use rust::structure::collection::linear::List;
    /// use rust::structure::collection::linear::array::Dynamic;
    ///
    /// let mut instance = Dynamic::<usize>::default();
    ///
    /// instance.insert(0, 1);
    /// instance.insert(1, 3);
    /// instance.insert(1, 2);
    /// instance.insert(0, 0);
    ///
    /// assert!(instance.into_iter().eq([0, 1, 2, 3]));
    /// ```
    fn insert(
        &mut self,
        index: usize,
        element: Self::Element,
    ) -> Result<&mut Self::Element, Self::Element> {
        if index > self.initialized {
            return Err(element);
        }

        // Consume front capacity.
        let mut ptr = if index == 0 && self.capacity_front() > 0 {
            // Shift all capacity to front capacity.
            if self.initialized == 0 {
                if let Some(capacity) = self.front_capacity.checked_add(self.back_capacity) {
                    self.front_capacity = capacity;
                } else {
                    unreachable!("cannot allocate more than `isize::MAX` bytes");
                }

                self.back_capacity = 0;
            }

            if let Some(decremented) = self.front_capacity.checked_sub(1) {
                self.front_capacity = decremented;
            } else {
                unreachable!("more than zero front capacity.");
            }

            // SAFETY: aligned within the allocated object.
            unsafe { self.buffer.add(self.front_capacity) }
        }
        // Consume back capacity.
        else if self.reserve(1).is_ok() {
            // SAFETY: there is back capacity to shift into.
            unsafe { self.shift_range(index.., 1); }

            if let Some(decremented) = self.back_capacity.checked_sub(1) {
                self.back_capacity = decremented;
            } else {
                unreachable!("more than zero back capacity");
            }

            let Some(offset) = self.front_capacity.checked_add(index) else {
                unreachable!("index is within bounds");
            };

            // SAFETY: aligned within the allocated object.
            unsafe { self.buffer.add(offset) }
        }
        // The above allocation failed.
        else {
            debug_assert_eq!(self.capacity(), 0, "no capacity to insert into");

            return Err(element);
        };

        if let Some(incremented) = self.initialized.checked_add(1) {
            self.initialized = incremented;
        } else {
            unreachable!("cannot allocate more that `isize::MAX` bytes");
        }

        // SAFETY:
        // * The `MaybeUninit<T>` is initialized.
        // * We have a unique mutable reference to self and the element.
        let uninitialized = unsafe { ptr.as_mut() };

        Ok(uninitialized.write(element))
    }

    /// Remove the element at `index`.
    ///
    /// # Performance
    /// #### Time Complexity
    /// | Worst | Best | Average |
    /// | :-: | :-: | :-: |
    /// | O(N) | 𝛀(1) | 𝚯(N) |
    ///
    /// #### Memory Complexity
    /// | Worst | Best | Average |
    /// | :-: | :-: | :-: |
    /// | O(N) | 𝛀(1) | 𝚯(N) |
    ///
    /// # Examples
    /// ```
    /// use rust::structure::collection::linear::List;
    /// use rust::structure::collection::linear::array::Dynamic;
    ///
    /// let mut instance = Dynamic::from_iter([0,1,2,3,4,5]);
    ///
    /// instance.remove(5);
    /// instance.remove(2);
    /// instance.remove(0);
    ///
    /// assert!(instance.into_iter().eq([1, 3, 4]));
    /// ```
    fn remove(&mut self, index: usize) -> Option<Self::Element> {
        if index >= self.initialized {
            return None;
        }

        let element = {
            let Some(offset) = self.front_capacity.checked_add(index) else {
                unreachable!("cannot allocate more than `isize::MAX` bytes");
            };

            // SAFETY: aligned within the allocated object.
            let mut ptr = unsafe { self.buffer.add(offset) };

            // SAFETY:
            // * The `MaybeUninit<T>` is initialized.
            // * We have a unique mutable reference to self and the element.
            let element = unsafe { ptr.as_mut() };

            // SAFETY:
            // * The underlying `T` is initialized.
            // * Element is prevented from being read after this move.
            unsafe { element.assume_init_read() }
        };

        // Increase front capacity.
        if index == 0 {
            if let Some(incremented) = self.front_capacity.checked_add(1) {
                self.front_capacity = incremented;
            } else {
                unreachable!("cannot allocate more that `isize::MAX` bytes");
            }
        }
        // Increase back capacity.
        else {
            // SAFETY: shifting into the removed element.
            unsafe { self.shift_range(index.saturating_add(1).., -1); }

            if let Some(incremented) = self.back_capacity.checked_add(1) {
                self.back_capacity = incremented;
            } else {
                unreachable!("cannot allocate more that `isize::MAX` bytes");
            }
        }

        if let Some(decremented) = self.initialized.checked_sub(1) {
            self.initialized = decremented;
        } else {
            unreachable!("at least the element being removed");
        }

        Some(element)
    }

    /// Optimally remove elements within `range`.
    ///
    /// This method is more efficient than using `remove` for sequential
    /// elements, moving elements out of the buffer as iterated and shifting
    /// once only when the iterator is dropped.
    ///
    /// # Performance
    /// #### Time Complexity
    /// | Worst | Best | Average |
    /// | :-: | :-: | :-: |
    /// | O(1) | 𝛀(1) | 𝚯(1) |
    ///
    /// #### Memory Complexity
    /// | Worst | Best | Average |
    /// | :-: | :-: | :-: |
    /// | O(1) | 𝛀(1) | 𝚯(1) |
    ///
    /// # Examples
    /// ```
    /// use rust::structure::collection::linear::array::Dynamic;
    /// use rust::structure::collection::linear::List;
    ///
    /// let mut instance = Dynamic::from_iter([0, 1, 2, 3, 4, 5, 6, 7]);
    ///
    /// let mut drain = instance.drain(..2);
    /// assert_eq!(drain.next(), Some(0));
    /// assert_eq!(drain.next_back(), Some(1));
    /// core::mem::drop(drain);
    ///
    /// let mut drain = instance.drain(0..2);
    /// assert_eq!(drain.next(), Some(2));
    /// assert_eq!(drain.next_back(), Some(3));
    /// core::mem::drop(drain);
    ///
    /// let mut drain = instance.drain(0..=1);
    /// assert_eq!(drain.next(), Some(4));
    /// assert_eq!(drain.next_back(), Some(5));
    /// core::mem::drop(drain);
    ///
    /// let mut drain = instance.drain(0..);
    /// assert_eq!(drain.next(), Some(6));
    /// assert_eq!(drain.next_back(), Some(7));
    /// core::mem::drop(drain);
    ///
    /// let mut drain = instance.drain(..);
    /// assert_eq!(drain.next(), None);
    /// assert_eq!(drain.next_back(), None);
    /// ```
    fn drain(
        &mut self,
        range: impl core::ops::RangeBounds<usize>,
    ) -> impl DoubleEndedIterator<Item = Self::Element> + ExactSizeIterator {
        let start = match range.start_bound() {
            core::ops::Bound::Included(start) => *start,
            core::ops::Bound::Excluded(start) => start.saturating_add(1),
            core::ops::Bound::Unbounded => 0,
        }
        .min(self.len());

        let end = match range.end_bound() {
            core::ops::Bound::Included(end) => end.saturating_add(1),
            core::ops::Bound::Excluded(end) => *end,
            core::ops::Bound::Unbounded => self.len(),
        }
        .min(self.len());

        let normalized = start..end;

        Drain {
            underlying: self,
            range: normalized.clone(),
            unyielded: normalized.clone(),
        }
    }

    /// Remove the elements which match some `predicate`.
    ///
    /// The `predicate` is called exactly once per each element, in order of
    /// iteration. Elements for which the `predicate` is false
    /// are shifted left to immediately after the previously retained element,
    /// thereby maintaining order.
    ///
    /// # Performance
    /// #### Time Complexity
    /// | Worst | Best | Average |
    /// | :-: | :-: | :-: |
    /// | O(1) | 𝛀(1) | 𝚯(1) |
    ///
    /// #### Memory Complexity
    /// | Worst | Best | Average |
    /// | :-: | :-: | :-: |
    /// | O(1) | 𝛀(1) | 𝚯(1) |
    ///
    /// # Examples
    /// ```
    /// use rust::structure::collection::linear::array::Dynamic;
    /// use rust::structure::collection::linear::List;
    ///
    /// let mut instance = Dynamic::from_iter([0, 1, 2, 3, 4, 5]);
    /// let mut withdraw = instance.withdraw(|element| element % 2 == 0);
    ///
    /// assert_eq!(withdraw.next(), Some(0));
    /// assert_eq!(withdraw.next_back(), Some(4));
    ///
    /// drop(withdraw);
    ///
    /// assert!(instance.eq([1, 3, 5]));
    /// ```
    fn withdraw(
        &mut self,
        predicate: impl FnMut(&T) -> bool,
    ) -> impl DoubleEndedIterator<Item = Self::Element> {
        let head = if self.initialized == 0 {
            // The pointer will not be read.
            NonNull::dangling()
        } else {
            // SAFETY: aligned within the allocated object.
            unsafe { self.buffer.add(self.front_capacity) }
        }
        // `MaybeUninit<T>` has the same layout as `T`.
        .cast::<T>();

        let tail = {
            let offset = self.initialized.saturating_sub(1);

            // SAFETY: aligned within the allocated object.
            unsafe { head.add(offset) }
        }
        // `MaybeUninit<T>` has the same layout as `T`.
        .cast::<T>();

        let remaining = self.initialized;

        Withdraw {
            underlying: self,
            predicate,
            remaining,
            retained: head,
            next_front: head,
            next_back: tail,
            trailing: 0,
        }
    }

    /// Drop all initialized elements
    ///
    /// # Performance
    /// #### Time Complexity
    /// | Worst | Best | Average |
    /// | :-: | :-: | :-: |
    /// | O(N) | 𝛀(N) | 𝚯(N) |
    ///
    /// #### Memory Complexity
    /// | Worst | Best | Average |
    /// | :-: | :-: | :-: |
    /// | O(1) | 𝛀(1) | 𝚯(1) |
    ///
    /// # Examples
    /// ```
    /// use rust::structure::collection::linear::List;
    /// use rust::structure::collection::linear::array::Dynamic;
    ///
    /// let mut instance = Dynamic::from_iter([0,1,2,3,4,5]);
    ///
    /// instance.clear();
    ///
    /// assert_eq!(instance.len(), 0);
    /// assert_eq!(instance.capacity(), 6);
    /// ```
    fn clear(&mut self) {
        self.by_ref().for_each(drop);
    }
}

impl<T> super::super::Stack for Dynamic<T> {
    // TODO: it seems weird this expands to the front.

    /// Insert an `element` on the top of the stack.
    ///
    /// # Performance
    /// #### Time Complexity
    /// | Worst | Best | Average |
    /// | :-: | :-: | :-: |
    /// | O(N) | 𝛀(1) | 𝚯(N) |
    ///
    /// #### Memory Complexity
    /// | Worst | Best | Average |
    /// | :-: | :-: | :-: |
    /// | O(N) | 𝛀(1) | 𝚯(N) |
    ///
    /// # Examples
    /// ```
    /// use rust::structure::collection::linear::Stack;
    /// use rust::structure::collection::linear::array::Dynamic;
    ///
    /// let mut instance = Dynamic::<usize>::default();
    ///
    /// instance.push(5).expect("successful allocation");
    /// instance.push(4).expect("successful allocation");
    /// instance.push(3).expect("successful allocation");
    /// instance.push(2).expect("successful allocation");
    /// instance.push(1).expect("successful allocation");
    /// instance.push(0).expect("successful allocation");
    ///
    /// assert!(instance.eq([0, 1, 2, 3, 4, 5]));
    /// ```
    fn push(&mut self, element: Self::Element) -> Result<&mut Self::Element, Self::Element> {
        self.prepend(element)
    }

    /// Remove the element at the top of the stack.
    ///
    /// # Performance
    /// #### Time Complexity
    /// | Worst | Best | Average |
    /// | :-: | :-: | :-: |
    /// | O(1) | 𝛀(1) | 𝚯(1) |
    ///
    /// #### Memory Complexity
    /// | Worst | Best | Average |
    /// | :-: | :-: | :-: |
    /// | O(1) | 𝛀(1) | 𝚯(1) |
    ///
    /// # Examples
    /// ```
    /// use rust::structure::collection::linear::Stack;
    /// use rust::structure::collection::linear::array::Dynamic;
    ///
    /// let mut instance = Dynamic::from_iter([0, 1, 2, 3, 4, 5]);
    ///
    /// assert_eq!(instance.pop(), Some(0));
    /// assert_eq!(instance.pop(), Some(1));
    /// assert_eq!(instance.pop(), Some(2));
    /// assert_eq!(instance.pop(), Some(3));
    /// assert_eq!(instance.pop(), Some(4));
    /// assert_eq!(instance.pop(), Some(5));
    /// assert_eq!(instance.pop(), None);
    /// ```
    fn pop(&mut self) -> Option<Self::Element> {
        self.front()
    }

    /// Obtain a reference to the element at the top of the stack.
    ///
    /// # Performance
    /// #### Time Complexity
    /// | Worst | Best | Average |
    /// | :-: | :-: | :-: |
    /// | O(1) | 𝛀(1) | 𝚯(1) |
    ///
    /// #### Memory Complexity
    /// | Worst | Best | Average |
    /// | :-: | :-: | :-: |
    /// | O(1) | 𝛀(1) | 𝚯(1) |
    ///
    /// # Examples
    /// ```
    /// use rust::structure::collection::linear::Stack;
    /// use rust::structure::collection::linear::array::Dynamic;
    ///
    /// let mut instance = Dynamic::from_iter([0, 1, 2, 3, 4, 5]);
    ///
    /// assert_eq!(instance.peek(), Some(&0));
    /// ```
    fn peek(&self) -> Option<&Self::Element> {
        self.first()
    }
}

impl<T> super::super::Queue for Dynamic<T> {
    /// Insert an `element` to the end of the queue.
    ///
    /// # Performance
    /// #### Time Complexity
    /// | Worst | Best | Average |
    /// | :-: | :-: | :-: |
    /// | O(N) | 𝛀(1) | 𝚯(N) |
    ///
    /// #### Memory Complexity
    /// | Worst | Best | Average |
    /// | :-: | :-: | :-: |
    /// | O(N) | 𝛀(1) | 𝚯(N) |
    ///
    /// # Examples
    /// ```
    /// use rust::structure::collection::linear::Stack;
    /// use rust::structure::collection::linear::array::Dynamic;
    ///
    /// let mut instance = Dynamic::<usize>::default();
    ///
    /// instance.push(5).expect("successful allocation");
    /// instance.push(4).expect("successful allocation");
    /// instance.push(3).expect("successful allocation");
    /// instance.push(2).expect("successful allocation");
    /// instance.push(1).expect("successful allocation");
    /// instance.push(0).expect("successful allocation");
    ///
    /// assert!(instance.eq([0, 1, 2, 3, 4, 5]));
    /// ```
    fn push(&mut self, element: Self::Element) -> Result<&mut Self::Element, Self::Element> {
        self.append(element)
    }

    /// Remove the element at the front of the queue.
    ///
    /// # Performance
    /// #### Time Complexity
    /// | Worst | Best | Average |
    /// | :-: | :-: | :-: |
    /// | O(1) | 𝛀(1) | 𝚯(1) |
    ///
    /// #### Memory Complexity
    /// | Worst | Best | Average |
    /// | :-: | :-: | :-: |
    /// | O(1) | 𝛀(1) | 𝚯(1) |
    ///
    /// # Examples
    /// ```
    /// use rust::structure::collection::linear::Stack;
    /// use rust::structure::collection::linear::array::Dynamic;
    ///
    /// let mut instance = Dynamic::from_iter([0, 1, 2, 3, 4, 5]);
    ///
    /// assert_eq!(instance.pop(), Some(0));
    /// assert_eq!(instance.pop(), Some(1));
    /// assert_eq!(instance.pop(), Some(2));
    /// assert_eq!(instance.pop(), Some(3));
    /// assert_eq!(instance.pop(), Some(4));
    /// assert_eq!(instance.pop(), Some(5));
    /// assert_eq!(instance.pop(), None);
    /// ```
    fn pop(&mut self) -> Option<Self::Element> {
        self.front()
    }

    /// Obtain a reference to the element at the front of the queue.
    ///
    /// # Performance
    /// #### Time Complexity
    /// | Worst | Best | Average |
    /// | :-: | :-: | :-: |
    /// | O(1) | 𝛀(1) | 𝚯(1) |
    ///
    /// #### Memory Complexity
    /// | Worst | Best | Average |
    /// | :-: | :-: | :-: |
    /// | O(1) | 𝛀(1) | 𝚯(1) |
    ///
    /// # Examples
    /// ```
    /// use rust::structure::collection::linear::Stack;
    /// use rust::structure::collection::linear::array::Dynamic;
    ///
    /// let mut instance = Dynamic::from_iter([0, 1, 2, 3, 4, 5]);
    ///
    /// assert_eq!(instance.peek(), Some(&0));
    /// ```
    fn peek(&self) -> Option<&Self::Element> {
        self.first()
    }
}

/// [`Iterator`] to yield elements within an index range from [`Dynamic`].
///
/// See [`Dynamic::drain`].
struct Drain<'a, T> {
    /// The underlying [`Dynamic`] being drained from.
    underlying: &'a mut Dynamic<T>,

    /// The index range of elements being drained.
    range: core::ops::Range<usize>,

    /// The index range of elements being drained that have yet to be yielded.
    unyielded: core::ops::Range<usize>,
}

impl<T> Iterator for Drain<'_, T> {
    type Item = T;

    /// Obtain the element with the lowest index yet to be yielded, if any.
    ///
    /// # Performance
    /// #### Time Complexity
    /// | Worst | Best | Average |
    /// | :-: | :-: | :-: |
    /// | O(1) | 𝛀(1) | 𝚯(1) |
    ///
    /// #### Memory Complexity
    /// | Worst | Best | Average |
    /// | :-: | :-: | :-: |
    /// | O(1) | 𝛀(1) | 𝚯(1) |
    ///
    /// # Examples
    /// ```
    /// use rust::structure::collection::linear::List;
    /// use rust::structure::collection::linear::array::Dynamic;
    ///
    /// let mut underlying = Dynamic::from_iter([0, 1, 2, 3, 4, 5]);
    /// let mut actual = underlying.drain(..);
    ///
    /// assert_eq!(actual.next(), Some(0));
    /// assert_eq!(actual.next(), Some(1));
    /// assert_eq!(actual.next(), Some(2));
    /// assert_eq!(actual.next_back(), Some(5));
    /// assert_eq!(actual.next_back(), Some(4));
    /// assert_eq!(actual.next_back(), Some(3));
    /// assert_eq!(actual.next(), None);
    /// assert_eq!(actual.next_back(), None);
    /// ```
    fn next(&mut self) -> Option<Self::Item> {
        self.unyielded.next().map(
            |index| {
                let Some(offset) = self.underlying.front_capacity.checked_add(index) else {
                    unreachable!("cannot allocate more than `isize::MAX` bytes");
                };

                // SAFETY: aligned within the allocated object.
                let mut ptr = unsafe { self.underlying.buffer.add(offset) };

                // SAFETY:
                // * The `MaybeUninit<T>` is initialized.
                // * We have a unique mutable reference to self and the element.
                let element = unsafe { ptr.as_mut() };

                // SAFETY:
                // * The underlying `T` is initialized.
                // * Element is prevented from being read after this move.
                unsafe { element.assume_init_read() }
            },
        )
    }

    /// Query how many elements have yet to be yielded.
    ///
    /// # Performance
    /// #### Time Complexity
    /// | Worst | Best | Average |
    /// | :-: | :-: | :-: |
    /// | O(N) | 𝛀(1) | 𝚯(N) |
    ///
    /// #### Memory Complexity
    /// | Worst | Best | Average |
    /// | :-: | :-: | :-: |
    /// | O(N) | 𝛀(1) | 𝚯(N) |
    ///
    /// # Examples
    /// ```
    /// use rust::structure::collection::linear::array::Dynamic;
    /// use rust::structure::collection::linear::List;
    ///
    /// let mut underlying = Dynamic::from_iter([0, 1, 2, 3, 4, 5]);
    /// let mut actual = underlying.drain(..);
    ///
    /// assert_eq!(actual.size_hint(), (6, Some(6)));
    /// ```
    fn size_hint(&self) -> (usize, Option<usize>) {
        (self.unyielded.len(), Some(self.unyielded.len()))
    }
}

impl<T> DoubleEndedIterator for Drain<'_, T> {
    /// Obtain the element with the greatest index yet to be yielded, if any.
    ///
    /// # Performance
    /// #### Time Complexity
    /// | Worst | Best | Average |
    /// | :-: | :-: | :-: |
    /// | O(1) | 𝛀(1) | 𝚯(1) |
    ///
    /// #### Memory Complexity
    /// | Worst | Best | Average |
    /// | :-: | :-: | :-: |
    /// | O(1) | 𝛀(1) | 𝚯(1) |
    ///
    /// # Examples
    /// ```
    /// use rust::structure::collection::linear::List;
    /// use rust::structure::collection::linear::array::Dynamic;
    ///
    /// let mut underlying = Dynamic::from_iter([0, 1, 2, 3, 4, 5]);
    /// let mut actual = underlying.drain(..);
    ///
    /// assert_eq!(actual.next_back(), Some(5));
    /// assert_eq!(actual.next_back(), Some(4));
    /// assert_eq!(actual.next_back(), Some(3));
    /// assert_eq!(actual.next_back(), Some(2));
    /// assert_eq!(actual.next_back(), Some(1));
    /// assert_eq!(actual.next_back(), Some(0));
    /// assert_eq!(actual.next_back(), None);
    /// ```
    fn next_back(&mut self) -> Option<Self::Item> {
        self.unyielded.next_back().map(|index| {
            let Some(offset) = self.underlying.front_capacity.checked_add(index) else {
                unreachable!("cannot allocate more than `isize::MAX` bytes");
            };

            // SAFETY: aligned within the allocated object.
            let mut ptr = unsafe { self.underlying.buffer.add(offset) };

            // SAFETY:
            // * The `MaybeUninit<T>` is initialized.
            // * We have a unique mutable reference to self and the element.
            let element = unsafe { ptr.as_mut() };

            // SAFETY:
            // * The underlying `T` is initialized.
            // * Element is prevented from being read after this move.
            unsafe { element.assume_init_read() }
        })
    }
}

impl<T> ExactSizeIterator for Drain<'_, T> {}

impl<T> core::iter::FusedIterator for Drain<'_, T> {}

impl<T> Drop for Drain<'_, T> {
    /// Drops remaining elements and fixes the underlying [`Dynamic`] buffer.
    ///
    /// # Performance
    /// #### Time Complexity
    /// | Worst | Best | Average |
    /// | :-: | :-: | :-: |
    /// | O(N) | 𝛀(1) | 𝚯(N) |
    ///
    /// #### Memory Complexity
    /// | Worst | Best | Average |
    /// | :-: | :-: | :-: |
    /// | O(N) | 𝛀(1) | 𝚯(N) |
    ///
    /// # Examples
    /// ```
    /// use rust::structure::collection::linear::List;
    /// use rust::structure::collection::linear::array::Dynamic;
    ///
    /// let mut instance = Dynamic::from_iter([0, 1, 2, 3, 4, 5, 6]);
    ///
    /// let mut drain = instance.drain(2..=4);
    ///
    /// drain.next();      // Consumes the element with value `2`.
    /// drain.next_back(); // Consumes the element with value `4`.
    ///
    /// core::mem::drop(drain); // Drops the element with value '3'.
    ///
    /// assert!(instance.into_iter().eq([0, 1, 5, 6])); // Remaining elements.
    /// ```
    fn drop(&mut self) {
        if self.range.is_empty() {
            return;
        }

        // Drop any remaining elements yet to be yielded.
        self.for_each(drop);

        // Increase back capacity.
        if self.range.end == self.underlying.initialized {
            if let Some(capacity) = self.underlying.back_capacity.checked_add(self.range.len()) {
                self.underlying.back_capacity = capacity;
            } else {
                unreachable!("cannot allocate more than `isize::MAX` bytes");
            }
        }
        // Increase front capacity.
        else if self.range.start == 0 {
            if let Some(capacity) = self.underlying.front_capacity.checked_add(self.range.len()) {
                self.underlying.front_capacity = capacity;
            } else {
                unreachable!("cannot allocate more than `isize::MAX` bytes");
            }
        }
        // There exists two disjoint groups of initialized elements.
        else {
            // The elements before the range that was drained.
            let leading = 0..self.range.start;

            // The elements after the range that was drained.
            let trailing = self.range.end..self.underlying.initialized;

            let Ok(offset) = isize::try_from(self.range.len()) else {
                unreachable!("cannot allocate more than `isize::MAX` bytes");
            };

            let only_front_capacity =
                self.underlying.front_capacity != 0 && self.underlying.back_capacity == 0;
            let only_back_capacity =
                self.underlying.front_capacity == 0 && self.underlying.back_capacity != 0;

            // Shift leading elements to increase front capacity.
            if only_front_capacity || (!only_back_capacity && trailing.len() > leading.len()) {
                // SAFETY: [front capacity] [shift] [drained] [remain] [back capacity]
                unsafe { self.underlying.shift_range(leading, offset); }

                if let Some(capacity) = self.underlying.front_capacity.checked_add(self.range.len()) {
                    self.underlying.front_capacity = capacity;
                } else {
                    unreachable!("cannot allocate more than `isize::MAX` bytes");
                }
            }
            // Shift trailing element to increase back capacity.
            else {
                let Some(offset) = offset.checked_neg() else {
                    unreachable!("element count cannot be `isize::MIN`");
                };

                // SAFETY: [front capacity] [remain] [drained] [shift] [back capacity]
                unsafe { self.underlying.shift_range(trailing, offset); }

                if let Some(capacity) = self.underlying.back_capacity.checked_add(self.range.len()) {
                    self.underlying.back_capacity = capacity;
                } else {
                    unreachable!("cannot allocate more than `isize::MAX` bytes");
                }
            }
        }

        if let Some(decreased) = self.underlying.initialized.checked_sub(self.range.len()) {
            self.underlying.initialized = decreased;
        }
    }
}

impl<T: core::fmt::Debug> core::fmt::Debug for Drain<'_, T> {
    /// List the elements within the range that have yet to be yielded.
    ///
    /// # Performance
    /// #### Time Complexity
    /// | Worst | Best | Average |
    /// | :-: | :-: | :-: |
    /// | O(N) | 𝛀(N) | 𝚯(N) |
    ///
    /// #### Memory Complexity
    /// | Worst | Best | Average |
    /// | :-: | :-: | :-: |
    /// | O(N) | 𝛀(N) | 𝚯(N) |
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut list = f.debug_list();

        let slice = {
            let first = self.underlying.as_ptr();

            // SAFETY: aligned within the allocated object.
            let start = unsafe { first.add(self.unyielded.start) };

            // SAFETY: points to that many initialized instances of `T`.
            unsafe { core::slice::from_raw_parts(start, self.unyielded.len()) }
        };

        list.entries(slice).finish()
    }
}

/// [`Iterator`] to yield elements matching a predicate from [`Dynamic`].
///
/// See [`Dynamic::withdraw`].
struct Withdraw<'a, T, F: FnMut(&T) -> bool> {
    /// The underlying [`Dynamic`] being withdrawn from.
    underlying: &'a mut Dynamic<T>,

    /// The predicate based upon which elements are withdrawn.
    predicate: F,

    /// Where to write the next retained element to.
    retained: NonNull<T>,

    /// How many element are left to query with the predicate.
    remaining: usize,

    /// The next (front) element to query with the predicate.
    next_front: NonNull<T>,

    /// The next (back) element to query with the predicate.
    next_back: NonNull<T>,

    /// The number of retained elements at the end because of `next_back`.
    trailing: usize,
}

impl<T, F: FnMut(&T) -> bool> Iterator for Withdraw<'_, T, F> {
    type Item = T;

    /// Obtain the element with the lowest index yet to be yielded, if any.
    ///
    /// # Performance
    /// #### Time Complexity
    /// | Worst | Best | Average |
    /// | :-: | :-: | :-: |
    /// | O(N) | 𝛀(N) | 𝚯(N) |
    ///
    /// #### Memory Complexity
    /// | Worst | Best | Average |
    /// | :-: | :-: | :-: |
    /// | O(1) | 𝛀(1) | 𝚯(1) |
    ///
    /// # Examples
    /// ```
    /// use rust::structure::collection::linear::List;
    /// use rust::structure::collection::linear::array::Dynamic;
    ///
    /// let mut underlying = Dynamic::from_iter([0, 1, 2, 3, 4, 5]);
    /// let mut actual = underlying.withdraw(|element| element % 2 == 0);
    ///
    /// assert_eq!(actual.next(), Some(0));
    /// assert_eq!(actual.next(), Some(2));
    /// assert_eq!(actual.next(), Some(4));
    /// assert_eq!(actual.next(), None);
    /// ```
    fn next(&mut self) -> Option<Self::Item> {
        // The first element that does not match the predicate.
        let first_retained = self.next_front;

        // How many consecutive elements after that also do not match.
        let mut consecutive_retained = 0;

        while self.remaining > 0 {
            if let Some(decremented) = self.remaining.checked_sub(1) {
                self.remaining = decremented;
            } else {
                unreachable!("loop ensures `remaining > 0`");
            }

            // SAFETY: the element is initialized.
            let current = unsafe { self.next_front.as_ref() };

            // SAFETY: aligned within the allocated object, or one byte past.
            self.next_front = unsafe { self.next_front.add(1) };

            if (self.predicate)(current) {
                // SAFETY: element is prevented from being read after this move.
                let element = unsafe { core::ptr::read(current) };

                #[expect(clippy::collapsible_else_if, reason = "increase front or back capacity")]
                if self.underlying.as_ptr() == current {
                    if let Some(incremented) = self.underlying.front_capacity.checked_add(1) {
                        self.underlying.front_capacity = incremented;
                    } else {
                        unreachable!("cannot allocate more than `isize::MAX` bytes");
                    }

                    // SAFETY: at most one byte past the allocated object.
                    self.retained = unsafe { self.retained.add(1) };
                } else {
                    if let Some(incremented) = self.underlying.back_capacity.checked_add(1) {
                        self.underlying.back_capacity = incremented;
                    } else {
                        unreachable!("cannot allocate more than `isize::MAX` bytes");
                    }
                }

                // SAFETY:
                // * Source is valid for reads of that many elements.
                // * Destination is valid for writes of that many elements.
                // * Can overlap because no aliasing restrictions.
                unsafe { first_retained.copy_to(self.retained, consecutive_retained); }

                // SAFETY: next uninitialized element, or one byte past.
                self.retained = unsafe { self.retained.add(consecutive_retained) };

                if let Some(decremented) = self.underlying.initialized.checked_sub(1) {
                    self.underlying.initialized = decremented;
                } else {
                    unreachable!("at least the element being removed");
                }

                return Some(element);
            }

            if let Some(incremented) = consecutive_retained.checked_add(1) {
                consecutive_retained = incremented;
            } else {
                unreachable!("allocated more than `isize::MAX` bytes")
            }
        }

        // The above loop will exit whenever there are no more remaining
        // elements to query with the predicate. However, this means the loop
        // may iterate through a string of elements to retain at the end of the
        // buffer before exhausting elements to query. In such a circumstance,
        // there is no element at the end to withdraw hence the loop will exit
        // without shifting these elements to align with previously retained
        // elements. Nevertheless, previous iterations of the loop ensure the
        // pointer and counter denote a valid range of retained elements (if
        // any) so they can still be shifted before returning none.

        // SAFETY:
        // * Source is valid for reads of that many elements.
        // * Destination is valid for writes of that many elements.
        // * Can overlap because no aliasing restrictions.
        unsafe { first_retained.copy_to(self.retained, consecutive_retained); }

        // SAFETY: next uninitialized element, or one byte past.
        self.retained = unsafe { self.retained.add(consecutive_retained) };

        None
    }

    /// Query how many elements could possibly be yielded.
    ///
    /// # Performance
    /// #### Time Complexity
    /// | Worst | Best | Average |
    /// | :-: | :-: | :-: |
    /// | O(1) | 𝛀(1) | 𝚯(1) |
    ///
    /// #### Memory Complexity
    /// | Worst | Best | Average |
    /// | :-: | :-: | :-: |
    /// | O(1) | 𝛀(1) | 𝚯(1) |
    ///
    /// # Examples
    /// ```
    /// use rust::structure::collection::linear::List;
    /// use rust::structure::collection::linear::array::Dynamic;
    ///
    /// let mut underlying = Dynamic::from_iter([0, 1, 2, 3, 4, 5]);
    /// let instance = underlying.withdraw(|element| element % 2 == 0);
    ///
    /// assert_eq!(instance.size_hint(), (0, Some(6)));
    /// ```
    fn size_hint(&self) -> (usize, Option<usize>) {
        (0, Some(self.remaining))
    }
}

impl<T, F: FnMut(&T) -> bool> DoubleEndedIterator for Withdraw<'_, T, F> {
    /// Obtain the element with the greatest index yet to be yielded, if any.
    ///
    /// # Performance
    /// This methods takes O(N) time and consumes O(1) memory.
    ///
    /// # Examples
    /// ```
    /// use rust::structure::collection::linear::List;
    /// use rust::structure::collection::linear::array::Dynamic;
    ///
    /// let mut underlying = Dynamic::from_iter([0, 1, 2, 3, 4, 5]);
    /// let mut actual = underlying.withdraw(|element| element % 2 == 0);
    ///
    /// assert_eq!(actual.next_back(), Some(4));
    /// assert_eq!(actual.next_back(), Some(2));
    /// assert_eq!(actual.next_back(), Some(0));
    /// assert_eq!(actual.next_back(), None);
    /// ```
    fn next_back(&mut self) -> Option<Self::Item> {
        while self.remaining > 0 {
            if let Some(decremented) = self.remaining.checked_sub(1) {
                self.remaining = decremented;
            } else {
                unreachable!("loop ensures `remaining > 0`");
            }

            // SAFETY: the element is initialized.
            let current = unsafe { self.next_back.as_ref() };

            // Although it is safe to move a pointer one bytes past the
            // allocated object, it is _NOT_ safe to move it one bytes before.
            if self.remaining != 0 {
                // SAFETY: aligned within the allocated object.
                self.next_back = unsafe { self.next_back.sub(1) };
            }

            if (self.predicate)(current) {
                // SAFETY: element is prevented from being read after this move.
                let element = unsafe { core::ptr::read(current) };

                if let Some(decremented) = self.underlying.initialized.checked_sub(1) {
                    self.underlying.initialized = decremented;
                } else {
                    unreachable!("at least the element being removed");
                }

                if let Some(incremented) = self.underlying.back_capacity.checked_add(1) {
                    self.underlying.back_capacity = incremented;
                } else {
                    unreachable!("cannot allocate more than `isize::MAX` bytes");
                }

                let hole = NonNull::from(current);

                // SAFETY: aligned within the allocated object, or one byte past.
                let trailing = unsafe { hole.add(1) };

                // SAFETY:
                // * Source is valid for reads of that many elements.
                // * Destination is valid for writes of that many elements.
                // * Can overlap because no aliasing restrictions.
                unsafe { trailing.copy_to(hole, self.trailing); }

                return Some(element);
            }

            if let Some(incremented) = self.trailing.checked_add(1) {
                self.trailing = incremented;
            } else {
                unreachable!("cannot allocate more than `isize::MAX`");
            }
        }

        None
    }
}

impl<T, F: FnMut(&T) -> bool> core::iter::FusedIterator for Withdraw<'_, T, F> {}

impl<T, F: FnMut(&T) -> bool> Drop for Withdraw<'_, T, F> {
    /// Drops remaining elements and fixes the underlying [`Dynamic`] buffer.
    ///
    /// # Performance
    /// #### Time Complexity
    /// | Worst | Best | Average |
    /// | :-: | :-: | :-: |
    /// | O(N) | 𝛀(1) | 𝚯(N) |
    ///
    /// #### Memory Complexity
    /// | Worst | Best | Average |
    /// | :-: | :-: | :-: |
    /// | O(1) | 𝛀(1) | 𝚯(1) |
    ///
    /// # Examples
    /// ```
    /// use rust::structure::collection::linear::List;
    /// use rust::structure::collection::linear::array::Dynamic;
    ///
    /// let mut instance = Dynamic::from_iter([0, 1, 2, 3, 4, 5]);
    ///
    /// let mut withdraw = instance.withdraw(|element| element % 2 == 0);
    ///
    /// // Consumes the element with value `0`.
    /// assert_eq!(withdraw.next(), Some(0));
    ///
    /// // Consumes the element with value `4`.
    /// assert_eq!(withdraw.next_back(), Some(4));
    ///
    /// // Drops the element with value '2'.
    /// drop(withdraw);
    ///
    /// // Retained elements.
    /// assert!(instance.eq([1, 3, 5]));
    /// ```
    fn drop(&mut self) {
        // Drop all elements yet to be yielded.
        self.for_each(drop);

        if self.trailing > 0 {
            // SAFETY: aligned within the allocated object, or one byte past.
            let trailing = unsafe { self.next_back.add(1) };

            // SAFETY:
            // * Source is valid for reads of that many elements.
            // * Destination is valid for writes of that many elements.
            // * Can overlap because no aliasing restrictions.
            unsafe { trailing.copy_to(self.retained, self.trailing); }
        }
    }
}

impl<T, F: FnMut(&T) -> bool> core::fmt::Debug for Withdraw<'_, T, F> {
    /// Output what indexes are being pointed to in the underlying buffer.
    ///
    /// Note that these indexes are _NOT_ based on the first initialized
    /// element, but rather absolute relative to the beginning of the
    /// allocated object.
    ///
    /// # Performance
    /// #### Time Complexity
    /// | Worst | Best | Average |
    /// | :-: | :-: | :-: |
    /// | O(1) | 𝛀(1) | 𝚯(1) |
    ///
    /// #### Memory Complexity
    /// | Worst | Best | Average |
    /// | :-: | :-: | :-: |
    /// | O(1) | 𝛀(1) | 𝚯(1) |
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let origin = self.underlying.buffer.cast::<T>();

        // SAFETY: both pointers are aligned within the allocated object.
        let head = unsafe { self.next_front.offset_from(origin) };

        // SAFETY: both pointers are aligned within the allocated object.
        let retained = unsafe { self.retained.offset_from(origin) };

        // SAFETY: both pointers are aligned within the allocated object.
        let tail = unsafe { self.next_back.offset_from(origin) };

        f.debug_struct("Withdraw")
            .field("head index", &head)
            .field("tail index", &tail)
            .field("remaining elements", &self.remaining)
            .field("retained index", &retained)
            .field("trailing elements", &self.trailing)
            .finish_non_exhaustive()
    }
}

/// Error type for recoverable allocation failure.
#[derive(Debug, Clone, Copy)]
pub struct FailedAllocation;

impl core::error::Error for FailedAllocation {}

impl core::fmt::Display for FailedAllocation {
    /// Write a human-facing description of the error.
    ///
    /// # Performance
    /// #### Time Complexity
    /// | Worst | Best | Average |
    /// | :-: | :-: | :-: |
    /// | O(1) | 𝛀(1) | 𝚯(1) |
    ///
    /// #### Memory Complexity
    /// | Worst | Best | Average |
    /// | :-: | :-: | :-: |
    /// | O(1) | 𝛀(1) | 𝚯(1) |
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        write!(f, "memory allocation failed")
    }
}

/// Error type for invalid index parameters.
#[derive(Debug, Clone, Copy)]
pub struct OutOfBounds;

impl core::error::Error for OutOfBounds {}

impl core::fmt::Display for OutOfBounds {
    /// Write a human-facing description of the error.
    ///
    /// # Performance
    /// #### Time Complexity
    /// | Worst | Best | Average |
    /// | :-: | :-: | :-: |
    /// | O(1) | 𝛀(1) | 𝚯(1) |
    ///
    /// #### Memory Complexity
    /// | Worst | Best | Average |
    /// | :-: | :-: | :-: |
    /// | O(1) | 𝛀(1) | 𝚯(1) |
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        write!(f, "index is outside the bounds of initialized elements")
    }
}

#[cfg(test)]
mod test {
    use super::*;

    mod method {
        use super::*;

        mod with_capacity {
            use super::*;

            mod when_zero_requested {
                use super::*;

                #[test]
                fn then_does_not_have_capacity() {
                    let actual = Dynamic::<usize>::with_capacity(0).expect("does no allocation");

                    assert_eq!(actual.front_capacity, 0);
                    assert_eq!(actual.back_capacity, 0);
                }

                #[test]
                fn then_does_not_initialize_elements() {
                    let actual = Dynamic::<usize>::with_capacity(0).expect("does no allocation");

                    assert_eq!(actual.initialized, 0);
                }
            }

            mod when_more_than_zero_requested {
                use super::*;

                #[test]
                fn then_has_exactly_that_much_capacity() {
                    for capacity in 1..32 {
                        let actual = Dynamic::<usize>::with_capacity(capacity).expect("successful allocation");

                        assert_eq!(actual.capacity(), capacity);
                    }
                }

                #[test]
                fn then_does_not_initialize_elements() {
                    for capacity in 1..32 {
                        let actual = Dynamic::<usize>::with_capacity(capacity).expect("successful allocation");

                        assert_eq!(actual.initialized, 0);
                    }
                }

                #[test]
                fn then_requested_many_elements_can_be_prepended_without_reallocating_memory() {
                    for capacity in 1..32 {
                        let mut actual = Dynamic::<usize>::with_capacity(capacity).expect("successful allocation");

                        let allocation = actual.buffer;

                        for element in 0..capacity {
                            _ = actual.prepend(element).expect("uses capacity");
                        }

                        assert_eq!(actual.buffer, allocation);
                    }
                }

                #[test]
                fn then_requested_many_elements_can_be_appended_without_reallocating_memory() {
                    for capacity in 1..32 {
                        let mut actual = Dynamic::<usize>::with_capacity(capacity).expect("successful allocation");

                        let allocation = actual.buffer;

                        for element in 0..capacity {
                            _ = actual.append(element).expect("uses capacity");
                        }

                        assert_eq!(actual.buffer, allocation);
                    }
                }

                #[test]
                fn then_can_allocate_maximum_possible_when_zero_size_type() {
                    let actual = Dynamic::<()>::with_capacity(isize::MAX as usize).expect("ZSTs do not occupy memory");

                    assert_eq!(actual.capacity(), isize::MAX as usize);
                }
            }
        }

        mod capacity {
            use super::*;

            mod when_no_capacity {
                use super::*;

                mod when_empty {
                    use super::*;

                    #[test]
                    fn then_yields_zero() {
                        let actual = Dynamic::<usize>::default();

                        debug_assert_eq!(actual.initialized, 0);
                        debug_assert_eq!(actual.front_capacity, 0);
                        debug_assert_eq!(actual.back_capacity, 0);

                        assert_eq!(actual.capacity(), 0);
                    }
                }

                mod when_not_empty {
                    use super::*;

                    #[test]
                    fn then_yields_zero() {
                        for elements in 1..32 {
                            let actual: Dynamic<_> = (0..elements).collect();

                            debug_assert_eq!(actual.initialized, elements);
                            debug_assert_eq!(actual.front_capacity, 0);
                            debug_assert_eq!(actual.back_capacity, 0);

                            assert_eq!(actual.capacity(), 0);
                        }
                    }
                }
            }

            mod when_only_front_capacity {
                use super::*;

                mod when_empty {
                    use super::*;

                    #[test]
                    fn then_yields_that_amount() {
                        for capacity in 1..32 {
                            let mut actual = Dynamic::<usize>::default();

                            _ = actual.reserve_front(capacity).expect("successful allocation");

                            debug_assert_eq!(actual.initialized, 0);
                            debug_assert_eq!(actual.front_capacity, capacity);
                            debug_assert_eq!(actual.back_capacity, 0);

                            assert_eq!(actual.capacity(), capacity);
                        }
                    }

                    #[test]
                    fn then_that_many_elements_can_be_prepended_without_reallocating_memory() {
                        for capacity in 1..32 {
                            let mut actual = Dynamic::<usize>::default();

                            _ = actual.reserve_front(capacity).expect("successful allocation");

                            debug_assert_eq!(actual.initialized, 0);
                            debug_assert_eq!(actual.front_capacity, capacity);
                            debug_assert_eq!(actual.back_capacity, 0);

                            let allocation = actual.buffer;

                            for element in 0..capacity {
                                _ = actual.prepend(element).expect("uses capacity");
                            }

                            assert_eq!(actual.buffer, allocation);
                        }
                    }

                    #[test]
                    fn then_that_many_elements_can_be_appended_without_reallocating_memory() {
                        for capacity in 1..32 {
                            let mut actual = Dynamic::<usize>::default();

                            _ = actual.reserve_front(capacity).expect("successful allocation");

                            debug_assert_eq!(actual.initialized, 0);
                            debug_assert_eq!(actual.front_capacity, capacity);
                            debug_assert_eq!(actual.back_capacity, 0);

                            let allocation = actual.buffer;

                            for element in 0..capacity {
                                _ = actual.append(element).expect("uses capacity");
                            }

                            assert_eq!(actual.buffer, allocation);
                        }
                    }
                }

                mod when_not_empty {
                    use super::*;

                    #[test]
                    fn then_yields_that_amount() {
                        for elements in 1..32 {
                            for capacity in 1..32 {
                                let mut actual: Dynamic<_> = (0..elements).collect();

                                _ = actual.reserve_front(capacity).expect("successful allocation");

                                debug_assert_eq!(actual.initialized, elements);
                                debug_assert_eq!(actual.front_capacity, capacity);
                                debug_assert_eq!(actual.back_capacity, 0);

                                assert_eq!(actual.capacity(), capacity);
                            }
                        }
                    }

                    #[test]
                    fn then_that_many_elements_can_be_prepended_without_reallocating_memory() {
                        for elements in 1..32 {
                            for capacity in 1..32 {
                                let mut actual: Dynamic<_> = (0..elements).collect();

                                _ = actual.reserve_front(capacity).expect("successful allocation");

                                debug_assert_eq!(actual.initialized, elements);
                                debug_assert_eq!(actual.front_capacity, capacity);
                                debug_assert_eq!(actual.back_capacity, 0);

                                let allocation = actual.buffer;

                                for element in 0..capacity {
                                    _ = actual.prepend(element).expect("uses capacity");
                                }

                                assert_eq!(actual.buffer, allocation);
                            }
                        }
                    }

                    #[test]
                    fn then_that_many_elements_can_be_appended_without_reallocating_memory() {
                        for elements in 1..32 {
                            for capacity in 1..32 {
                                let mut actual: Dynamic<_> = (0..elements).collect();

                                _ = actual.reserve_front(capacity).expect("successful allocation");

                                debug_assert_eq!(actual.initialized, elements);
                                debug_assert_eq!(actual.front_capacity, capacity);
                                debug_assert_eq!(actual.back_capacity, 0);

                                let allocation = actual.buffer;

                                for element in 0..capacity {
                                    _ = actual.append(element).expect("uses capacity");
                                }

                                assert_eq!(actual.buffer, allocation);
                            }
                        }
                    }
                }
            }

            mod when_only_back_capacity {
                use super::*;

                mod when_empty {
                    use super::*;

                    #[test]
                    fn then_yields_that_amount() {
                        for capacity in 1..32 {
                            let mut actual = Dynamic::<usize>::default();

                            _ = actual.reserve_back(capacity).expect("successful allocation");

                            debug_assert_eq!(actual.initialized, 0);
                            debug_assert_eq!(actual.front_capacity, 0);
                            debug_assert_eq!(actual.back_capacity, capacity);

                            assert_eq!(actual.capacity(), capacity);
                        }
                    }

                    #[test]
                    fn then_that_many_elements_can_be_prepended_without_reallocating_memory() {
                        for capacity in 1..32 {
                            let mut actual = Dynamic::<usize>::default();

                            _ = actual.reserve_back(capacity).expect("successful allocation");

                            debug_assert_eq!(actual.initialized, 0);
                            debug_assert_eq!(actual.front_capacity, 0);
                            debug_assert_eq!(actual.back_capacity, capacity);

                            let allocation = actual.buffer;

                            for element in 0..capacity {
                                _ = actual.prepend(element).expect("uses capacity");
                            }

                            assert_eq!(actual.buffer, allocation);
                        }
                    }

                    #[test]
                    fn then_that_many_elements_can_be_appended_without_reallocating_memory() {
                        for capacity in 1..32 {
                            let mut actual = Dynamic::<usize>::default();

                            _ = actual.reserve_back(capacity).expect("successful allocation");

                            debug_assert_eq!(actual.initialized, 0);
                            debug_assert_eq!(actual.front_capacity, 0);
                            debug_assert_eq!(actual.back_capacity, capacity);

                            let allocation = actual.buffer;

                            for element in 0..capacity {
                                _ = actual.append(element).expect("uses capacity");
                            }

                            assert_eq!(actual.buffer, allocation);
                        }
                    }
                }

                mod when_not_empty {
                    use super::*;

                    #[test]
                    fn then_yields_that_amount() {
                        for elements in 1..32 {
                            for capacity in 1..32 {
                                let mut actual: Dynamic<_> = (0..elements).collect();

                                _ = actual.reserve_back(capacity).expect("successful allocation");

                                debug_assert_eq!(actual.initialized, elements);
                                debug_assert_eq!(actual.front_capacity, 0);
                                debug_assert_eq!(actual.back_capacity, capacity);

                                assert_eq!(actual.capacity(), capacity);
                            }
                        }
                    }

                    #[test]
                    fn then_that_many_elements_can_be_prepended_without_reallocating_memory() {
                        for elements in 1..32 {
                            for capacity in 1..32 {
                                let mut actual: Dynamic<_> = (0..elements).collect();

                                _ = actual.reserve_back(capacity).expect("successful allocation");

                                debug_assert_eq!(actual.initialized, elements);
                                debug_assert_eq!(actual.front_capacity, 0);
                                debug_assert_eq!(actual.back_capacity, capacity);

                                let allocation = actual.buffer;

                                for element in 0..capacity {
                                    _ = actual.prepend(element).expect("uses capacity");
                                }

                                assert_eq!(actual.buffer, allocation);
                            }
                        }
                    }

                    #[test]
                    fn then_that_many_elements_can_be_appended_without_reallocating_memory() {
                        for elements in 1..32 {
                            for capacity in 1..32 {
                                let mut actual: Dynamic<_> = (0..elements).collect();

                                _ = actual.reserve_back(capacity).expect("successful allocation");

                                debug_assert_eq!(actual.initialized, elements);
                                debug_assert_eq!(actual.front_capacity, 0);
                                debug_assert_eq!(actual.back_capacity, capacity);

                                let allocation = actual.buffer;

                                for element in 0..capacity {
                                    _ = actual.append(element).expect("uses capacity");
                                }

                                assert_eq!(actual.buffer, allocation);
                            }
                        }
                    }
                }
            }

            mod when_both_front_and_back_capacity {
                use super::*;

                mod when_empty {
                    use super::*;

                    #[test]
                    fn then_yields_sum_of_capacities() {
                        for front in 1..32 {
                            for back in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_back(front + back).expect("successful allocation");

                                _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, front);
                                debug_assert_eq!(actual.back_capacity, back);

                                assert_eq!(actual.capacity(), front + back);
                            }
                        }
                    }

                    #[test]
                    fn then_that_many_elements_can_be_prepended_without_reallocating_memory() {
                        for front in 1..32 {
                            for back in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_back(front + back).expect("successful allocation");

                                _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, front);
                                debug_assert_eq!(actual.back_capacity, back);

                                let allocation = actual.buffer;

                                for element in 0..(front + back) {
                                    _ = actual.prepend(element).expect("uses capacity");
                                }

                                assert_eq!(actual.buffer, allocation);
                            }
                        }
                    }

                    #[test]
                    fn then_that_many_elements_can_be_appended_without_reallocating_memory() {
                        for front in 1..32 {
                            for back in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_back(front + back).expect("successful allocation");

                                _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, front);
                                debug_assert_eq!(actual.back_capacity, back);

                                let allocation = actual.buffer;

                                for element in 0..(front + back) {
                                    _ = actual.append(element).expect("uses capacity");
                                }

                                assert_eq!(actual.buffer, allocation);
                            }
                        }
                    }
                }

                mod when_not_empty {
                    use super::*;

                    #[test]
                    fn then_yields_sum_of_capacities() {
                        for elements in 1..32 {
                            for front in 1..32 {
                                for back in 1..32 {
                                    let mut actual: Dynamic<_> = (0..elements).collect();

                                    _ = actual.reserve_front(front).expect("successful allocation");
                                    _ = actual.reserve_back(back).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, front);
                                    debug_assert_eq!(actual.back_capacity, back);

                                    assert_eq!(actual.capacity(), front + back);
                                }
                            }
                        }
                    }

                    #[test]
                    fn then_that_many_elements_can_be_prepended_without_reallocating_memory() {
                        for elements in 1..32 {
                            for front in 1..32 {
                                for back in 1..32 {
                                    let mut actual: Dynamic<_> = (0..elements).collect();

                                    _ = actual.reserve_back(front + back).expect("successful allocation");

                                    _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, front);
                                    debug_assert_eq!(actual.back_capacity, back);

                                    let allocation = actual.buffer;

                                    for element in 0..(front + back) {
                                        _ = actual.prepend(element).expect("uses capacity");
                                    }

                                    assert_eq!(actual.buffer, allocation);
                                }
                            }
                        }
                    }

                    #[test]
                    fn then_that_many_elements_can_be_appended_without_reallocating_memory() {
                        for elements in 1..32 {
                            for front in 1..32 {
                                for back in 1..32 {
                                    let mut actual: Dynamic<_> = (0..elements).collect();

                                    _ = actual.reserve_back(front + back).expect("successful allocation");

                                    _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, front);
                                    debug_assert_eq!(actual.back_capacity, back);

                                    let allocation = actual.buffer;

                                    for element in 0..(front + back) {
                                        _ = actual.append(element).expect("uses capacity");
                                    }

                                    assert_eq!(actual.buffer, allocation);
                                }
                            }
                        }
                    }
                }
            }
        }

        mod capacity_front {
            use super::*;

            mod when_no_capacity {
                use super::*;

                mod when_empty {
                    use super::*;

                    #[test]
                    fn then_yields_zero() {
                        let actual = Dynamic::<usize>::default();

                        debug_assert_eq!(actual.initialized, 0);
                        debug_assert_eq!(actual.front_capacity, 0);
                        debug_assert_eq!(actual.back_capacity, 0);

                        assert_eq!(actual.capacity_front(), 0);
                    }
                }

                mod when_not_empty {
                    use super::*;

                    #[test]
                    fn then_yields_zero() {
                        for elements in 1..32 {
                            let actual: Dynamic<_> = (0..elements).collect();

                            debug_assert_eq!(actual.initialized, elements);
                            debug_assert_eq!(actual.front_capacity, 0);
                            debug_assert_eq!(actual.back_capacity, 0);

                            assert_eq!(actual.capacity_front(), 0);
                        }
                    }
                }
            }

            mod when_only_front_capacity {
                use super::*;

                mod when_empty {
                    use super::*;

                    #[test]
                    fn then_yields_that_amount() {
                        for capacity in 1..32 {
                            let mut actual = Dynamic::<usize>::default();

                            _ = actual.reserve_front(capacity).expect("successful allocation");

                            debug_assert_eq!(actual.initialized, 0);
                            debug_assert_eq!(actual.front_capacity, capacity);
                            debug_assert_eq!(actual.back_capacity, 0);

                            assert_eq!(actual.capacity_front(), capacity);
                        }
                    }

                    #[test]
                    fn then_that_many_elements_can_be_prepended_without_reallocating_memory() {
                        for capacity in 1..32 {
                            let mut actual = Dynamic::<usize>::default();

                            _ = actual.reserve_front(capacity).expect("successful allocation");

                            debug_assert_eq!(actual.initialized, 0);
                            debug_assert_eq!(actual.front_capacity, capacity);
                            debug_assert_eq!(actual.back_capacity, 0);

                            let allocation = actual.buffer;

                            for element in 0..capacity {
                                _ = actual.prepend(element).expect("uses capacity");
                            }

                            assert_eq!(actual.buffer, allocation);
                        }
                    }
                }

                mod when_not_empty {
                    use super::*;

                    #[test]
                    fn then_yields_that_amount() {
                        for elements in 1..32 {
                            for capacity in 1..32 {
                                let mut actual: Dynamic<_> = (0..elements).collect();

                                _ = actual.reserve_front(capacity).expect("successful allocation");

                                debug_assert_eq!(actual.initialized, elements);
                                debug_assert_eq!(actual.front_capacity, capacity);
                                debug_assert_eq!(actual.back_capacity, 0);

                                assert_eq!(actual.capacity_front(), capacity);
                            }
                        }
                    }

                    #[test]
                    fn then_that_many_elements_can_be_prepended_without_invalidating_pointers() {
                        for elements in 1..32 {
                            for capacity in 1..32 {
                                let expected = 0..elements;

                                let mut actual: Dynamic<_> = expected.clone().collect();

                                _ = actual.reserve_front(capacity).expect("successful allocation");

                                debug_assert_eq!(actual.initialized, elements);
                                debug_assert_eq!(actual.front_capacity, capacity);
                                debug_assert_eq!(actual.back_capacity, 0);

                                let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                for element in 0..capacity {
                                    _ = actual.prepend(element).expect("uses capacity");
                                }

                                assert!(pointers.iter().copied().eq(expected));
                            }
                        }
                    }
                }
            }

            mod mod_when_only_back_capacity {
                use super::*;

                mod when_empty {
                    use super::*;

                    #[test]
                    fn then_yields_that_amount() {
                        for capacity in 1..32 {
                            let mut actual = Dynamic::<usize>::default();

                            _ = actual.reserve_back(capacity).expect("successful allocation");

                            debug_assert_eq!(actual.initialized, 0);
                            debug_assert_eq!(actual.front_capacity, 0);
                            debug_assert_eq!(actual.back_capacity, capacity);

                            assert_eq!(actual.capacity_front(), capacity);
                        }
                    }

                    #[test]
                    fn then_that_many_elements_can_be_prepended_without_reallocating_memory() {
                        for capacity in 1..32 {
                            let mut actual = Dynamic::<usize>::default();

                            _ = actual.reserve_back(capacity).expect("successful allocation");

                            debug_assert_eq!(actual.initialized, 0);
                            debug_assert_eq!(actual.front_capacity, 0);
                            debug_assert_eq!(actual.back_capacity, capacity);

                            let allocation = actual.buffer;

                            for element in 0..capacity {
                                _ = actual.prepend(element).expect("uses capacity");
                            }

                            assert_eq!(actual.buffer, allocation);
                        }
                    }
                }

                mod when_not_empty {
                    use super::*;

                    #[test]
                    fn then_yields_zero() {
                        for elements in 1..32 {
                            for capacity in 1..32 {
                                let mut actual: Dynamic<_> = (0..elements).collect();

                                _ = actual.reserve_back(capacity).expect("successful allocation");

                                debug_assert_eq!(actual.initialized, elements);
                                debug_assert_eq!(actual.front_capacity, 0);
                                debug_assert_eq!(actual.back_capacity, capacity);

                                assert_eq!(actual.capacity_front(), 0);
                            }
                        }
                    }
                }
            }

            mod when_both_front_and_back_capacity {
                use super::*;

                mod when_empty {
                    use super::*;

                    #[test]
                    fn then_yields_sum_of_capacities() {
                        for front in 1..32 {
                            for back in 1..32 {
                                let mut actual = Dynamic::<usize>::with_capacity(front + back).expect("successful allocation");

                                _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("back capacity to shift into");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, front);
                                debug_assert_eq!(actual.back_capacity, back);

                                assert_eq!(actual.capacity_front(), front + back);
                            }
                        }
                    }

                    #[test]
                    fn then_that_many_elements_can_be_prepended_without_reallocating_memory() {
                        for front in 1..32 {
                            for back in 1..32 {
                                let mut actual = Dynamic::<usize>::with_capacity(front + back).expect("successful allocation");

                                _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("back capacity to shift into");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, front);
                                debug_assert_eq!(actual.back_capacity, back);

                                let allocation = actual.buffer;

                                for element in 0..(front + back) {
                                    _ = actual.prepend(element).expect("uses capacity");
                                }

                                assert_eq!(actual.buffer, allocation);
                            }
                        }
                    }
                }

                mod when_not_empty {
                    use super::*;

                    #[test]
                    fn then_yields_only_front_capacity() {
                        for elements in 1..32 {
                            for front in 1..32 {
                                for back in 1..32 {
                                    let mut actual: Dynamic<_> = (0..elements).collect();

                                    _ = actual.reserve_front(front).expect("successful allocation");
                                    _ = actual.reserve_back(back).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, front);
                                    debug_assert_eq!(actual.back_capacity, back);

                                    assert_eq!(actual.capacity_front(), front);
                                }
                            }
                        }
                    }

                    #[test]
                    fn then_front_capacity_many_elements_can_be_prepended_without_invalidating_pointers() {
                        for elements in 1..32 {
                            for front in 1..32 {
                                for back in 1..32 {
                                    let expected = 0..elements;

                                    let mut actual: Dynamic<_> = expected.clone().collect();

                                    _ = actual.reserve_front(front).expect("successful allocation");
                                    _ = actual.reserve_back(back).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, front);
                                    debug_assert_eq!(actual.back_capacity, back);

                                    let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                    for element in 0..front {
                                        _ = actual.prepend(element).expect("uses capacity");
                                    }

                                    assert!(pointers.iter().copied().eq(expected));
                                }
                            }
                        }
                    }
                }
            }
        }

        mod capacity_back {
            use super::*;

            mod when_no_capacity {
                use super::*;

                mod when_empty {
                    use super::*;

                    #[test]
                    fn then_yields_zero() {
                        let actual = Dynamic::<usize>::default();

                        debug_assert_eq!(actual.initialized, 0);
                        debug_assert_eq!(actual.front_capacity, 0);
                        debug_assert_eq!(actual.back_capacity, 0);

                        assert_eq!(actual.capacity_back(), 0);
                    }
                }

                mod when_not_empty {
                    use super::*;

                    #[test]
                    fn then_yields_zero() {
                        for elements in 1..32 {
                            let actual: Dynamic<_> = (0..elements).collect();

                            debug_assert_eq!(actual.initialized, elements);
                            debug_assert_eq!(actual.front_capacity, 0);
                            debug_assert_eq!(actual.back_capacity, 0);

                            assert_eq!(actual.capacity_back(), 0);
                        }
                    }
                }
            }

            mod when_only_front_capacity {
                use super::*;

                mod when_empty {
                    use super::*;

                    #[test]
                    fn then_yields_that_amount() {
                        for capacity in 1..32 {
                            let mut actual = Dynamic::<usize>::default();

                            _ = actual.reserve_front(capacity).expect("successful allocation");

                            debug_assert_eq!(actual.initialized, 0);
                            debug_assert_eq!(actual.front_capacity, capacity);
                            debug_assert_eq!(actual.back_capacity, 0);

                            assert_eq!(actual.capacity_back(), capacity);
                        }
                    }

                    #[test]
                    fn then_that_many_elements_can_be_appended_without_reallocating_memory() {
                        for capacity in 1..32 {
                            let mut actual = Dynamic::<usize>::default();

                            _ = actual.reserve_front(capacity).expect("successful allocation");

                            debug_assert_eq!(actual.initialized, 0);
                            debug_assert_eq!(actual.front_capacity, capacity);
                            debug_assert_eq!(actual.back_capacity, 0);

                            let allocation = actual.buffer;

                            for element in 0..capacity {
                                _ = actual.append(element).expect("uses capacity");
                            }

                            assert_eq!(actual.buffer, allocation);
                        }
                    }
                }

                mod when_not_empty {
                    use super::*;

                    #[test]
                    fn then_yields_zero() {
                        for elements in 1..32 {
                            for capacity in 1..32 {
                                let mut actual: Dynamic<_> = (0..elements).collect();

                                _ = actual.reserve_front(capacity).expect("successful allocation");

                                debug_assert_eq!(actual.initialized, elements);
                                debug_assert_eq!(actual.front_capacity, capacity);
                                debug_assert_eq!(actual.back_capacity, 0);

                                assert_eq!(actual.capacity_back(), 0);
                            }
                        }
                    }
                }
            }

            mod when_only_back_capacity {
                use super::*;

                mod when_empty {
                    use super::*;

                    #[test]
                    fn then_yields_that_amount() {
                        for capacity in 1..32 {
                            let mut actual = Dynamic::<usize>::default();

                            _ = actual.reserve_back(capacity).expect("successful allocation");

                            debug_assert_eq!(actual.initialized, 0);
                            debug_assert_eq!(actual.front_capacity, 0);
                            debug_assert_eq!(actual.back_capacity, capacity);

                            assert_eq!(actual.capacity_back(), capacity);
                        }
                    }

                    #[test]
                    fn then_that_many_elements_can_be_appended_without_reallocating_memory() {
                        for capacity in 1..32 {
                            let mut actual = Dynamic::<usize>::default();

                            _ = actual.reserve_back(capacity).expect("successful allocation");

                            debug_assert_eq!(actual.initialized, 0);
                            debug_assert_eq!(actual.front_capacity, 0);
                            debug_assert_eq!(actual.back_capacity, capacity);

                            let allocation = actual.buffer;

                            for element in 0..capacity {
                                _ = actual.append(element).expect("uses capacity");
                            }

                            assert_eq!(actual.buffer, allocation);
                        }
                    }
                }

                mod when_not_empty {
                    use super::*;

                    #[test]
                    fn then_yields_that_amount() {
                        for elements in 1..32 {
                            for capacity in 1..32 {
                                let mut actual: Dynamic<_> = (0..elements).collect();

                                _ = actual.reserve_back(capacity).expect("successful allocation");

                                debug_assert_eq!(actual.initialized, elements);
                                debug_assert_eq!(actual.front_capacity, 0);
                                debug_assert_eq!(actual.back_capacity, capacity);

                                assert_eq!(actual.capacity_back(), capacity);
                            }
                        }
                    }

                    #[test]
                    fn then_that_many_elements_can_be_appended_without_invalidating_pointers() {
                        for elements in 1..32 {
                            for capacity in 1..32 {
                                let expected = 0..elements;

                                let mut actual: Dynamic<_> = expected.clone().collect();

                                _ = actual.reserve_back(capacity).expect("successful allocation");

                                debug_assert_eq!(actual.initialized, elements);
                                debug_assert_eq!(actual.front_capacity, 0);
                                debug_assert_eq!(actual.back_capacity, capacity);

                                let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                for element in 0..capacity {
                                    _ = actual.append(element).expect("uses capacity");
                                }

                                assert!(pointers.iter().copied().eq(expected));
                            }
                        }
                    }
                }
            }

            mod when_both_front_and_back_capacity {
                use super::*;

                mod when_empty {
                    use super::*;

                    #[test]
                    fn then_yields_sum_of_capacities() {
                        for front in 1..32 {
                            for back in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_back(front + back).expect("successful allocation");

                                _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, front);
                                debug_assert_eq!(actual.back_capacity, back);

                                assert_eq!(actual.capacity_back(), front + back);
                            }
                        }
                    }

                    #[test]
                    fn then_that_many_elements_can_be_appended_without_reallocating_memory() {
                        for front in 1..32 {
                            for back in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_back(front + back).expect("successful allocation");

                                _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, front);
                                debug_assert_eq!(actual.back_capacity, back);

                                let allocation = actual.buffer;

                                for element in 0..(front + back) {
                                    _ = actual.append(element).expect("uses capacity");
                                }

                                assert_eq!(actual.buffer, allocation);
                            }
                        }
                    }
                }

                mod when_not_empty {
                    use super::*;

                    #[test]
                    fn then_yields_only_back_capacity() {
                        for elements in 1..32 {
                            for front in 1..32 {
                                for back in 1..32 {
                                    let mut actual: Dynamic<_> = (0..elements).collect();

                                    _ = actual.reserve_front(front).expect("successful allocation");
                                    _ = actual.reserve_back(back).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, front);
                                    debug_assert_eq!(actual.back_capacity, back);

                                    assert_eq!(actual.capacity_back(), back);
                                }
                            }
                        }
                    }

                    #[test]
                    fn then_capacity_many_elements_can_be_appended_without_invalidating_pointers() {
                        for elements in 1..32 {
                            for front in 1..32 {
                                for back in 1..32 {
                                    let expected = 0..elements;

                                    let mut actual: Dynamic<_> = expected.clone().collect();

                                    _ = actual.reserve_front(front).expect("successful allocation");
                                    _ = actual.reserve_back(back).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, front);
                                    debug_assert_eq!(actual.back_capacity, back);

                                    let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), expected.len()) };

                                    for element in 0..back {
                                        _ = actual.append(element).expect("uses capacity");
                                    }

                                    assert!(pointers.iter().copied().eq(expected));
                                }
                            }
                        }
                    }
                }
            }
        }

        mod reserve {
            use super::*;

            mod when_no_capacity {
                use super::*;

                mod when_zero_requested {
                    use super::*;

                    mod when_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_capacity() {
                            let mut actual = Dynamic::<usize>::default();

                            debug_assert_eq!(actual.initialized, 0);
                            debug_assert_eq!(actual.front_capacity, 0);
                            debug_assert_eq!(actual.back_capacity, 0);

                            _ = actual.reserve(0).expect("does no allocation");

                            assert_eq!(actual.capacity(), 0);
                        }

                        #[test]
                        fn then_does_not_initialize_elements() {
                            let mut actual = Dynamic::<usize>::default();

                            debug_assert_eq!(actual.initialized, 0);
                            debug_assert_eq!(actual.front_capacity, 0);
                            debug_assert_eq!(actual.back_capacity, 0);

                            _ = actual.reserve(0).expect("does no allocation");

                            assert_eq!(actual.initialized, 0);
                        }
                    }

                    mod when_not_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_front_capacity() {
                            for elements in 1..32 {
                                let mut actual: Dynamic<_> = (0..elements).collect();

                                debug_assert_eq!(actual.initialized, elements);
                                debug_assert_eq!(actual.front_capacity, 0);
                                debug_assert_eq!(actual.back_capacity, 0);

                                _ = actual.reserve(0).expect("already enough capacity");

                                assert_eq!(actual.front_capacity, 0);
                            }
                        }

                        #[test]
                        fn then_does_not_modify_back_capacity() {
                            for elements in 1..32 {
                                let mut actual: Dynamic<_> = (0..elements).collect();

                                debug_assert_eq!(actual.initialized, elements);
                                debug_assert_eq!(actual.front_capacity, 0);
                                debug_assert_eq!(actual.back_capacity, 0);

                                _ = actual.reserve(0).expect("already enough capacity");

                                assert_eq!(actual.back_capacity, 0);
                            }
                        }

                        #[test]
                        fn then_does_not_modify_initialized_elements() {
                            for elements in 1..32 {
                                let expected = 0..elements;

                                let mut actual: Dynamic<_> = expected.clone().collect();

                                debug_assert_eq!(actual.initialized, elements);
                                debug_assert_eq!(actual.front_capacity, 0);
                                debug_assert_eq!(actual.back_capacity, 0);

                                _ = actual.reserve(0).expect("already enough capacity");

                                assert!(actual.eq(expected));
                            }
                        }
                    }
                }

                mod when_more_than_zero_requested {
                    use super::*;

                    mod when_empty {
                        use super::*;

                        #[test]
                        fn when_zero_size_type_then_can_allocate_maximum_possible_amount() {
                            let mut actual = Dynamic::<()>::default();

                            debug_assert_eq!(actual.initialized, 0);
                            debug_assert_eq!(actual.front_capacity, 0);
                            debug_assert_eq!(actual.back_capacity, 0);

                            _ = actual.reserve(isize::MAX as usize).expect("ZSTs do not occupy memory");

                            assert_eq!(actual.capacity(), isize::MAX as usize);
                        }

                        #[test]
                        fn then_increases_capacity_to_bounding_power_of_two_of_requested() {
                            for exponent in 0..(isize::BITS - 2) {
                                let power = usize::pow(2, exponent);

                                let mut actual = Dynamic::<()>::default();

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, 0);
                                debug_assert_eq!(actual.back_capacity, 0);

                                _ = actual.reserve(power + 1).expect("successful allocation");

                                assert_eq!(actual.capacity(), (power + 1).next_power_of_two());
                            }
                        }

                        #[test]
                        fn then_does_not_initialize_elements() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, 0);
                                debug_assert_eq!(actual.back_capacity, 0);

                                _ = actual.reserve(capacity).expect("successful allocation");

                                assert_eq!(actual.initialized, 0);
                            }
                        }

                        #[test]
                        fn then_requested_many_elements_can_be_appended_without_reallocating_memory() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, 0);
                                debug_assert_eq!(actual.back_capacity, 0);

                                _ = actual.reserve(capacity).expect("successful allocation");

                                let allocation = actual.buffer;

                                for element in 0..capacity {
                                    _ = actual.append(element).expect("uses capacity");
                                }

                                assert_eq!(actual.buffer, allocation);
                            }
                        }
                    }

                    mod when_not_empty {
                        use super::*;

                        #[test]
                        fn when_zero_size_type_then_can_allocate_maximum_possible_amount() {
                            for elements in 1..32 {
                                let mut actual: Dynamic<_> = core::iter::repeat_n((), elements).collect();

                                debug_assert_eq!(actual.initialized, elements);
                                debug_assert_eq!(actual.front_capacity, 0);
                                debug_assert_eq!(actual.back_capacity, 0);

                                _ = actual.reserve(isize::MAX as usize - elements).expect("ZSTs do not occupy memory");

                                assert_eq!(actual.capacity(), isize::MAX as usize - elements);
                            }
                        }

                        #[test]
                        fn then_does_not_modify_front_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let mut actual: Dynamic<_> = (0..elements).collect();

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.reserve(capacity).expect("successful allocation");

                                    assert_eq!(actual.front_capacity, 0);
                                }
                            }
                        }

                        #[test]
                        fn then_increases_back_capacity_to_bounding_power_of_two_of_requested() {
                            for elements in 1..32 {
                                for exponent in 0..(isize::BITS - 2) {
                                    let power = usize::pow(2, exponent);

                                    let mut actual: Dynamic<()> = core::iter::repeat_n((), elements).collect();

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.reserve(power + 1).expect("successful allocation");

                                    assert_eq!(actual.back_capacity, (power + 1 + elements).next_power_of_two() - elements);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_initialized_elements() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let expected = 0..elements;

                                    let mut actual: Dynamic<usize> = expected.clone().collect();

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.reserve(capacity).expect("successful allocation");

                                    assert!(actual.eq(expected));
                                }
                            }
                        }

                        #[test]
                        fn then_requested_many_elements_can_be_appended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let expected = 0..elements;

                                    let mut actual: Dynamic<_> = expected.clone().collect();

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.reserve(capacity).expect("successful allocation");

                                    let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                    for _ in 0..capacity {
                                        // NOTE: this is distinct from the expected values.
                                        _ = actual.append(usize::MAX).expect("uses capacity");
                                    }

                                    assert!(pointers.iter().copied().eq(expected));
                                }
                            }
                        }
                    }
                }
            }

            mod when_only_front_capacity {
                use super::*;

                mod when_zero_requested {
                    use super::*;

                    mod when_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_capacity() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_front(capacity).expect("successful allocation");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, capacity);
                                debug_assert_eq!(actual.back_capacity, 0);

                                _ = actual.reserve(0).expect("already enough capacity");

                                assert_eq!(actual.capacity(), capacity);
                            }
                        }

                        #[test]
                        fn then_does_not_initialize_elements() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_front(capacity).expect("successful allocation");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, capacity);
                                debug_assert_eq!(actual.back_capacity, 0);

                                _ = actual.reserve(0).expect("already enough capacity");

                                assert_eq!(actual.initialized, 0);
                            }
                        }

                        #[test]
                        fn then_does_not_reallocate_memory() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_front(capacity).expect("successful allocation");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, capacity);
                                debug_assert_eq!(actual.back_capacity, 0);

                                let allocation = actual.buffer;

                                _ = actual.reserve(0).expect("already enough capacity");

                                assert_eq!(actual.buffer, allocation);
                            }
                        }

                        #[test]
                        fn then_capacity_many_elements_can_be_prepended_without_reallocating_memory() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_front(capacity).expect("successful allocation");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, capacity);
                                debug_assert_eq!(actual.back_capacity, 0);

                                _ = actual.reserve(0).expect("already enough capacity");

                                let allocation = actual.buffer;

                                for element in 0..capacity {
                                    _ = actual.prepend(element).expect("uses capacity");
                                }

                                assert_eq!(actual.buffer, allocation);
                            }
                        }
                    }

                    mod when_not_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_front_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let mut actual: Dynamic<_> = (0..elements).collect();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.reserve(0).expect("already enough capacity");

                                    assert_eq!(actual.front_capacity, capacity);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_back_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let mut actual: Dynamic<_> = (0..elements).collect();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.reserve(0).expect("already enough capacity");

                                    assert_eq!(actual.back_capacity, 0);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_initialized_elements() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let expected = 0..elements;

                                    let mut actual: Dynamic<_> = expected.clone().collect();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.reserve(0).expect("already enough capacity");

                                    assert!(actual.eq(expected));
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_reallocate_memory() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let mut actual: Dynamic<_> = (0..elements).collect();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    let allocation = actual.buffer;

                                    _ = actual.reserve(0).expect("already enough capacity");

                                    assert_eq!(actual.buffer, allocation);
                                }
                            }
                        }

                        #[test]
                        fn then_capacity_many_elements_can_be_prepended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let expected = 0..elements;

                                    let mut actual: Dynamic<_> = expected.clone().collect();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.reserve(0).expect("already enough capacity");

                                    let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                    for _ in 0..capacity {
                                        // NOTE: this is distinct from the expected values.
                                        _ = actual.prepend(usize::MAX).expect("uses capacity");
                                    }

                                    assert!(pointers.iter().copied().eq(expected));
                                }
                            }
                        }
                    }
                }

                mod when_less_than_requested {
                    use super::*;

                    mod when_empty {
                        use super::*;

                        #[test]
                        fn when_zero_size_type_then_can_allocate_maximum_possible_amount() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<()>::default();

                                _ = actual.reserve_front(capacity).expect("successful allocation");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, capacity);
                                debug_assert_eq!(actual.back_capacity, 0);

                                _ = actual.reserve(isize::MAX as usize).expect("ZSTs do not occupy memory");

                                assert_eq!(actual.capacity(), isize::MAX as usize);
                            }
                        }

                        #[test]
                        fn then_increases_capacity_to_bounding_power_of_two_of_requested() {
                            for exponent in 0..(isize::BITS - 2) {
                                let power = usize::pow(2, exponent);

                                for additional in 1..32 {
                                    let mut actual = Dynamic::<()>::default();

                                    _ = actual.reserve_front(power).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, power);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.reserve(power + additional).expect("successful allocation");

                                    assert_eq!(actual.capacity(), (power + additional).next_power_of_two());
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_initialize_elements() {
                            for capacity in 1..32 {
                                for additional in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.reserve(capacity + additional).expect("successful allocation");

                                    assert_eq!(actual.initialized, 0);
                                }
                            }
                        }

                        #[test]
                        fn then_requested_many_elements_can_be_appended_without_reallocating_memory() {
                            for capacity in 1..32 {
                                for additional in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.reserve(capacity + additional).expect("successful allocation");

                                    let allocation = actual.buffer;

                                    for element in 0..(capacity + additional) {
                                        _ = actual.append(element).expect("uses capacity");
                                    }

                                    assert_eq!(actual.buffer, allocation);
                                }
                            }
                        }
                    }

                    mod when_not_empty {
                        use super::*;

                        #[test]
                        fn when_zero_size_type_then_can_allocate_maximum_possible_amount() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let mut actual: Dynamic<_> = core::iter::repeat_n((), elements).collect();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.reserve(isize::MAX as usize - elements).expect("ZSTs do not occupy memory");

                                    assert_eq!(actual.capacity(), isize::MAX as usize - elements);
                                }
                            }
                        }

                        #[test]
                        fn then_decreases_front_capacity_to_zero() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let mut actual: Dynamic<_> = (0..elements).collect();

                                        _ = actual.reserve_front(capacity).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, capacity);
                                        debug_assert_eq!(actual.back_capacity, 0);

                                        _ = actual.reserve(capacity + additional).expect("successful allocation");

                                        assert_eq!(actual.front_capacity, 0);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_increases_back_capacity_to_bounding_power_of_two_of_requested() {
                            for elements in 1..32 {
                                for exponent in 0..(isize::BITS - 2) {
                                    let power = usize::pow(2, exponent);

                                    for additional in 1..32 {
                                        let mut actual: Dynamic<()> = core::iter::repeat_n((), elements).collect();

                                        _ = actual.reserve_front(power).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, power);
                                        debug_assert_eq!(actual.back_capacity, 0);

                                        _ = actual.reserve(power + additional).expect("successful allocation");

                                        assert_eq!(actual.back_capacity, (power + additional + elements).next_power_of_two() - elements);
                                    }
                                }
                            }




                        }

                        #[test]
                        fn then_does_not_modify_initialized_elements() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let expected = 0..elements;

                                        let mut actual: Dynamic<_> = expected.clone().collect();

                                        _ = actual.reserve_front(capacity).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, capacity);
                                        debug_assert_eq!(actual.back_capacity, 0);

                                        _ = actual.reserve(capacity + additional).expect("successful allocation");

                                        assert!(actual.eq(expected));
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_requested_many_elements_can_be_appended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let expected = 0..elements;

                                        let mut actual: Dynamic<_> = expected.clone().collect();

                                        _ = actual.reserve_front(capacity).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, capacity);
                                        debug_assert_eq!(actual.back_capacity, 0);

                                        _ = actual.reserve(capacity + additional).expect("successful allocation");

                                        let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                        for _ in 0..(capacity + additional) {
                                            // NOTE: this is distinct from the expected values.
                                            _ = actual.append(usize::MAX).expect("uses capacity");
                                        }

                                        assert!(pointers.iter().copied().eq(expected));
                                    }
                                }
                            }
                        }
                    }
                }

                mod when_exactly_requested {
                    use super::*;

                    mod when_empty {
                        use super::*;

                        #[test]
                        fn when_zero_size_type_then_can_allocate_maximum_possible_amount() {
                            let mut actual = Dynamic::<()>::default();

                            _ = actual.reserve_front(isize::MAX as usize).expect("successful allocation");

                            debug_assert_eq!(actual.initialized, 0);
                            debug_assert_eq!(actual.front_capacity, isize::MAX as usize);
                            debug_assert_eq!(actual.back_capacity, 0);

                            _ = actual.reserve(isize::MAX as usize).expect("ZSTs do not occupy memory");

                            assert_eq!(actual.capacity(), isize::MAX as usize);
                        }

                        #[test]
                        fn then_does_not_modify_capacity() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_front(capacity).expect("successful allocation");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, capacity);
                                debug_assert_eq!(actual.back_capacity, 0);

                                _ = actual.reserve(capacity).expect("already enough capacity");

                                assert_eq!(actual.capacity(), capacity);
                            }
                        }

                        #[test]
                        fn then_does_not_initialize_elements() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_front(capacity).expect("successful allocation");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, capacity);
                                debug_assert_eq!(actual.back_capacity, 0);

                                _ = actual.reserve(capacity).expect("already enough capacity");

                                assert_eq!(actual.initialized, 0);
                            }
                        }

                        #[test]
                        fn then_does_not_reallocate_memory() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_front(capacity).expect("successful allocation");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, capacity);
                                debug_assert_eq!(actual.back_capacity, 0);

                                let allocation = actual.buffer;

                                _ = actual.reserve(capacity).expect("already enough capacity");

                                assert_eq!(actual.buffer, allocation);
                            }
                        }

                        #[test]
                        fn then_requested_many_elements_can_be_appended_without_reallocating_memory() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_front(capacity).expect("successful allocation");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, capacity);
                                debug_assert_eq!(actual.back_capacity, 0);

                                _ = actual.reserve(capacity);

                                let allocation = actual.buffer;

                                for element in 0..capacity {
                                    _ = actual.append(element).expect("uses capacity");
                                }

                                assert_eq!(actual.buffer, allocation);
                            }
                        }
                    }

                    mod when_not_empty {
                        use super::*;

                        #[test]
                        fn when_zero_size_type_then_can_allocate_maximum_possible_amount() {
                            for elements in 1..32 {
                                let mut actual: Dynamic<_> = core::iter::repeat_n((), elements).collect();

                                _ = actual.reserve_front(isize::MAX as usize - elements).expect("successful allocation");

                                debug_assert_eq!(actual.initialized, elements);
                                debug_assert_eq!(actual.front_capacity, isize::MAX as usize - elements);
                                debug_assert_eq!(actual.back_capacity, 0);

                                _ = actual.reserve(isize::MAX as usize - elements).expect("ZSTs do not occupy memory");

                                assert_eq!(actual.capacity(), isize::MAX as usize - elements);
                            }
                        }

                        #[test]
                        fn then_decreases_front_capacity_to_zero() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let mut actual: Dynamic<_> = (0..elements).collect();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.reserve(capacity).expect("already enough capacity");

                                    assert_eq!(actual.front_capacity, 0);
                                }
                            }
                        }

                        #[test]
                        fn then_increases_back_capacity_to_exactly_requested() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let mut actual: Dynamic<_> = (0..elements).collect();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.reserve(capacity).expect("already enough capacity");

                                    assert_eq!(actual.back_capacity, capacity);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_initialized_elements() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let expected = 0..elements;

                                    let mut actual: Dynamic<_> = expected.clone().collect();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.reserve(capacity).expect("already enough capacity");

                                    assert!(actual.eq(expected));
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_reallocate_memory() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let mut actual: Dynamic<_> = (0..elements).collect();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    let allocation = actual.buffer;

                                    _ = actual.reserve(capacity).expect("already enough capacity");

                                    assert_eq!(actual.buffer, allocation);
                                }
                            }
                        }

                        #[test]
                        fn then_requested_many_elements_can_be_appended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let expected = 0..elements;

                                    let mut actual: Dynamic<_> = expected.clone().collect();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.reserve(capacity).expect("already enough capacity");

                                    let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                    for _ in 0..capacity {
                                        // NOTE: this is distinct from the expected values.
                                        _ = actual.append(usize::MAX).expect("uses capacity");
                                    }

                                    assert!(pointers.iter().copied().eq(expected));
                                }
                            }
                        }
                    }
                }

                mod when_more_than_requested {
                    use super::*;

                    mod when_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_capacity() {
                            for capacity in 1..32 {
                                for additional in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_front(capacity + additional).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, capacity + additional);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.reserve(capacity).expect("already enough capacity");

                                    assert_eq!(actual.capacity(), capacity + additional);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_initialize_elements() {
                            for capacity in 1..32 {
                                for additional in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_front(capacity + additional).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, capacity + additional);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.reserve(capacity).expect("already enough capacity");

                                    assert_eq!(actual.initialized, 0);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_reallocate_memory() {
                            for capacity in 1..32 {
                                for additional in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_front(capacity + additional).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, capacity + additional);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    let allocation = actual.buffer;

                                    _ = actual.reserve(capacity).expect("already enough capacity");

                                    assert_eq!(actual.buffer, allocation);
                                }
                            }
                        }

                        #[test]
                        fn then_capacity_many_elements_can_be_appended_without_reallocating_memory() {
                            for capacity in 1..32 {
                                for additional in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_front(capacity + additional).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, capacity + additional);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.reserve(capacity).expect("already enough capacity");

                                    let allocation = actual.buffer;

                                    for element in 0..(capacity + additional) {
                                        _ = actual.append(element).expect("uses capacity");
                                    }

                                    assert_eq!(actual.buffer, allocation);
                                }
                            }
                        }
                    }

                    mod when_not_empty {
                        use super::*;

                        #[test]
                        fn then_decreases_front_capacity_to_zero() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let mut actual: Dynamic<_> = (0..elements).collect();

                                        _ = actual.reserve_front(capacity + additional).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, capacity + additional);
                                        debug_assert_eq!(actual.back_capacity, 0);

                                        _ = actual.reserve(capacity).expect("already enough capacity");

                                        assert_eq!(actual.front_capacity, 0);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_increases_back_capacity_to_front_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let mut actual: Dynamic<_> = (0..elements).collect();

                                        _ = actual.reserve_front(capacity + additional).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, capacity + additional);
                                        debug_assert_eq!(actual.back_capacity, 0);

                                        _ = actual.reserve(capacity).expect("already enough capacity");

                                        assert_eq!(actual.back_capacity, capacity + additional);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_initialized_elements() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let expected = 0..elements;

                                        let mut actual: Dynamic<_> = expected.clone().collect();

                                        _ = actual.reserve_front(capacity + additional).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, capacity + additional);
                                        debug_assert_eq!(actual.back_capacity, 0);

                                        _ = actual.reserve(capacity).expect("already enough capacity");

                                        assert!(actual.eq(expected));
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_reallocate_memory() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let mut actual: Dynamic<_> = (0..elements).collect();

                                        _ = actual.reserve_front(capacity + additional).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, capacity + additional);
                                        debug_assert_eq!(actual.back_capacity, 0);

                                        let allocation = actual.buffer;

                                        _ = actual.reserve(capacity).expect("already enough capacity");

                                        assert_eq!(actual.buffer, allocation);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_capacity_many_elements_can_be_appended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let expected = 0..elements;

                                        let mut actual: Dynamic<_> = expected.clone().collect();

                                        _ = actual.reserve_front(capacity + additional).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, capacity + additional);
                                        debug_assert_eq!(actual.back_capacity, 0);

                                        _ = actual.reserve(capacity).expect("already enough capacity");

                                        let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                        for _ in 0..(capacity + additional) {
                                            // NOTE: this is distinct from the expected values.
                                            _ = actual.append(usize::MAX).expect("uses capacity");
                                        }

                                        assert!(pointers.iter().copied().eq(expected));
                                    }
                                }
                            }
                        }
                    }
                }
            }

            mod when_only_back_capacity {
                use super::*;

                mod when_zero_requested {
                    use super::*;

                    mod when_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_capacity() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_back(capacity).expect("successful allocation");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, 0);
                                debug_assert_eq!(actual.back_capacity, capacity);

                                _ = actual.reserve(0).expect("already enough capacity");

                                assert_eq!(actual.capacity(), capacity);
                            }
                        }

                        #[test]
                        fn then_does_not_initialize_elements() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_back(capacity).expect("successful allocation");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, 0);
                                debug_assert_eq!(actual.back_capacity, capacity);

                                _ = actual.reserve(0).expect("already enough capacity");

                                assert_eq!(actual.initialized, 0);
                            }
                        }

                        #[test]
                        fn then_does_not_reallocate_memory() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_back(capacity).expect("successful allocation");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, 0);
                                debug_assert_eq!(actual.back_capacity, capacity);

                                let allocation = actual.buffer;

                                _ = actual.reserve(0).expect("already enough capacity");

                                assert_eq!(actual.buffer, allocation);
                            }
                        }

                        #[test]
                        fn then_capacity_many_elements_can_be_appended_without_reallocating_memory() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_back(capacity).expect("successful allocation");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, 0);
                                debug_assert_eq!(actual.back_capacity, capacity);

                                _ = actual.reserve(0).expect("already enough capacity");

                                let allocation = actual.buffer;

                                for element in 0..capacity {
                                    _ = actual.append(element).expect("uses capacity");
                                }

                                assert_eq!(actual.buffer, allocation);
                            }
                        }
                    }

                    mod when_not_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_front_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let mut actual: Dynamic<_> = (0..elements).collect();

                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    _ = actual.reserve(0).expect("already enough capacity");

                                    assert_eq!(actual.front_capacity, 0);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_decrease_back_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let mut actual: Dynamic<_> = (0..elements).collect();

                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    _ = actual.reserve(0).expect("already enough capacity");

                                    assert_eq!(actual.back_capacity, capacity);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_initialized_elements() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let expected = 0..elements;

                                    let mut actual: Dynamic<_> = expected.clone().collect();

                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    _ = actual.reserve(0).expect("already enough capacity");

                                    assert!(actual.eq(expected));
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_reallocate_memory() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let mut actual: Dynamic<_> = (0..elements).collect();

                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    let allocation = actual.buffer;

                                    _ = actual.reserve(0).expect("already enough capacity");

                                    assert_eq!(actual.buffer, allocation);
                                }
                            }
                        }

                        #[test]
                        fn then_capacity_many_elements_can_be_appended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let expected = 0..elements;

                                    let mut actual: Dynamic<_> = expected.clone().collect();

                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    _ = actual.reserve(0).expect("already enough capacity");

                                    let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                    for _ in 0..capacity {
                                        // NOTE: this is distinct from the expected values.
                                        _ = actual.append(usize::MAX).expect("uses capacity");
                                    }

                                    assert!(pointers.iter().copied().eq(expected));
                                }
                            }
                        }
                    }
                }

                mod when_less_than_requested {
                    use super::*;

                    mod when_empty {
                        use super::*;

                        #[test]
                        fn when_zero_size_type_then_can_allocate_maximum_possible_amount() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<()>::default();

                                _ = actual.reserve_back(capacity).expect("successful allocation");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, 0);
                                debug_assert_eq!(actual.back_capacity, capacity);

                                _ = actual.reserve(isize::MAX as usize).expect("ZSTs do not occupy memory");

                                assert_eq!(actual.capacity(), isize::MAX as usize);
                            }
                        }

                        #[test]
                        fn then_increases_capacity_to_bounding_power_of_two_of_requested() {
                            for exponent in 0..(isize::BITS - 2) {
                                let power = usize::pow(2, exponent);

                                for additional in 1..32 {
                                    let mut actual = Dynamic::<()>::default();

                                    _ = actual.reserve_back(power).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, power);

                                    _ = actual.reserve(power + additional).expect("successful allocation");

                                    assert_eq!(actual.capacity(), (power + additional).next_power_of_two());
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_initialize_elements() {
                            for capacity in 1..32 {
                                for additional in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    _ = actual.reserve(capacity + additional).expect("successful allocation");

                                    assert_eq!(actual.initialized, 0);
                                }
                            }
                        }

                        #[test]
                        fn then_requested_many_elements_can_be_appended_without_reallocating_memory() {
                            for capacity in 1..32 {
                                for additional in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    _ = actual.reserve(capacity + additional).expect("successful allocation");

                                    let allocation = actual.buffer;

                                    for element in 0..(capacity + additional) {
                                        _ = actual.append(element).expect("uses capacity");
                                    }

                                    assert_eq!(actual.buffer, allocation);
                                }
                            }

                        }
                    }

                    mod when_not_empty {
                        use super::*;

                        #[test]
                        fn when_zero_size_type_then_can_allocate_maximum_possible_amount() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let mut actual: Dynamic<_> = core::iter::repeat_n((), elements).collect();

                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    _ = actual.reserve(isize::MAX as usize - elements).expect("ZSTs do not occupy memory");

                                    assert_eq!(actual.capacity(), isize::MAX as usize - elements);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_front_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let mut actual: Dynamic<_> = (0..elements).collect();

                                        _ = actual.reserve_back(capacity).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, 0);
                                        debug_assert_eq!(actual.back_capacity, capacity);

                                        _ = actual.reserve(capacity + additional).expect("successful allocation");

                                        assert_eq!(actual.front_capacity, 0);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_increases_back_capacity_to_bounding_power_of_two_of_requested() {
                            for elements in 1..32 {
                                for exponent in 0..(isize::BITS - 2) {
                                    let power = usize::pow(2, exponent);

                                    for additional in 1..32 {
                                        let mut actual: Dynamic<_> = core::iter::repeat_n((), elements).collect();

                                        _ = actual.reserve_back(power).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, 0);
                                        debug_assert_eq!(actual.back_capacity, power);

                                        _ = actual.reserve(power + additional);

                                        assert_eq!(actual.back_capacity, (power + additional + elements).next_power_of_two() - elements);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_initialized_elements() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let expected = 0..elements;

                                        let mut actual: Dynamic<_> = expected.clone().collect();

                                        _ = actual.reserve_back(capacity).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, 0);
                                        debug_assert_eq!(actual.back_capacity, capacity);

                                        _ = actual.reserve(capacity + additional).expect("successful allocation");

                                        assert!(actual.eq(expected));
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_requested_many_elements_can_be_appended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let expected = 0..elements;

                                        let mut actual: Dynamic<_> = expected.clone().collect();

                                        _ = actual.reserve_back(capacity).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, 0);
                                        debug_assert_eq!(actual.back_capacity, capacity);

                                        _ = actual.reserve(capacity + additional).expect("successful allocation");

                                        let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                        for _ in 0..(capacity + additional) {
                                            // NOTE: this is distinct from the expected values.
                                            _ = actual.append(usize::MAX).expect("uses capacity");
                                        }

                                        assert!(pointers.iter().copied().eq(expected));
                                    }
                                }
                            }
                        }
                    }
                }

                mod when_exactly_requested {
                    use super::*;

                    mod when_empty {
                        use super::*;

                        #[test]
                        fn when_zero_size_type_then_can_allocate_maximum_possible_amount() {
                            let mut actual = Dynamic::<()>::default();

                            _ = actual.reserve_back(isize::MAX as usize).expect("successful allocation");

                            debug_assert_eq!(actual.initialized, 0);
                            debug_assert_eq!(actual.front_capacity, 0);
                            debug_assert_eq!(actual.back_capacity, isize::MAX as usize);

                            _ = actual.reserve(isize::MAX as usize).expect("ZSTs do not occupy memory");

                            assert_eq!(actual.capacity(), isize::MAX as usize);
                        }

                        #[test]
                        fn then_does_not_modify_capacity() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_back(capacity).expect("successful allocation");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, 0);
                                debug_assert_eq!(actual.back_capacity, capacity);

                                _ = actual.reserve(capacity).expect("already enough capacity");

                                assert_eq!(actual.capacity(), capacity);
                            }
                        }

                        #[test]
                        fn then_does_not_initialize_elements() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_back(capacity).expect("successful allocation");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, 0);
                                debug_assert_eq!(actual.back_capacity, capacity);

                                _ = actual.reserve(capacity).expect("already enough capacity");

                                assert_eq!(actual.initialized, 0);
                            }
                        }

                        #[test]
                        fn then_does_not_reallocate_memory() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_back(capacity).expect("successful allocation");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, 0);
                                debug_assert_eq!(actual.back_capacity, capacity);

                                let allocation = actual.buffer;

                                _ = actual.reserve(capacity).expect("already enough capacity");

                                assert_eq!(actual.buffer, allocation);
                            }
                        }

                        #[test]
                        fn then_requested_many_elements_can_be_appended_without_reallocating_memory() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_back(capacity).expect("successful allocation");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, 0);
                                debug_assert_eq!(actual.back_capacity, capacity);

                                _ = actual.reserve(capacity).expect("already enough capacity");

                                let allocation = actual.buffer;

                                for element in 0..capacity {
                                    _ = actual.append(element).expect("uses capacity");
                                }

                                assert_eq!(actual.buffer, allocation);
                            }
                        }
                    }

                    mod when_not_empty {
                        use super::*;

                        #[test]
                        fn when_zero_size_type_then_can_allocate_maximum_possible_amount() {
                            for elements in 1..32 {
                                let mut actual: Dynamic<_> = core::iter::repeat_n((), elements).collect();

                                _ = actual.reserve_back(isize::MAX as usize - elements).expect("successful allocation");

                                debug_assert_eq!(actual.initialized, elements);
                                debug_assert_eq!(actual.front_capacity, 0);
                                debug_assert_eq!(actual.back_capacity, isize::MAX as usize - elements);

                                _ = actual.reserve(isize::MAX as usize - elements).expect("ZSTs do not occupy memory");

                                assert_eq!(actual.capacity(), isize::MAX as usize - elements);
                            }
                        }

                        #[test]
                        fn then_does_not_modify_front_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let mut actual: Dynamic<_> = (0..elements).collect();

                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    _ = actual.reserve(capacity).expect("already enough capacity");

                                    assert_eq!(actual.front_capacity, 0);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_back_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let mut actual: Dynamic<_> = (0..elements).collect();

                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    _ = actual.reserve(capacity).expect("already enough capacity");

                                    assert_eq!(actual.back_capacity, capacity);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_initialized_elements() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let expected = 0..elements;

                                    let mut actual: Dynamic<_> = expected.clone().collect();

                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    _ = actual.reserve(capacity).expect("already enough capacity");

                                    assert!(actual.eq(expected));
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_reallocate_memory() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let mut actual: Dynamic<_> = (0..elements).collect();

                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    let allocation = actual.buffer;

                                    _ = actual.reserve(capacity).expect("already enough capacity");

                                    assert_eq!(actual.buffer, allocation);
                                }
                            }
                        }

                        #[test]
                        fn then_requested_many_elements_can_be_appended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let expected = 0..elements;

                                    let mut actual: Dynamic<_> = expected.clone().collect();

                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    _ = actual.reserve(capacity).expect("already enough capacity");

                                    let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                    for _ in 0..capacity {
                                        // NOTE: this is distinct form the expected values.
                                        _ = actual.append(usize::MAX).expect("uses capacity");
                                    }

                                    assert!(pointers.iter().copied().eq(expected));
                                }
                            }
                        }
                    }
                }

                mod when_more_than_requested {
                    use super::*;

                    mod when_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_capacity() {
                            for capacity in 1..32 {
                                for additional in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_back(capacity + additional).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, capacity + additional);

                                    _ = actual.reserve(capacity).expect("already enough capacity");

                                    assert_eq!(actual.capacity(), capacity + additional);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_initialize_elements() {
                            for capacity in 1..32 {
                                for additional in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_back(capacity + additional).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, capacity + additional);

                                    _ = actual.reserve(capacity).expect("already enough capacity");

                                    assert_eq!(actual.initialized, 0);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_reallocate_memory() {
                            for capacity in 1..32 {
                                for additional in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_back(capacity + additional).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, capacity + additional);

                                    let allocation = actual.buffer;

                                    _ = actual.reserve(capacity).expect("already enough capacity");

                                    assert_eq!(actual.buffer, allocation);
                                }
                            }
                        }

                        #[test]
                        fn then_capacity_many_elements_can_be_appended_without_reallocating_memory() {
                            for capacity in 1..32 {
                                for additional in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_back(capacity + additional).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, capacity + additional);

                                    _ = actual.reserve(capacity).expect("already enough capacity");

                                    let allocation = actual.buffer;

                                    for element in 0..(capacity + additional) {
                                        _ = actual.append(element).expect("uses capacity");
                                    }

                                    assert_eq!(actual.buffer, allocation);
                                }
                            }
                        }
                    }

                    mod when_not_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_front_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let mut actual: Dynamic<_> = (0..elements).collect();

                                        _ = actual.reserve_back(capacity + additional).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, 0);
                                        debug_assert_eq!(actual.back_capacity, capacity + additional);

                                        _ = actual.reserve(capacity).expect("already enough capacity");

                                        assert_eq!(actual.front_capacity, 0);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_decrease_back_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let mut actual: Dynamic<_> = (0..elements).collect();

                                        _ = actual.reserve_back(capacity + additional).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, 0);
                                        debug_assert_eq!(actual.back_capacity, capacity + additional);

                                        _ = actual.reserve(capacity).expect("already enough capacity");

                                        assert_eq!(actual.back_capacity, capacity + additional);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_initialized_elements() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let expected = 0..elements;

                                        let mut actual: Dynamic<_> = expected.clone().collect();

                                        _ = actual.reserve_back(capacity + additional).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, 0);
                                        debug_assert_eq!(actual.back_capacity, capacity + additional);

                                        _ = actual.reserve(capacity).expect("already enough capacity");

                                        assert!(actual.eq(expected));
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_reallocate_memory() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let mut actual: Dynamic<_> = (0..elements).collect();

                                        _ = actual.reserve_back(capacity + additional).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, 0);
                                        debug_assert_eq!(actual.back_capacity, capacity + additional);

                                        let allocation = actual.buffer;

                                        _ = actual.reserve(capacity).expect("already enough capacity");

                                        assert_eq!(actual.buffer, allocation);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_capacity_many_elements_can_be_appended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let expected = 0..elements;

                                        let mut actual: Dynamic<_> = expected.clone().collect();

                                        _ = actual.reserve_back(capacity + additional).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, 0);
                                        debug_assert_eq!(actual.back_capacity, capacity + additional);

                                        _ = actual.reserve(capacity).expect("already enough capacity");

                                        let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                        for _ in 0..(capacity + additional) {
                                            // NOTE: this is distinct from the expected values
                                            _ = actual.append(usize::MAX).expect("uses capacity");
                                        }

                                        assert!(pointers.iter().copied().eq(expected));
                                    }
                                }
                            }
                        }
                    }
                }
            }

            mod when_both_front_and_back_capacity {
                use super::*;

                mod when_zero_requested {
                    use super::*;

                    mod when_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_capacity() {
                            for front in 1..32 {
                                for back in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_back(front + back).expect("successful allocation");

                                    _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, front);
                                    debug_assert_eq!(actual.back_capacity, back);

                                    _ = actual.reserve(0).expect("already enough capacity");

                                    assert_eq!(actual.capacity(), front + back);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_initialize_elements() {
                            for front in 1..32 {
                                for back in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_back(front + back).expect("successful allocation");

                                    _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, front);
                                    debug_assert_eq!(actual.back_capacity, back);

                                    _ = actual.reserve(0).expect("already enough capacity");

                                    assert_eq!(actual.initialized, 0);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_reallocate_memory() {
                            for front in 1..32 {
                                for back in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_back(front + back).expect("successful allocation");

                                    _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("back capacity to shift into");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, front);
                                    debug_assert_eq!(actual.back_capacity, back);

                                    let allocation = actual.buffer;

                                    _ = actual.reserve(0).expect("already enough capacity");

                                    assert_eq!(actual.buffer, allocation);
                                }
                            }
                        }

                        #[test]
                        fn then_capacity_many_elements_can_be_appended_without_reallocating_memory() {
                            for front in 1..32 {
                                for back in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_back(front + back).expect("successful allocation");

                                    _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("back capacity to shift into");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, front);
                                    debug_assert_eq!(actual.back_capacity, back);

                                    _ = actual.reserve(0).expect("already enough capacity");

                                    let allocation = actual.buffer;

                                    for element in 0..(front + back) {
                                        _ = actual.append(element).expect("uses capacity");
                                    }

                                    assert_eq!(actual.buffer, allocation);
                                }
                            }
                        }
                    }

                    mod when_not_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_front_capacity() {
                            for elements in 1..32 {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        let mut actual: Dynamic<_> = (0..elements).collect();

                                        _ = actual.reserve_front(front).expect("successful allocation");
                                        _ = actual.reserve_back(back).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.reserve(0).expect("already enough capacity");

                                        assert_eq!(actual.front_capacity, front);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_back_capacity() {
                            for elements in 1..32 {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        let mut actual: Dynamic<_> = (0..elements).collect();

                                        _ = actual.reserve_front(front).expect("successful allocation");
                                        _ = actual.reserve_back(back).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.reserve(0).expect("already enough capacity");

                                        assert_eq!(actual.back_capacity, back);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_initialized_elements() {
                            for elements in 1..32 {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        let expected = 0..elements;

                                        let mut actual: Dynamic<_> = expected.clone().collect();

                                        _ = actual.reserve_front(front).expect("successful allocation");
                                        _ = actual.reserve_back(back).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.reserve(0).expect("already enough capacity");

                                        assert!(actual.eq(expected));
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_reallocate_memory() {
                            for elements in 1..32 {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        let mut actual: Dynamic<_> = (0..elements).collect();

                                        _ = actual.reserve_front(front).expect("successful allocation");
                                        _ = actual.reserve_back(back).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        let allocation = actual.buffer;

                                        _ = actual.reserve(0).expect("already enough capacity");

                                        assert_eq!(actual.buffer, allocation);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_front_many_elements_can_be_prepended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        let expected = 0..elements;

                                        let mut actual: Dynamic<_> = expected.clone().collect();

                                        _ = actual.reserve_front(front).expect("successful allocation");
                                        _ = actual.reserve_back(back).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.reserve(0).expect("already enough capacity");

                                        let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                        for _ in 0..front {
                                            // NOTE: this is distinct from the expected values.
                                            _ = actual.prepend(usize::MAX).expect("uses capacity");
                                        }

                                        assert!(pointers.iter().copied().eq(expected));
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_back_many_elements_can_be_appended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        let expected = 0..elements;

                                        let mut actual: Dynamic<_> = expected.clone().collect();

                                        _ = actual.reserve_front(front).expect("successful allocation");
                                        _ = actual.reserve_back(back).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.reserve(0).expect("already enough capacity");

                                        let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                        for _ in 0..back {
                                            // NOTE: this is distinct from the expected values.
                                            _ = actual.append(usize::MAX).expect("uses capacity");
                                        }

                                        assert!(pointers.iter().copied().eq(expected));
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_both_front_many_elements_can_be_prepended_and_back_many_elements_can_be_appended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        let expected = 0..elements;

                                        let mut actual: Dynamic<_> = expected.clone().collect();

                                        _ = actual.reserve_front(front).expect("successful allocation");
                                        _ = actual.reserve_back(back).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.reserve(0).expect("already enough capacity");

                                        let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                        for _ in 0..front {
                                            // NOTE: this is distinct from the expected values.
                                            _ = actual.prepend(usize::MAX).expect("uses capacity");
                                        }

                                        for _ in 0..back {
                                            // NOTE: this is distinct from the expected values.
                                            _ = actual.append(usize::MAX).expect("uses capacity");
                                        }

                                        assert!(pointers.iter().copied().eq(expected));
                                    }
                                }
                            }
                        }
                    }
                }

                mod when_both_less_than_requested {
                    use super::*;

                    mod when_sum_is_less_than_requested {
                        use super::*;

                        mod when_empty {
                            use super::*;

                            #[test]
                            fn when_zero_size_type_then_can_allocate_maximum_possible_amount() {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        let mut actual = Dynamic::<()>::default();

                                        _ = actual.reserve_back(front + back).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.reserve(isize::MAX as usize).expect("successful allocation");

                                        assert_eq!(actual.capacity(), isize::MAX as usize);
                                    }
                                }
                            }

                            #[test]
                            fn then_increases_capacity_to_bounding_power_of_two_of_requested() {
                                for exponent in 0..(isize::BITS - 2) {
                                    let power = usize::pow(2, exponent);

                                    for additional in 1..32 {
                                        // The goal is to test all combinations
                                        // of front and back capacities which
                                        // sum to the overall power. It is
                                        // obviously not practical to iterate
                                        // through all values of a `usize` so
                                        // this is good enough.
                                        for front in 0..exponent {
                                            let mut actual = Dynamic::<()>::default();

                                            _ = actual.reserve_back(power).expect("successful allocation");

                                            let front = usize::pow(2, front);
                                            _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                            debug_assert_eq!(actual.initialized, 0);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, power - front);

                                            _ = actual.reserve(power + additional);

                                            assert_eq!(actual.capacity(), (power + additional).next_power_of_two());
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_initialize_elements() {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        for additional in 1..32 {
                                            let mut actual = Dynamic::<usize>::default();

                                            _ = actual.reserve_back(front + back).expect("successful allocation");

                                            _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                            debug_assert_eq!(actual.initialized, 0);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.reserve(front + back + additional).expect("successful allocation");

                                            assert_eq!(actual.initialized, 0);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_requested_many_elements_can_be_appended_without_reallocating_memory() {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        for additional in 1..32 {
                                            let mut actual = Dynamic::<usize>::default();

                                            _ = actual.reserve_back(front + back).expect("successful allocation");

                                            _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                            debug_assert_eq!(actual.initialized, 0);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.reserve(front + back + additional).expect("successful allocation");

                                            let allocation = actual.buffer;

                                            for element in 0..(front + back + additional) {
                                                _ = actual.append(element).expect("uses capacity");
                                            }

                                            assert_eq!(actual.buffer, allocation);
                                        }
                                    }
                                }
                            }
                        }

                        mod when_not_empty {
                            use super::*;

                            #[test]
                            fn when_zero_size_type_then_can_allocate_maximum_possible_amount() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            let mut actual: Dynamic<_> = core::iter::repeat_n((), elements).collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.reserve(isize::MAX as usize - elements).expect("successful allocation");

                                            assert_eq!(actual.capacity(), isize::MAX as usize - elements);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_decreases_front_capacity_to_zero() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            for additional in 1..32 {
                                                let mut actual: Dynamic<_> = (0..elements).collect();

                                                _ = actual.reserve_front(front).expect("successful allocation");
                                                _ = actual.reserve_back(back).expect("successful allocation");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front);
                                                debug_assert_eq!(actual.back_capacity, back);

                                                _ = actual.reserve(front + back + additional).expect("successful allocation");

                                                assert_eq!(actual.front_capacity, 0);
                                            }
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_increases_capacity_to_bounding_power_of_two_of_requested() {
                                for elements in 1..32 {
                                    for exponent in 0..(isize::BITS - 2) {
                                        let power = usize::pow(2, exponent);

                                        for additional in 1..32 {
                                            // The goal is to test all combinations
                                            // of front and back capacities which
                                            // sum to the overall power. It is
                                            // obviously not practical to iterate
                                            // through all values of a `usize` so
                                            // this is good enough.
                                            for front in 0..exponent {
                                                let mut actual: Dynamic<_> = core::iter::repeat_n((), elements).collect();

                                                _ = actual.reserve_back(power).expect("successful allocation");

                                                let front = usize::pow(2, front);
                                                _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front);
                                                debug_assert_eq!(actual.back_capacity, power - front);

                                                _ = actual.reserve(power + additional);

                                                assert_eq!(actual.capacity(), (power + additional + elements).next_power_of_two() - elements);
                                            }
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_modify_initialized_elements() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            for additional in 1..32 {
                                                let expected = 0..elements;

                                                let mut actual: Dynamic<_> = expected.clone().collect();

                                                _ = actual.reserve_front(front).expect("successful allocation");
                                                _ = actual.reserve_back(back).expect("successful allocation");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front);
                                                debug_assert_eq!(actual.back_capacity, back);

                                                _ = actual.reserve(front + back + additional).expect("successful allocation");

                                                assert!(actual.eq(expected));
                                            }
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_requested_many_elements_can_be_appended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            for additional in 1..32 {
                                                let expected = 0..elements;

                                                let mut actual: Dynamic<_> = expected.clone().collect();

                                                _ = actual.reserve_front(front).expect("successful allocation");
                                                _ = actual.reserve_back(back).expect("successful allocation");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front);
                                                debug_assert_eq!(actual.back_capacity, back);

                                                _ = actual.reserve(front + back + additional).expect("successful allocation");

                                                let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                                for _ in 0..(front + back + additional) {
                                                    // NOTE: this is distinct from the expected values.
                                                    _ = actual.append(usize::MAX).expect("uses capacity");
                                                }

                                                assert!(pointers.iter().copied().eq(expected));
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }

                    mod when_sum_is_exactly_requested {
                        use super::*;

                        mod when_empty {
                            use super::*;

                            #[test]
                            fn when_zero_size_type_then_can_allocate_maximum_possible_amount() {
                                for exponent in 0..(isize::BITS - 2) {
                                    let mut actual = Dynamic::<()>::default();

                                    _ = actual.reserve_back(isize::MAX as usize).expect("ZSTs do not occupy memory");

                                    let front = usize::pow(2, exponent);

                                    _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, front);
                                    debug_assert_eq!(actual.back_capacity, isize::MAX as usize - front);

                                    _ = actual.reserve(isize::MAX as usize).expect("already enough capacity");

                                    assert_eq!(actual.capacity(), isize::MAX as usize);
                                }
                            }

                            #[test]
                            fn then_does_not_modify_capacity() {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(front + back).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.reserve(front + back).expect("exactly enough capacity");

                                        assert_eq!(actual.capacity(), front + back);
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_initialize_elements() {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(front + back).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.reserve(front + back).expect("exactly enough capacity");

                                        assert_eq!(actual.initialized, 0);
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_reallocate_memory() {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(front + back).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        let allocation = actual.buffer;

                                        _ = actual.reserve(front + back).expect("exactly enough capacity");

                                        assert_eq!(actual.buffer, allocation);
                                    }
                                }
                            }

                            #[test]
                            fn then_requested_many_elements_can_be_appended_without_reallocating_memory() {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(front + back).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.reserve(front + back).expect("exactly enough capacity");

                                        let allocation = actual.buffer;

                                        for element in 0..(front + back) {
                                            _ = actual.append(element).expect("uses capacity");
                                        }

                                        assert_eq!(actual.buffer, allocation);
                                    }
                                }
                            }
                        }

                        mod when_not_empty {
                            use super::*;

                            #[test]
                            fn when_zero_size_type_then_can_allocate_maximum_possible_amount() {
                                for elements in 1..32 {
                                    for exponent in 0..(isize::BITS - 2) {
                                        let mut actual: Dynamic<_> = core::iter::repeat_n((), elements).collect();

                                        _ = actual.reserve_back(isize::MAX as usize - elements).expect("ZSTs do not occupy memory");

                                        let front = usize::pow(2, exponent);

                                        _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, isize::MAX as usize - elements - front);

                                        _ = actual.reserve(isize::MAX as usize - elements).expect("already enough capacity");

                                        assert_eq!(actual.capacity(), isize::MAX as usize - elements);
                                    }
                                }
                            }

                            #[test]
                            fn then_decreases_front_capacity_to_zero() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.reserve(front + back).expect("already enough capacity");

                                            assert_eq!(actual.front_capacity, 0);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_increases_back_capacity_to_sum_with_front_capacity() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.reserve(front + back).expect("already enough capacity");

                                            assert_eq!(actual.back_capacity, front + back);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_modify_initialized_elements() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.reserve(front + back).expect("already enough capacity");

                                            assert!(actual.eq(expected));
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_reallocate_memory() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            let allocation = actual.buffer;

                                            _ = actual.reserve(front + back).expect("already enough capacity");

                                            assert_eq!(actual.buffer, allocation);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_requested_many_elements_can_be_appended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.reserve(front + back).expect("already enough capacity");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..(front + back) {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.append(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }
                        }
                    }

                    mod when_sum_is_more_than_requested {
                        use super::*;

                        mod when_empty {
                            use super::*;

                            #[test]
                            fn then_does_not_modify_capacity() {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        for additional in 1..usize::min(front, back) {
                                            let mut actual = Dynamic::<usize>::default();

                                            _ = actual.reserve_back(front + back).expect("successful allocation");

                                            _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                            debug_assert_eq!(actual.initialized, 0);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.reserve(front + back - additional).expect("already enough capacity");

                                            assert_eq!(actual.capacity(), front + back );
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_initialize_elements() {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        for additional in 1..usize::min(front, back) {
                                            let mut actual = Dynamic::<usize>::default();

                                            _ = actual.reserve_back(front + back).expect("successful allocation");

                                            _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                            debug_assert_eq!(actual.initialized, 0);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.reserve(front + back - additional).expect("already enough capacity");

                                            assert_eq!(actual.initialized, 0);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_reallocate_memory() {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        for additional in 1..usize::min(front, back) {
                                            let mut actual = Dynamic::<usize>::default();

                                            _ = actual.reserve_back(front + back).expect("successful allocation");

                                            _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                            debug_assert_eq!(actual.initialized, 0);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            let allocation = actual.buffer;

                                            _ = actual.reserve(front + back - additional).expect("already enough capacity");

                                            assert_eq!(actual.buffer, allocation);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_capacity_many_elements_can_be_appended_without_reallocating_memory() {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        for additional in 1..usize::min(front, back) {
                                            let mut actual = Dynamic::<usize>::default();

                                            _ = actual.reserve_back(front + back).expect("successful allocation");

                                            _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                            debug_assert_eq!(actual.initialized, 0);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.reserve(front + back - additional).expect("already enough capacity");

                                            let allocation = actual.buffer;

                                            for element in 0..(front + back - additional) {
                                                _ = actual.append(element).expect("uses capacity");
                                            }

                                            assert_eq!(actual.buffer, allocation);
                                        }
                                    }
                                }
                            }
                        }

                        mod when_not_empty {
                            use super::*;

                            #[test]
                            fn then_decreases_front_capacity_to_zero() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            for additional in 1..usize::min(front, back) {
                                                let mut actual: Dynamic<_> = (0..elements).collect();

                                                _ = actual.reserve_back(front + back).expect("successful allocation");

                                                _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front);
                                                debug_assert_eq!(actual.back_capacity, back);

                                                _ = actual.reserve(front + back - additional).expect("already enough capacity");

                                                assert_eq!(actual.front_capacity, 0);
                                            }
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_increases_back_capacity_to_sum_with_front_capacity() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            for additional in 1..usize::min(front, back) {
                                                let mut actual: Dynamic<_> = (0..elements).collect();

                                                _ = actual.reserve_back(front + back).expect("successful allocation");

                                                _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front);
                                                debug_assert_eq!(actual.back_capacity, back);

                                                _ = actual.reserve(front + back - additional).expect("already enough capacity");

                                                assert_eq!(actual.back_capacity, front + back);
                                            }
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_modify_initialized_elements() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            for additional in 1..usize::min(front, back) {
                                                let expected = 0..elements;

                                                let mut actual: Dynamic<_> = expected.clone().collect();

                                                _ = actual.reserve_back(front + back).expect("successful allocation");

                                                _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front);
                                                debug_assert_eq!(actual.back_capacity, back);

                                                _ = actual.reserve(front + back - additional).expect("already enough capacity");

                                                assert!(actual.eq(expected));
                                            }
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_reallocate_memory() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            for additional in 1..usize::min(front, back) {
                                                let mut actual: Dynamic<_> = (0..elements).collect();

                                                _ = actual.reserve_back(front + back).expect("successful allocation");

                                                _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front);
                                                debug_assert_eq!(actual.back_capacity, back);

                                                let allocation = actual.buffer;

                                                _ = actual.reserve(front + back - additional).expect("already enough capacity");

                                                assert_eq!(actual.buffer, allocation);
                                            }
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_capacity_many_elements_can_be_appended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            for additional in 1..usize::min(front, back) {
                                                let expected = 0..elements;

                                                let mut actual: Dynamic<_> = expected.clone().collect();

                                                _ = actual.reserve_back(front + back).expect("successful allocation");

                                                _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front);
                                                debug_assert_eq!(actual.back_capacity, back);

                                                _ = actual.reserve(front + back - additional).expect("already enough capacity");

                                                let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                                for _ in 0..(front + back) {
                                                    // NOTE: this is distinct from the expected values.
                                                    _ = actual.append(usize::MAX).expect("uses capacity");
                                                }

                                                assert!(pointers.iter().copied().eq(expected));
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                mod when_front_is_exactly_requested {
                    use super::*;

                    mod when_back_is_less_than_requested {
                        use super::*;

                        mod when_empty {
                            use super::*;

                            #[test]
                            fn then_does_not_modify_capacity() {
                                for front in 1..32 {
                                    for back in 1..front {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(front + back).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.reserve(front).expect("already enough capacity");

                                        assert_eq!(actual.capacity(), front + back);
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_initialize_elements() {
                                for front in 1..32 {
                                    for back in 1..front {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(front + back).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.reserve(front).expect("already enough capacity");

                                        assert_eq!(actual.initialized, 0);
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_reallocate_memory() {
                                for front in 1..32 {
                                    for back in 1..front {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(front + back).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        let allocation = actual.buffer;

                                        _ = actual.reserve(front).expect("already enough capacity");

                                        assert_eq!(actual.buffer, allocation);
                                    }
                                }
                            }

                            #[test]
                            fn then_capacity_many_elements_can_be_appended_without_reallocating_memory() {
                                for front in 1..32 {
                                    for back in 1..front {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(front + back).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.reserve(front).expect("already enough capacity");

                                        let allocation = actual.buffer;

                                        for element in 0..(front + back) {
                                            _ = actual.append(element).expect("uses capacity");
                                        }

                                        assert_eq!(actual.buffer, allocation);
                                    }
                                }
                            }
                        }

                        mod when_not_empty {
                            use super::*;

                            #[test]
                            fn then_decreases_front_capacity_to_zero() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..front {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.reserve(front).expect("already enough capacity");

                                            assert_eq!(actual.front_capacity, 0);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_increases_back_capacity_to_sum_with_front_capacity() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..front {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.reserve(front).expect("already enough capacity");

                                            assert_eq!(actual.back_capacity, front + back);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_modify_initialized_elements() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..front {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.reserve(front).expect("already enough capacity");

                                            assert!(actual.eq(expected));
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_reallocate_memory() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..front {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            let allocation = actual.buffer;

                                            _ = actual.reserve(front).expect("already enough capacity");

                                            assert_eq!(actual.buffer, allocation);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_capacity_many_elements_can_be_appended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..front {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.reserve(front).expect("already enough capacity");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..(front + back) {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.append(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }
                        }
                    }

                    mod when_back_is_more_than_requested {
                        use super::*;

                        mod when_empty {
                            use super::*;

                            #[test]
                            fn then_does_not_modify_capacity() {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(capacity + capacity + additional).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(capacity).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, capacity);
                                        debug_assert_eq!(actual.back_capacity, capacity + additional);

                                        _ = actual.reserve(capacity).expect("already enough capacity");

                                        assert_eq!(actual.capacity(), capacity + capacity + additional);
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_initialize_elements() {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(capacity + capacity + additional).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(capacity).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, capacity);
                                        debug_assert_eq!(actual.back_capacity, capacity + additional);

                                        _ = actual.reserve(capacity).expect("already enough capacity");

                                        assert_eq!(actual.initialized, 0);
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_reallocate_memory() {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(capacity + capacity + additional).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(capacity).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, capacity);
                                        debug_assert_eq!(actual.back_capacity, capacity + additional);

                                        let allocation = actual.buffer;

                                        _ = actual.reserve(capacity).expect("already enough capacity");

                                        assert_eq!(actual.buffer, allocation);
                                    }
                                }
                            }

                            #[test]
                            fn then_capacity_many_elements_can_be_appended_without_reallocating_memory() {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(capacity + capacity + additional).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(capacity).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, capacity);
                                        debug_assert_eq!(actual.back_capacity, capacity + additional);

                                        _ = actual.reserve(capacity).expect("already enough capacity");

                                        let allocation = actual.buffer;

                                        for element in 0..(capacity + capacity + additional) {
                                            _ = actual.append(element).expect("uses capacity");
                                        }

                                        assert_eq!(actual.buffer, allocation);
                                    }
                                }
                            }
                        }

                        mod when_not_empty {
                            use super::*;

                            #[test]
                            fn then_does_not_modify_front_capacity() {
                                for elements in 1..32 {
                                    for capacity in 1..32 {
                                        for additional in 1..32 {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(capacity ).expect("successful allocation");
                                            _ = actual.reserve_back(capacity + additional).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, capacity);
                                            debug_assert_eq!(actual.back_capacity, capacity + additional);

                                            _ = actual.reserve(capacity).expect("already enough capacity");

                                            assert_eq!(actual.front_capacity, capacity);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_modify_back_capacity() {
                                for elements in 1..32 {
                                    for capacity in 1..32 {
                                        for additional in 1..32 {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(capacity).expect("successful allocation");
                                            _ = actual.reserve_back(capacity + additional).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, capacity);
                                            debug_assert_eq!(actual.back_capacity, capacity + additional);

                                            _ = actual.reserve(capacity).expect("already enough capacity");

                                            assert_eq!(actual.back_capacity, capacity + additional);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_modify_initialized_elements() {
                                for elements in 1..32 {
                                    for capacity in 1..32 {
                                        for additional in 1..32 {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(capacity).expect("successful allocation");
                                            _ = actual.reserve_back(capacity + additional).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, capacity);
                                            debug_assert_eq!(actual.back_capacity, capacity + additional);

                                            _ = actual.reserve(capacity).expect("already enough capacity");

                                            assert!(actual.eq(expected));
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_reallocate_memory() {
                                for elements in 1..32 {
                                    for capacity in 1..32 {
                                        for additional in 1..32 {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(capacity).expect("successful allocation");
                                            _ = actual.reserve_back(capacity + additional).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, capacity);
                                            debug_assert_eq!(actual.back_capacity, capacity + additional);

                                            let allocation = actual.buffer;

                                            _ = actual.reserve(capacity).expect("already enough capacity");

                                            assert_eq!(actual.buffer, allocation);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_front_many_elements_can_be_prepended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for capacity in 1..32 {
                                        for additional in 1..32 {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(capacity).expect("successful allocation");
                                            _ = actual.reserve_back(capacity + additional).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, capacity);
                                            debug_assert_eq!(actual.back_capacity, capacity + additional);

                                            _ = actual.reserve(capacity).expect("already enough capacity");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..capacity {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.prepend(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_back_many_elements_can_be_appended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for capacity in 1..32 {
                                        for additional in 1..32 {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(capacity).expect("successful allocation");
                                            _ = actual.reserve_back(capacity + additional).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, capacity);
                                            debug_assert_eq!(actual.back_capacity, capacity + additional);

                                            _ = actual.reserve(capacity).expect("already enough capacity");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..(capacity + additional) {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.append(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_both_front_many_elements_can_be_prepended_and_back_many_elements_can_be_appended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for capacity in 1..32 {
                                        for additional in 1..32 {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(capacity).expect("successful allocation");
                                            _ = actual.reserve_back(capacity + additional).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, capacity);
                                            debug_assert_eq!(actual.back_capacity, capacity + additional);

                                            _ = actual.reserve(capacity).expect("already enough capacity");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..capacity {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.prepend(usize::MAX).expect("uses capacity");
                                            }

                                            for _ in 0..(capacity + additional) {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.append(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                mod when_back_is_exactly_requested {
                    use super::*;

                    mod when_front_is_less_than_requested {
                        use super::*;

                        mod when_empty {
                            use super::*;

                            #[test]
                            fn then_does_not_modify_capacity() {
                                for back in 1..32 {
                                    for front in 1..back {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(front + back).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.reserve(back).expect("already enough capacity");

                                        assert_eq!(actual.capacity(), front + back);
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_initialize_elements() {
                                for back in 1..32 {
                                    for front in 1..back {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(front + back).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.reserve(back).expect("already enough capacity");

                                        assert_eq!(actual.initialized, 0);
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_reallocate_memory() {
                                for back in 1..32 {
                                    for front in 1..back {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(front + back).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        let allocation = actual.buffer;

                                        _ = actual.reserve(back).expect("already enough capacity");

                                        assert_eq!(actual.buffer, allocation);
                                    }
                                }
                            }

                            #[test]
                            fn then_capacity_many_elements_can_be_appended_without_reallocating_memory() {
                                for back in 1..32 {
                                    for front in 1..back {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(front + back).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.reserve(back).expect("already enough capacity");

                                        let allocation = actual.buffer;

                                        for element in 0..(front + back) {
                                            _ = actual.append(element).expect("uses capacity");
                                        }

                                        assert_eq!(actual.buffer, allocation);
                                    }
                                }
                            }
                        }

                        mod when_not_empty {
                            use super::*;

                            #[test]
                            fn then_does_not_modify_front_capacity() {
                                for elements in 1..32 {
                                    for back in 1..32 {
                                        for front in 1..back {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.reserve(back).expect("already enough capacity");

                                            assert_eq!(actual.front_capacity, front);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_modify_back_capacity() {
                                for elements in 1..32 {
                                    for back in 1..32 {
                                        for front in 1..back {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.reserve(back).expect("already enough capacity");

                                            assert_eq!(actual.back_capacity, back);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_modify_initialized_elements() {
                                for elements in 1..32 {
                                    for back in 1..32 {
                                        for front in 1..back {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.reserve(back).expect("already enough capacity");

                                            assert!(actual.eq(expected));
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_reallocate_memory() {
                                for elements in 1..32 {
                                    for back in 1..32 {
                                        for front in 1..back {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            let allocation = actual.buffer;

                                            _ = actual.reserve(back).expect("already enough capacity");

                                            assert_eq!(actual.buffer, allocation);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_front_many_elements_can_be_prepended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for back in 1..32 {
                                        for front in 1..back {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.reserve(back).expect("already enough capacity");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..front {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.prepend(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_requested_many_elements_can_be_appended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for back in 1..32 {
                                        for front in 1..back {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.reserve(back).expect("already enough capacity");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..back {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.append(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_both_front_many_elements_can_be_prepended_and_requested_many_elements_can_be_appended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for back in 1..32 {
                                        for front in 1..back {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.reserve(back).expect("already enough capacity");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..front {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.prepend(usize::MAX).expect("uses capacity");
                                            }

                                            for _ in 0..back {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.append(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }
                        }
                    }

                    mod when_front_is_more_than_requested {
                        use super::*;

                        mod when_empty {
                            use super::*;

                            #[test]
                            fn then_does_not_modify_capacity() {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(capacity + additional + capacity).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(capacity + additional).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, capacity + additional);
                                        debug_assert_eq!(actual.back_capacity, capacity);

                                        _ = actual.reserve(capacity).expect("already enough capacity");

                                        assert_eq!(actual.capacity(), capacity + additional + capacity);
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_initialize_elements() {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(capacity + additional + capacity).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(capacity + additional).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, capacity + additional);
                                        debug_assert_eq!(actual.back_capacity, capacity);

                                        _ = actual.reserve(capacity).expect("already enough capacity");

                                        assert_eq!(actual.initialized, 0);
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_reallocate_memory() {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(capacity + additional + capacity).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(capacity + additional).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, capacity + additional);
                                        debug_assert_eq!(actual.back_capacity, capacity);

                                        let allocation = actual.buffer;

                                        _ = actual.reserve(capacity).expect("already enough capacity");

                                        assert_eq!(actual.buffer, allocation);
                                    }
                                }
                            }

                            #[test]
                            fn then_capacity_many_elements_can_be_appended_without_reallocating_memory() {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(capacity + additional + capacity).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(capacity + additional).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, capacity + additional);
                                        debug_assert_eq!(actual.back_capacity, capacity);

                                        _ = actual.reserve(capacity).expect("already enough capacity");

                                        let allocation = actual.buffer;

                                        for element in 0..(capacity + additional + capacity) {
                                            _ = actual.append(element).expect("uses capacity");
                                        }

                                        assert_eq!(actual.buffer, allocation);
                                    }
                                }
                            }
                        }

                        mod when_not_empty {
                            use super::*;

                            #[test]
                            fn then_does_not_modify_front_capacity() {
                                for elements in 1..32 {
                                    for capacity in 1..32 {
                                        for additional in 1..32 {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_back(capacity + additional + capacity).expect("successful allocation");

                                            _ = actual.shift(isize::try_from(capacity + additional).expect("too small to wrap")).expect("enough back capacity to shift into");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, capacity + additional);
                                            debug_assert_eq!(actual.back_capacity, capacity);

                                            _ = actual.reserve(capacity).expect("already enough capacity");

                                            assert_eq!(actual.front_capacity, capacity + additional);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_modify_back_capacity() {
                                for elements in 1..32 {
                                    for capacity in 1..32 {
                                        for additional in 1..32 {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_back(capacity + additional + capacity).expect("successful allocation");

                                            _ = actual.shift(isize::try_from(capacity + additional).expect("too small to wrap")).expect("enough back capacity to shift into");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, capacity + additional);
                                            debug_assert_eq!(actual.back_capacity, capacity);

                                            _ = actual.reserve(capacity).expect("already enough capacity");

                                            assert_eq!(actual.back_capacity, capacity);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_modify_initialized_elements() {
                                for elements in 1..32 {
                                    for capacity in 1..32 {
                                        for additional in 1..32 {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_back(capacity + additional + capacity).expect("successful allocation");

                                            _ = actual.shift(isize::try_from(capacity + additional).expect("too small to wrap")).expect("enough back capacity to shift into");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, capacity + additional);
                                            debug_assert_eq!(actual.back_capacity, capacity);

                                            _ = actual.reserve(capacity).expect("already enough capacity");

                                            assert!(actual.eq(expected));
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_reallocate_memory() {
                                for elements in 1..32 {
                                    for capacity in 1..32 {
                                        for additional in 1..32 {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_back(capacity + additional + capacity).expect("successful allocation");

                                            _ = actual.shift(isize::try_from(capacity + additional).expect("too small to wrap")).expect("enough back capacity to shift into");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, capacity + additional);
                                            debug_assert_eq!(actual.back_capacity, capacity);

                                            let allocation = actual.buffer;

                                            _ = actual.reserve(capacity).expect("already enough capacity");

                                            assert_eq!(actual.buffer, allocation);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_front_many_elements_can_be_prepended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for capacity in 1..32 {
                                        for additional in 1..32 {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_back(capacity + additional + capacity).expect("successful allocation");

                                            _ = actual.shift(isize::try_from(capacity + additional).expect("too small to wrap")).expect("enough back capacity to shift into");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, capacity + additional);
                                            debug_assert_eq!(actual.back_capacity, capacity);

                                            _ = actual.reserve(capacity).expect("already enough capacity");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..(capacity + additional) {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.prepend(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_requested_many_elements_can_be_appended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for capacity in 1..32 {
                                        for additional in 1..32 {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_back(capacity + additional + capacity).expect("successful allocation");

                                            _ = actual.shift(isize::try_from(capacity + additional).expect("too small to wrap")).expect("enough back capacity to shift into");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, capacity + additional);
                                            debug_assert_eq!(actual.back_capacity, capacity);

                                            _ = actual.reserve(capacity).expect("already enough capacity");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..capacity {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.append(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_both_front_many_elements_can_be_prepended_and_requested_many_elements_can_be_appended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for capacity in 1..32 {
                                        for additional in 1..32 {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_back(capacity + additional + capacity).expect("successful allocation");

                                            _ = actual.shift(isize::try_from(capacity + additional).expect("too small to wrap")).expect("enough back capacity to shift into");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, capacity + additional);
                                            debug_assert_eq!(actual.back_capacity, capacity);

                                            _ = actual.reserve(capacity).expect("already enough capacity");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..(capacity + additional) {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.prepend(usize::MAX).expect("uses capacity");
                                            }

                                            for _ in 0..capacity {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.append(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                mod when_both_exactly_requested {
                    use super::*;

                    mod when_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_capacity() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_back(capacity + capacity).expect("successful allocation");

                                _ = actual.shift(isize::try_from(capacity).expect("too small to wrap")).expect("enough back capacity");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, capacity);
                                debug_assert_eq!(actual.back_capacity, capacity);

                                _ = actual.reserve(capacity).expect("already enough capacity");

                                assert_eq!(actual.capacity(), capacity + capacity);
                            }
                        }

                        #[test]
                        fn then_does_not_initialize_elements() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_back(capacity + capacity).expect("successful allocation");

                                _ = actual.shift(isize::try_from(capacity).expect("too small to wrap")).expect("enough back capacity");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, capacity);
                                debug_assert_eq!(actual.back_capacity, capacity);

                                _ = actual.reserve(capacity).expect("already enough capacity");

                                assert_eq!(actual.initialized, 0);
                            }
                        }

                        #[test]
                        fn then_does_not_reallocate_memory() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_back(capacity + capacity).expect("successful allocation");

                                _ = actual.shift(isize::try_from(capacity).expect("too small to wrap")).expect("enough back capacity");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, capacity);
                                debug_assert_eq!(actual.back_capacity, capacity);

                                let allocation = actual.buffer;

                                _ = actual.reserve(capacity).expect("already enough capacity");

                                assert_eq!(actual.buffer, allocation);
                            }
                        }

                        #[test]
                        fn then_requested_many_elements_can_be_appended_without_reallocating_memory() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_back(capacity + capacity).expect("successful allocation");

                                _ = actual.shift(isize::try_from(capacity).expect("too small to wrap")).expect("enough back capacity");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, capacity);
                                debug_assert_eq!(actual.back_capacity, capacity);

                                _ = actual.reserve(capacity).expect("already enough capacity");

                                let allocation = actual.buffer;

                                for element in 0..capacity {
                                    _ = actual.append(element).expect("uses capacity");
                                }

                                assert_eq!(actual.buffer, allocation);
                            }
                        }
                    }

                    mod when_not_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_front_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let mut actual: Dynamic<_> = (0..elements).collect();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");
                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    _ = actual.reserve(capacity).expect("already enough capacity");

                                    assert_eq!(actual.front_capacity, capacity);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_back_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let mut actual: Dynamic<_> = (0..elements).collect();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");
                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    _ = actual.reserve(capacity).expect("already enough capacity");

                                    assert_eq!(actual.back_capacity, capacity);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_initialized_elements() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let expected = 0..elements;

                                    let mut actual: Dynamic<_> = expected.clone().collect();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");
                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    _ = actual.reserve(capacity).expect("already enough capacity");

                                    assert!(actual.eq(expected));
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_reallocate_memory() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let expected = 0..elements;

                                    let mut actual: Dynamic<_> = expected.clone().collect();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");
                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    let allocation = actual.buffer;

                                    _ = actual.reserve(capacity).expect("already enough capacity");

                                    assert_eq!(actual.buffer, allocation);
                                }
                            }
                        }

                        #[test]
                        fn then_front_many_elements_can_be_prepended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let expected = 0..elements;

                                    let mut actual: Dynamic<_> = expected.clone().collect();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");
                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    _ = actual.reserve(capacity).expect("already enough capacity");

                                    let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                    for _ in 0..capacity {
                                        // NOTE: this is distinct from the expected values.
                                        _ = actual.prepend(usize::MAX).expect("uses capacity");
                                    }

                                    assert!(pointers.iter().copied().eq(expected));
                                }
                            }
                        }

                        #[test]
                        fn then_requested_many_elements_can_be_appended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let expected = 0..elements;

                                    let mut actual: Dynamic<_> = expected.clone().collect();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");
                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    _ = actual.reserve(capacity).expect("already enough capacity");

                                    let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                    for _ in 0..capacity {
                                        // NOTE: this is distinct from the expected values.
                                        _ = actual.append(usize::MAX).expect("uses capacity");
                                    }

                                    assert!(pointers.iter().copied().eq(expected));
                                }
                            }
                        }

                        #[test]
                        fn then_both_front_many_elements_can_be_prepended_and_requested_many_elements_can_be_appended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let expected = 0..elements;

                                    let mut actual: Dynamic<_> = expected.clone().collect();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");
                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    _ = actual.reserve(capacity).expect("already enough capacity");

                                    let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                    for _ in 0..capacity {
                                        // NOTE: this is distinct from the expected values.
                                        _ = actual.prepend(usize::MAX).expect("uses capacity");
                                    }

                                    for _ in 0..capacity {
                                        // NOTE: this is distinct from the expected values.
                                        _ = actual.append(usize::MAX).expect("uses capacity");
                                    }

                                    assert!(pointers.iter().copied().eq(expected));
                                }
                            }
                        }
                    }
                }

                mod when_front_is_more_than_requested_and_back_is_less_than_requested {
                    use super::*;

                    mod when_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_capacity() {
                            for capacity in 1..32 {
                                for more in capacity..(capacity + 32) {
                                    for less in 1..capacity {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(more + less).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(more).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, more);
                                        debug_assert_eq!(actual.back_capacity, less);

                                        _ = actual.reserve(capacity).expect("already enough capacity");

                                        assert_eq!(actual.capacity(), more + less);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_initialize_elements() {
                            for capacity in 1..32 {
                                for more in capacity..(capacity + 32) {
                                    for less in 1..capacity {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(more + less).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(more).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, more);
                                        debug_assert_eq!(actual.back_capacity, less);

                                        _ = actual.reserve(capacity).expect("already enough capacity");

                                        assert_eq!(actual.initialized, 0);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_reallocate_memory() {
                            for capacity in 1..32 {
                                for more in capacity..(capacity + 32) {
                                    for less in 1..capacity {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(more + less).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(more).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, more);
                                        debug_assert_eq!(actual.back_capacity, less);

                                        let allocation = actual.buffer;

                                        _ = actual.reserve(capacity).expect("already enough capacity");

                                        assert_eq!(actual.buffer, allocation);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_capacity_many_elements_can_be_appended_without_reallocating_memory() {
                            for capacity in 1..32 {
                                for more in capacity..(capacity + 32) {
                                    for less in 1..capacity {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(more + less).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(more).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, more);
                                        debug_assert_eq!(actual.back_capacity, less);

                                        _ = actual.reserve(capacity).expect("already enough capacity");

                                        let allocation = actual.buffer;

                                        for element in 0..(more + less) {
                                            _ = actual.append(element).expect("uses capacity");
                                        }

                                        assert_eq!(actual.buffer, allocation);
                                    }
                                }
                            }
                        }
                    }

                    mod when_not_empty {
                        use super::*;

                        #[test]
                        fn then_decreases_front_capacity_to_zero() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for more in capacity..(capacity + 32) {
                                        for less in 1..capacity {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(more).expect("successful allocation");
                                            _ = actual.reserve_back(less).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, more);
                                            debug_assert_eq!(actual.back_capacity, less);

                                            _ = actual.reserve(capacity).expect("already enough capacity");

                                            assert_eq!(actual.front_capacity, 0);
                                        }
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_increases_back_capacity_to_sum_with_front_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for more in capacity..(capacity + 32) {
                                        for less in 1..capacity {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(more).expect("successful allocation");
                                            _ = actual.reserve_back(less).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, more);
                                            debug_assert_eq!(actual.back_capacity, less);

                                            _ = actual.reserve(capacity).expect("already enough capacity");

                                            assert_eq!(actual.back_capacity, more + less);
                                        }
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_initialized_elements() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for more in capacity..(capacity + 32) {
                                        for less in 1..capacity {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(more).expect("successful allocation");
                                            _ = actual.reserve_back(less).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, more);
                                            debug_assert_eq!(actual.back_capacity, less);

                                            _ = actual.reserve(capacity).expect("already enough capacity");

                                            assert!(actual.eq(expected));
                                        }
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_reallocate_memory() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for more in capacity..(capacity + 32) {
                                        for less in 1..capacity {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(more).expect("successful allocation");
                                            _ = actual.reserve_back(less).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, more);
                                            debug_assert_eq!(actual.back_capacity, less);

                                            let allocation = actual.buffer;

                                            _ = actual.reserve(capacity).expect("already enough capacity");

                                            assert_eq!(actual.buffer, allocation);
                                        }
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_capacity_many_elements_can_be_appended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for more in capacity..(capacity + 32) {
                                        for less in 1..capacity {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(more).expect("successful allocation");
                                            _ = actual.reserve_back(less).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, more);
                                            debug_assert_eq!(actual.back_capacity, less);

                                            _ = actual.reserve(capacity).expect("already enough capacity");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..(less + more) {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.append(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                mod when_front_is_less_than_requested_and_back_is_more_than_requested {
                    use super::*;

                    mod when_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_capacity() {
                            for capacity in 1..32 {
                                for more in capacity..(capacity + 32) {
                                    for less in 1..capacity {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(less + more).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(less).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, less);
                                        debug_assert_eq!(actual.back_capacity, more);

                                        _ = actual.reserve(capacity).expect("already enough capacity");

                                        assert_eq!(actual.capacity(), less + more);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_initialize_elements() {
                            for capacity in 1..32 {
                                for more in capacity..(capacity + 32) {
                                    for less in 1..capacity {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(less + more).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(less).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, less);
                                        debug_assert_eq!(actual.back_capacity, more);

                                        _ = actual.reserve(capacity).expect("already enough capacity");

                                        assert_eq!(actual.initialized, 0);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_reallocate_memory() {
                            for capacity in 1..32 {
                                for more in capacity..(capacity + 32) {
                                    for less in 1..capacity {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(less + more).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(less).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, less);
                                        debug_assert_eq!(actual.back_capacity, more);

                                        let allocation = actual.buffer;

                                        _ = actual.reserve(capacity).expect("already enough capacity");

                                        assert_eq!(actual.buffer, allocation);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_capacity_many_elements_can_be_appended_without_reallocating_memory() {
                            for capacity in 1..32 {
                                for more in capacity..(capacity + 32) {
                                    for less in 1..capacity {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(less + more).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(less).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, less);
                                        debug_assert_eq!(actual.back_capacity, more);

                                        _ = actual.reserve(capacity).expect("already enough capacity");

                                        let allocation = actual.buffer;

                                        for element in 0..(less + more) {
                                            _ = actual.append(element).expect("uses capacity");
                                        }

                                        assert_eq!(actual.buffer, allocation);
                                    }
                                }
                            }
                        }
                    }

                    mod when_not_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_front_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for more in capacity..(capacity + 32) {
                                        for less in 1..capacity {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(less).expect("successful allocation");
                                            _ = actual.reserve_back(more).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, less);
                                            debug_assert_eq!(actual.back_capacity, more);

                                            _ = actual.reserve(capacity).expect("already enough capacity");

                                            assert_eq!(actual.front_capacity, less);
                                        }
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_back_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for more in capacity..(capacity + 32) {
                                        for less in 1..capacity {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(less).expect("successful allocation");
                                            _ = actual.reserve_back(more).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, less);
                                            debug_assert_eq!(actual.back_capacity, more);

                                            _ = actual.reserve(capacity).expect("already enough capacity");

                                            assert_eq!(actual.back_capacity, more);
                                        }
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_initialized_elements() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for more in capacity..(capacity + 32) {
                                        for less in 1..capacity {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(less).expect("successful allocation");
                                            _ = actual.reserve_back(more).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, less);
                                            debug_assert_eq!(actual.back_capacity, more);

                                            _ = actual.reserve(capacity).expect("already enough capacity");

                                            assert!(actual.eq(expected));
                                        }
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_reallocate_memory() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for more in capacity..(capacity + 32) {
                                        for less in 1..capacity {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(less).expect("successful allocation");
                                            _ = actual.reserve_back(more).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, less);
                                            debug_assert_eq!(actual.back_capacity, more);

                                            let allocation = actual.buffer;

                                            _ = actual.reserve(capacity).expect("already enough capacity");

                                            assert_eq!(actual.buffer, allocation);
                                        }
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_front_many_elements_can_be_prepended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for more in capacity..(capacity + 32) {
                                        for less in 1..capacity {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(less).expect("successful allocation");
                                            _ = actual.reserve_back(more).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, less);
                                            debug_assert_eq!(actual.back_capacity, more);

                                            _ = actual.reserve(capacity).expect("already enough capacity");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..less {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.prepend(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_back_many_elements_can_be_appended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for more in capacity..(capacity + 32) {
                                        for less in 1..capacity {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(less).expect("successful allocation");
                                            _ = actual.reserve_back(more).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, less);
                                            debug_assert_eq!(actual.back_capacity, more);

                                            _ = actual.reserve(capacity).expect("already enough capacity");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..more {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.append(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_both_front_many_elements_can_be_prepended_and_back_many_elements_can_be_appended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for more in capacity..(capacity + 32) {
                                        for less in 1..capacity {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(less).expect("successful allocation");
                                            _ = actual.reserve_back(more).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, less);
                                            debug_assert_eq!(actual.back_capacity, more);

                                            _ = actual.reserve(capacity).expect("already enough capacity");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..less {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.prepend(usize::MAX).expect("uses capacity");
                                            }

                                            for _ in 0..more {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.append(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                mod when_both_more_than_requested {
                    use super::*;

                    mod when_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_capacity() {
                            for capacity in 1..32 {
                                for additional_front in 1..32 {
                                    for additional_back in 1..32 {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(capacity + additional_front + capacity + additional_back).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(capacity + additional_front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, capacity + additional_front);
                                        debug_assert_eq!(actual.back_capacity, capacity + additional_back);

                                        _ = actual.reserve(capacity).expect("already enough capacity");

                                        assert_eq!(actual.capacity(), capacity + additional_front + capacity + additional_back);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_initialize_elements() {
                            for capacity in 1..32 {
                                for additional_front in 1..32 {
                                    for additional_back in 1..32 {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(capacity + additional_front + capacity + additional_back).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(capacity + additional_front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, capacity + additional_front);
                                        debug_assert_eq!(actual.back_capacity, capacity + additional_back);

                                        _ = actual.reserve(capacity).expect("already enough capacity");

                                        assert_eq!(actual.initialized, 0);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_reallocate_memory() {
                            for capacity in 1..32 {
                                for additional_front in 1..32 {
                                    for additional_back in 1..32 {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(capacity + additional_front + capacity + additional_back).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(capacity + additional_front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, capacity + additional_front);
                                        debug_assert_eq!(actual.back_capacity, capacity + additional_back);

                                        let allocation = actual.buffer;

                                        _ = actual.reserve(capacity).expect("already enough capacity");

                                        assert_eq!(actual.buffer, allocation);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_capacity_many_elements_can_be_appended_without_reallocating_memory() {
                            for capacity in 1..32 {
                                for additional_front in 1..32 {
                                    for additional_back in 1..32 {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(capacity + additional_front + capacity + additional_back).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(capacity + additional_front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, capacity + additional_front);
                                        debug_assert_eq!(actual.back_capacity, capacity + additional_back);

                                        _ = actual.reserve(capacity).expect("already enough capacity");

                                        let allocation = actual.buffer;

                                        for element in 0..(capacity + additional_front + capacity + additional_back) {
                                            _ = actual.append(element).expect("uses capacity");
                                        }

                                        assert_eq!(actual.buffer, allocation);
                                    }
                                }
                            }
                        }
                    }

                    mod when_not_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_front_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional_front in 1..32 {
                                        for additional_back in 1..32 {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(capacity + additional_front).expect("successful allocation");
                                            _ = actual.reserve_back(capacity + additional_back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, capacity + additional_front);
                                            debug_assert_eq!(actual.back_capacity, capacity + additional_back);

                                            _ = actual.reserve(capacity).expect("already enough capacity");

                                            assert_eq!(actual.front_capacity, capacity + additional_front);
                                        }
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_back_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional_front in 1..32 {
                                        for additional_back in 1..32 {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(capacity + additional_front).expect("successful allocation");
                                            _ = actual.reserve_back(capacity + additional_back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, capacity + additional_front);
                                            debug_assert_eq!(actual.back_capacity, capacity + additional_back);

                                            _ = actual.reserve(capacity).expect("already enough capacity");

                                            assert_eq!(actual.back_capacity, capacity + additional_back);
                                        }
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_initialized_elements() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional_front in 1..32 {
                                        for additional_back in 1..32 {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(capacity + additional_front).expect("successful allocation");
                                            _ = actual.reserve_back(capacity + additional_back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, capacity + additional_front);
                                            debug_assert_eq!(actual.back_capacity, capacity + additional_back);

                                            _ = actual.reserve(capacity).expect("already enough capacity");

                                            assert!(actual.eq(expected));
                                        }
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_reallocate_memory() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional_front in 1..32 {
                                        for additional_back in 1..32 {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(capacity + additional_front).expect("successful allocation");
                                            _ = actual.reserve_back(capacity + additional_back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, capacity + additional_front);
                                            debug_assert_eq!(actual.back_capacity, capacity + additional_back);

                                            let allocation = actual.buffer;

                                            _ = actual.reserve(capacity).expect("already enough capacity");

                                            assert_eq!(actual.buffer, allocation);
                                        }
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_front_many_elements_can_be_prepended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional_front in 1..32 {
                                        for additional_back in 1..32 {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(capacity + additional_front).expect("successful allocation");
                                            _ = actual.reserve_back(capacity + additional_back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, capacity + additional_front);
                                            debug_assert_eq!(actual.back_capacity, capacity + additional_back);

                                            _ = actual.reserve(capacity).expect("already enough capacity");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..(capacity + additional_front) {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.prepend(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_back_many_elements_can_be_appended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional_front in 1..32 {
                                        for additional_back in 1..32 {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(capacity + additional_front).expect("successful allocation");
                                            _ = actual.reserve_back(capacity + additional_back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, capacity + additional_front);
                                            debug_assert_eq!(actual.back_capacity, capacity + additional_back);

                                            _ = actual.reserve(capacity).expect("already enough capacity");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..(capacity + additional_back) {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.append(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_both_front_many_elements_can_be_prepended_and_back_many_elements_can_be_appended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional_front in 1..32 {
                                        for additional_back in 1..32 {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(capacity + additional_front).expect("successful allocation");
                                            _ = actual.reserve_back(capacity + additional_back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, capacity + additional_front);
                                            debug_assert_eq!(actual.back_capacity, capacity + additional_back);

                                            _ = actual.reserve(capacity).expect("already enough capacity");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..(capacity + additional_front) {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.prepend(usize::MAX).expect("uses capacity");
                                            }

                                            for _ in 0..(capacity + additional_back) {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.append(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        mod reserve_front {
            use super::*;

            mod when_no_capacity {
                use super::*;

                mod when_zero_requested {
                    use super::*;

                    mod when_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_capacity() {
                            let mut actual = Dynamic::<usize>::default();

                            debug_assert_eq!(actual.initialized, 0);
                            debug_assert_eq!(actual.front_capacity, 0);
                            debug_assert_eq!(actual.back_capacity, 0);

                            _ = actual.reserve_front(0).expect("does no allocation");

                            assert_eq!(actual.capacity(), 0);
                        }

                        #[test]
                        fn then_does_not_initialize_elements() {
                            let mut actual = Dynamic::<usize>::default();

                            debug_assert_eq!(actual.initialized, 0);
                            debug_assert_eq!(actual.front_capacity, 0);
                            debug_assert_eq!(actual.back_capacity, 0);

                            _ = actual.reserve_front(0).expect("does no allocation");

                            assert_eq!(actual.initialized, 0);
                        }
                    }

                    mod when_not_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_front_capacity() {
                            for elements in 1..32 {
                                let mut actual: Dynamic<_> = (0..elements).collect();

                                debug_assert_eq!(actual.initialized, elements);
                                debug_assert_eq!(actual.front_capacity, 0);
                                debug_assert_eq!(actual.back_capacity, 0);

                                _ = actual.reserve_front(0).expect("already enough capacity");

                                assert_eq!(actual.front_capacity, 0);
                            }
                        }

                        #[test]
                        fn then_does_not_modify_back_capacity() {
                            for elements in 1..32 {
                                let mut actual: Dynamic<_> = (0..elements).collect();

                                debug_assert_eq!(actual.initialized, elements);
                                debug_assert_eq!(actual.front_capacity, 0);
                                debug_assert_eq!(actual.back_capacity, 0);

                                _ = actual.reserve_front(0).expect("already enough capacity");

                                assert_eq!(actual.back_capacity, 0);
                            }
                        }

                        #[test]
                        fn then_does_not_modify_initialized_elements() {
                            for elements in 1..32 {
                                let expected = 0..elements;

                                let mut actual: Dynamic<_> = expected.clone().collect();

                                debug_assert_eq!(actual.initialized, elements);
                                debug_assert_eq!(actual.front_capacity, 0);
                                debug_assert_eq!(actual.back_capacity, 0);

                                _ = actual.reserve_front(0).expect("already enough capacity");

                                assert!(actual.eq(expected));
                            }
                        }
                    }
                }

                mod when_more_than_zero_requested {
                    use super::*;

                    mod when_empty {
                        use super::*;

                        #[test]
                        fn when_zero_size_type_then_can_allocate_maximum_possible_amount() {
                            let mut actual = Dynamic::<()>::default();

                            debug_assert_eq!(actual.initialized, 0);
                            debug_assert_eq!(actual.front_capacity, 0);
                            debug_assert_eq!(actual.back_capacity, 0);

                            _ = actual.reserve_front(isize::MAX as usize).expect("ZSTs do not occupy memory");

                            assert_eq!(actual.capacity(), isize::MAX as usize);
                        }

                        #[test]
                        fn then_increases_capacity_to_exactly_requested() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, 0);
                                debug_assert_eq!(actual.back_capacity, 0);

                                _ = actual.reserve_front(capacity).expect("successful allocation");

                                assert_eq!(actual.capacity(), capacity);
                            }
                        }

                        #[test]
                        fn then_does_not_initialize_elements() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, 0);
                                debug_assert_eq!(actual.back_capacity, 0);

                                _ = actual.reserve_front(capacity).expect("successful allocation");

                                assert_eq!(actual.initialized, 0);
                            }
                        }

                        #[test]
                        fn that_many_elements_can_be_prepended_without_reallocation() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, 0);
                                debug_assert_eq!(actual.back_capacity, 0);

                                _ = actual.reserve_front(capacity).expect("successful allocation");

                                let allocation = actual.buffer;

                                for element in 0..capacity {
                                    _ = actual.prepend(element).expect("uses capacity");
                                }

                                assert_eq!(actual.buffer, allocation);
                            }
                        }
                    }

                    mod when_not_empty {
                        use super::*;

                        #[test]
                        fn when_zero_size_type_then_can_allocate_maximum_possible_amount() {
                            for elements in 1..32 {
                                let mut actual: Dynamic<_> = core::iter::repeat_n((), elements).collect();

                                debug_assert_eq!(actual.initialized, elements);
                                debug_assert_eq!(actual.front_capacity, 0);
                                debug_assert_eq!(actual.back_capacity, 0);

                                _ = actual.reserve_front(isize::MAX as usize - elements).expect("ZSTs do not occupy memory");

                                assert_eq!(actual.front_capacity, isize::MAX as usize - elements);
                            }
                        }

                        #[test]
                        fn then_increases_front_capacity_to_exactly_requested() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let mut actual: Dynamic<_> = (0..elements).collect();

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.reserve_front(capacity).expect("successful allocation");

                                    assert_eq!(actual.front_capacity, capacity);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_back_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let mut actual: Dynamic<_> = (0..elements).collect();

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.reserve_front(capacity).expect("successful allocation");

                                    assert_eq!(actual.back_capacity, 0);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_initialized_elements() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let expected = 0..elements;

                                    let mut actual: Dynamic<_> = expected.clone().collect();

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.reserve_front(capacity).expect("successful allocation");

                                    assert!(actual.eq(expected));
                                }
                            }
                        }

                        #[test]
                        fn then_requested_many_elements_can_be_prepended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let expected = 0..elements;

                                    let mut actual: Dynamic<_> = expected.clone().collect();

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.reserve_front(capacity).expect("successful allocation");

                                    let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                    for _ in 0..capacity {
                                        // NOTE: this is distinct from the expected values.
                                        _ = actual.prepend(usize::MAX).expect("uses capacity");
                                    }

                                    assert!(pointers.iter().copied().eq(expected));
                                }
                            }
                        }
                    }
                }
            }

            mod when_only_front_capacity {
                use super::*;

                mod when_zero_requested {
                    use super::*;

                    mod when_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_capacity() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_front(capacity).expect("successful allocation");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, capacity);
                                debug_assert_eq!(actual.back_capacity, 0);

                                _ = actual.reserve_front(0).expect("already enough capacity");

                                assert_eq!(actual.capacity(), capacity);
                            }
                        }

                        #[test]
                        fn then_does_not_initialize_elements() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_front(capacity).expect("successful allocation");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, capacity);
                                debug_assert_eq!(actual.back_capacity, 0);

                                _ = actual.reserve_front(0).expect("already enough capacity");

                                assert_eq!(actual.initialized, 0);
                            }
                        }

                        #[test]
                        fn then_does_not_reallocate_memory() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_front(capacity).expect("successful allocation");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, capacity);
                                debug_assert_eq!(actual.back_capacity, 0);

                                let allocation = actual.buffer;

                                _ = actual.reserve_front(0).expect("already enough capacity");

                                assert_eq!(actual.buffer, allocation);
                            }
                        }

                        #[test]
                        fn then_capacity_many_elements_can_be_prepended_without_reallocating_memory() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_front(capacity).expect("successful allocation");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, capacity);
                                debug_assert_eq!(actual.back_capacity, 0);

                                _ = actual.reserve_front(0).expect("already enough capacity");

                                let allocation = actual.buffer;

                                for element in 0..capacity {
                                    _ = actual.prepend(element).expect("uses capacity");
                                }

                                assert_eq!(actual.buffer, allocation);
                            }
                        }
                    }

                    mod when_not_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_front_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let mut actual: Dynamic<_> = (0..elements).collect();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.reserve_front(0).expect("already enough capacity");

                                    assert_eq!(actual.front_capacity, capacity);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_back_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let mut actual: Dynamic<_> = (0..elements).collect();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.reserve_front(0).expect("already enough capacity");

                                    assert_eq!(actual.back_capacity, 0);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_initialized_elements() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let expected = 0..elements;

                                    let mut actual: Dynamic<_> = expected.clone().collect();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.reserve_front(0).expect("already enough capacity");

                                    assert!(actual.eq(expected));
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_reallocate_memory() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let mut actual: Dynamic<_> = (0..elements).collect();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    let allocation = actual.buffer;

                                    _ = actual.reserve_front(0).expect("already enough capacity");

                                    assert_eq!(actual.buffer, allocation);
                                }
                            }
                        }

                        #[test]
                        fn then_capacity_many_elements_can_be_prepended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let expected = 0..elements;

                                    let mut actual: Dynamic<_> = expected.clone().collect();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.reserve_front(0).expect("already enough capacity");

                                    let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                    for _ in 0..capacity {
                                        // NOTE: this is distinct from the expected values.
                                        _ = actual.prepend(usize::MAX).expect("uses capacity");
                                    }

                                    assert!(pointers.iter().copied().eq(expected));
                                }
                            }
                        }
                    }
                }

                mod when_less_than_requested {
                    use super::*;

                    mod when_empty {
                        use super::*;

                        #[test]
                        fn when_zero_size_type_then_can_allocate_maximum_possible_amount() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<()>::default();

                                _ = actual.reserve_front(capacity).expect("successful allocation");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, capacity);
                                debug_assert_eq!(actual.back_capacity, 0);

                                _ = actual.reserve_front(isize::MAX as usize).expect("ZSTs do not occupy memory");

                                assert_eq!(actual.capacity(), isize::MAX as usize);
                            }
                        }

                        #[test]
                        fn then_increases_capacity_to_exactly_requested() {
                            for capacity in 1..32 {
                                for additional in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.reserve_front(capacity + additional).expect("successful allocation");

                                    assert_eq!(actual.capacity(), capacity + additional);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_initialize_elements() {
                            for capacity in 1..32 {
                                for additional in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.reserve_front(capacity + additional).expect("successful allocation");

                                    assert_eq!(actual.initialized, 0);
                                }
                            }
                        }

                        #[test]
                        fn then_requested_many_elements_can_be_prepended_without_reallocating_memory() {
                            for capacity in 1..32 {
                                for additional in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.reserve_front(capacity + additional).expect("successful allocation");

                                    let allocation = actual.buffer;

                                    for element in 0..(capacity + additional) {
                                        _ = actual.prepend(element).expect("uses capacity");
                                    }

                                    assert_eq!(actual.buffer, allocation);
                                }
                            }
                        }
                    }

                    mod when_not_empty {
                        use super::*;

                        #[test]
                        fn when_zero_size_type_then_can_allocate_maximum_possible_amount() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let mut actual: Dynamic<_> = core::iter::repeat_n((), elements).collect();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.reserve_front(isize::MAX as usize - elements).expect("ZSTs do not occupy memory");

                                    assert_eq!(actual.front_capacity, isize::MAX as usize - elements);
                                }
                            }
                        }

                        #[test]
                        fn then_increases_front_capacity_to_exactly_requested() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let mut actual: Dynamic<_> = (0..elements).collect();

                                        _ = actual.reserve_front(capacity).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, capacity);
                                        debug_assert_eq!(actual.back_capacity, 0);

                                        _ = actual.reserve_front(capacity + additional).expect("successful allocation");

                                        assert_eq!(actual.front_capacity, capacity + additional);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_back_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let mut actual: Dynamic<_> = (0..elements).collect();

                                        _ = actual.reserve_front(capacity).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, capacity);
                                        debug_assert_eq!(actual.back_capacity, 0);

                                        _ = actual.reserve_front(capacity + additional).expect("successful allocation");

                                        assert_eq!(actual.back_capacity, 0);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_initialized_elements() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let expected = 0..elements;

                                        let mut actual: Dynamic<_> = expected.clone().collect();

                                        _ = actual.reserve_front(capacity).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, capacity);
                                        debug_assert_eq!(actual.back_capacity, 0);

                                        _ = actual.reserve_front(capacity + additional).expect("successful allocation");

                                        assert!(actual.eq(expected));
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_requested_many_elements_can_be_prepended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let expected = 0..elements;

                                        let mut actual: Dynamic<_> = expected.clone().collect();

                                        _ = actual.reserve_front(capacity).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, capacity);
                                        debug_assert_eq!(actual.back_capacity, 0);

                                        _ = actual.reserve_front(capacity + additional).expect("successful allocation");

                                        let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                        for _ in 0..(capacity + additional) {
                                            // NOTE: this is distinct from the expected values.
                                            _ = actual.prepend(usize::MAX).expect("uses capacity");
                                        }

                                        assert!(pointers.iter().copied().eq(expected));
                                    }
                                }
                            }
                        }
                    }
                }

                mod when_exactly_requested {
                    use super::*;

                    mod when_empty {
                        use super::*;

                        #[test]
                        fn when_zero_size_type_then_can_allocate_maximum_possible_amount() {
                            let mut actual = Dynamic::<()>::default();

                            _ = actual.reserve_front(isize::MAX as usize).expect("successful allocation");

                            debug_assert_eq!(actual.initialized, 0);
                            debug_assert_eq!(actual.front_capacity, isize::MAX as usize);
                            debug_assert_eq!(actual.back_capacity, 0);

                            _ = actual.reserve_front(isize::MAX as usize).expect("ZSTs do not occupy memory");

                            assert_eq!(actual.capacity(), isize::MAX as usize);
                        }

                        #[test]
                        fn then_does_not_modify_capacity() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_front(capacity).expect("successful allocation");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, capacity);
                                debug_assert_eq!(actual.back_capacity, 0);

                                _ = actual.reserve_front(capacity).expect("already enough capacity");

                                assert_eq!(actual.capacity(), capacity);
                            }
                        }

                        #[test]
                        fn then_does_not_initialize_elements() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_front(capacity).expect("successful allocation");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, capacity);
                                debug_assert_eq!(actual.back_capacity, 0);

                                _ = actual.reserve_front(capacity).expect("already enough capacity");

                                assert_eq!(actual.initialized, 0);
                            }
                        }

                        #[test]
                        fn then_does_not_reallocate_memory() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_front(capacity).expect("successful allocation");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, capacity);
                                debug_assert_eq!(actual.back_capacity, 0);

                                let allocation = actual.buffer;

                                _ = actual.reserve_front(capacity).expect("already enough capacity");

                                assert_eq!(actual.buffer, allocation);
                            }
                        }

                        #[test]
                        fn then_requested_many_elements_can_be_prepended_without_reallocating_memory() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_front(capacity).expect("successful allocation");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, capacity);
                                debug_assert_eq!(actual.back_capacity, 0);

                                _ = actual.reserve_front(capacity).expect("already enough capacity");

                                let allocation = actual.buffer;

                                for element in 0..capacity {
                                    _ = actual.prepend(element).expect("uses capacity");
                                }

                                assert_eq!(actual.buffer, allocation);
                            }
                        }
                    }

                    mod when_not_empty {
                        use super::*;

                        #[test]
                        fn when_zero_size_type_then_can_allocate_maximum_possible_amount() {
                            for elements in 1..32 {
                                let mut actual: Dynamic<_> = core::iter::repeat_n((), elements).collect();

                                _ = actual.reserve_front(isize::MAX as usize - elements).expect("successful allocation");

                                debug_assert_eq!(actual.initialized, elements);
                                debug_assert_eq!(actual.front_capacity, isize::MAX as usize - elements);
                                debug_assert_eq!(actual.back_capacity, 0);

                                _ = actual.reserve_front(isize::MAX as usize - elements).expect("ZSTs do not occupy memory");

                                assert_eq!(actual.capacity(), isize::MAX as usize - elements);
                            }
                        }

                        #[test]
                        fn then_does_not_modify_front_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let mut actual: Dynamic<_> = (0..elements).collect();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.reserve_front(capacity).expect("already enough capacity");

                                    assert_eq!(actual.front_capacity, capacity);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_back_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let mut actual: Dynamic<_> = (0..elements).collect();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.reserve_front(capacity).expect("already enough capacity");

                                    assert_eq!(actual.back_capacity, 0);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_initialized_elements() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let expected = 0..elements;

                                    let mut actual: Dynamic<_> = expected.clone().collect();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.reserve_front(capacity).expect("already enough capacity");

                                    assert!(actual.eq(expected));
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_reallocate_memory() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let mut actual: Dynamic<_> = (0..elements).collect();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    let allocation = actual.buffer;

                                    _ = actual.reserve_front(capacity).expect("already enough capacity");

                                    assert_eq!(actual.buffer, allocation);
                                }
                            }
                        }

                        #[test]
                        fn then_requested_many_elements_can_be_prepended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let expected = 0..elements;

                                    let mut actual: Dynamic<_> = expected.clone().collect();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.reserve_front(capacity).expect("already enough capacity");

                                    let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                    for _ in 0..capacity {
                                        // NOTE: this is distinct from the expected values.
                                        _ = actual.prepend(usize::MAX).expect("uses capacity");
                                    }

                                    assert!(pointers.iter().copied().eq(expected));
                                }
                            }
                        }
                    }
                }

                mod when_more_than_requested {
                    use super::*;

                    mod when_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_capacity() {
                            for capacity in 1..32 {
                                for additional in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_front(capacity + additional).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, capacity + additional);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.reserve_front(capacity).expect("already enough capacity");

                                    assert_eq!(actual.capacity(), capacity + additional);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_initialize_elements() {
                            for capacity in 1..32 {
                                for additional in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_front(capacity + additional).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, capacity + additional);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.reserve_front(capacity).expect("already enough capacity");

                                    assert_eq!(actual.initialized, 0);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_reallocate_memory() {
                            for capacity in 1..32 {
                                for additional in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_front(capacity + additional).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, capacity + additional);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    let allocation = actual.buffer;

                                    _ = actual.reserve_front(capacity).expect("already enough capacity");

                                    assert_eq!(actual.buffer, allocation);
                                }
                            }
                        }

                        #[test]
                        fn then_capacity_many_elements_can_be_prepended_without_reallocating_memory() {
                            for capacity in 1..32 {
                                for additional in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_front(capacity + additional).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, capacity + additional);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    let allocation = actual.buffer;

                                    _ = actual.reserve_front(capacity).expect("already enough capacity");

                                    for element in 0..(capacity + additional) {
                                        _ = actual.prepend(element).expect("uses capacity");
                                    }

                                    assert_eq!(actual.buffer, allocation);
                                }
                            }
                        }
                    }

                    mod when_not_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_front_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let mut actual: Dynamic<_> = (0..elements).collect();

                                        _ = actual.reserve_front(capacity + additional);

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, capacity + additional);
                                        debug_assert_eq!(actual.back_capacity, 0);

                                        _ = actual.reserve_front(capacity).expect("already enough capacity");

                                        assert_eq!(actual.front_capacity, capacity + additional);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_back_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let mut actual: Dynamic<_> = (0..elements).collect();

                                        _ = actual.reserve_front(capacity + additional);

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, capacity + additional);
                                        debug_assert_eq!(actual.back_capacity, 0);

                                        _ = actual.reserve_front(capacity).expect("already enough capacity");

                                        assert_eq!(actual.back_capacity, 0);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_initialized_elements() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let expected = 0..elements;

                                        let mut actual: Dynamic<_> = expected.clone().collect();

                                        _ = actual.reserve_front(capacity + additional);

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, capacity + additional);
                                        debug_assert_eq!(actual.back_capacity, 0);

                                        _ = actual.reserve_front(capacity).expect("already enough capacity");

                                        assert!(actual.eq(expected));
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_reallocate_memory() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let mut actual: Dynamic<_> = (0..elements).collect();

                                        _ = actual.reserve_front(capacity + additional).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, capacity + additional);
                                        debug_assert_eq!(actual.back_capacity, 0);

                                        let allocation = actual.buffer;

                                        _ = actual.reserve_front(capacity).expect("already enough capacity");

                                        assert_eq!(actual.buffer, allocation);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_capacity_many_elements_can_be_prepended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let expected = 0..elements;

                                        let mut actual: Dynamic<_> = expected.clone().collect();

                                        _ = actual.reserve_front(capacity + additional);

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, capacity + additional);
                                        debug_assert_eq!(actual.back_capacity, 0);

                                        _ = actual.reserve_front(capacity).expect("already enough capacity");

                                        let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                        for _ in 0..(capacity + additional) {
                                            // NOTE: this is distinct from the expected values.
                                            _ = actual.prepend(usize::MAX).expect("uses capacity");
                                        }

                                        assert!(pointers.iter().copied().eq(expected));
                                    }
                                }
                            }
                        }
                    }
                }
            }

            mod when_only_back_capacity {
                use super::*;

                mod when_zero_requested {
                    use super::*;

                    mod when_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_capacity() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_back(capacity).expect("successful allocation");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, 0);
                                debug_assert_eq!(actual.back_capacity, capacity);

                                _ = actual.reserve_front(0).expect("already enough capacity");

                                assert_eq!(actual.capacity(), capacity);
                            }
                        }

                        #[test]
                        fn then_does_not_initialize_elements() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_back(capacity).expect("successful allocation");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, 0);
                                debug_assert_eq!(actual.back_capacity, capacity);

                                _ = actual.reserve_front(0).expect("already enough capacity");

                                assert_eq!(actual.initialized, 0);
                            }
                        }

                        #[test]
                        fn then_does_not_reallocate_memory() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_back(capacity).expect("successful allocation");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, 0);
                                debug_assert_eq!(actual.back_capacity, capacity);

                                let allocation = actual.buffer;

                                _ = actual.reserve_front(0).expect("already enough capacity");

                                assert_eq!(actual.buffer, allocation);
                            }
                        }

                        #[test]
                        fn then_capacity_many_elements_can_be_appended_without_reallocating_memory() {
                            for capacity in 0..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_back(capacity).expect("successful allocation");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, 0);
                                debug_assert_eq!(actual.back_capacity, capacity);

                                _ = actual.reserve_front(0).expect("already enough capacity");

                                let allocation = actual.buffer;

                                for element in 0..capacity {
                                    _ = actual.append(element).expect("uses capacity");
                                }

                                assert_eq!(actual.buffer, allocation);
                            }
                        }
                    }

                    mod when_not_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_front_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let mut actual: Dynamic<_> = (0..elements).collect();

                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    _ = actual.reserve_front(0).expect("already enough capacity");

                                    assert_eq!(actual.front_capacity, 0);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_decrease_back_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let mut actual: Dynamic<_> = (0..elements).collect();

                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    _ = actual.reserve_front(0).expect("already enough capacity");

                                    assert_eq!(actual.back_capacity, capacity);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_initialized_elements() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let expected = 0..elements;

                                    let mut actual: Dynamic<_> = expected.clone().collect();

                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    _ = actual.reserve_front(0).expect("already enough capacity");

                                    assert!(actual.eq(expected));
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_reallocate_memory() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let mut actual: Dynamic<_> = (0..elements).collect();

                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    let allocation = actual.buffer;

                                    _ = actual.reserve_front(0).expect("already enough capacity");

                                    assert_eq!(actual.buffer, allocation);
                                }
                            }
                        }

                        #[test]
                        fn then_capacity_many_elements_can_be_appended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for capacity in 0..32 {
                                    let expected = 0..elements;

                                    let mut actual: Dynamic<_> = expected.clone().collect();

                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    _ = actual.reserve_front(0).expect("already enough capacity");

                                    let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                    for _ in 0..capacity {
                                        // NOTE: this is distinct from the expected values.
                                        _ = actual.append(usize::MAX).expect("uses capacity");
                                    }

                                    assert!(pointers.iter().copied().eq(expected));
                                }
                            }
                        }
                    }
                }

                mod when_less_than_requested {
                    use super::*;

                    mod when_empty {
                        use super::*;

                        #[test]
                        fn when_zero_size_type_then_can_allocate_maximum_possible_amount() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<()>::default();

                                _ = actual.reserve_back(capacity).expect("successful allocation");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, 0);
                                debug_assert_eq!(actual.back_capacity, capacity);

                                _ = actual.reserve_front(isize::MAX as usize).expect("ZSTs do not occupy memory");

                                assert_eq!(actual.capacity(), isize::MAX as usize);
                            }
                        }

                        #[test]
                        fn then_increases_capacity_to_exactly_requested() {
                            for capacity in 1..32 {
                                for additional in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    _ = actual.reserve_front(capacity + additional).expect("successful allocation");

                                    assert_eq!(actual.capacity(), capacity + additional);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_initialize_elements() {
                            for capacity in 1..32 {
                                for additional in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    _ = actual.reserve_front(capacity + additional).expect("successful allocation");

                                    assert_eq!(actual.initialized, 0);
                                }
                            }
                        }

                        #[test]
                        fn then_requested_many_elements_can_be_prepended_without_reallocating_memory() {
                            for capacity in 1..32 {
                                for additional in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    _ = actual.reserve_front(capacity + additional).expect("successful allocation");

                                    let allocation = actual.buffer;

                                    for element in 0..(capacity + additional) {
                                        _ = actual.prepend(element).expect("uses capacity");
                                    }

                                    assert_eq!(actual.buffer, allocation);
                                }
                            }
                        }
                    }

                    mod when_not_empty {
                        use super::*;

                        #[test]
                        fn when_zero_size_type_then_can_allocate_maximum_possible_amount() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let mut actual: Dynamic<_> = core::iter::repeat_n((), elements).collect();

                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    _ = actual.reserve_front(isize::MAX as usize - elements - capacity).expect("ZSTs do not occupy memory");

                                    assert_eq!(actual.front_capacity, isize::MAX as usize - elements - capacity);
                                }
                            }
                        }

                        #[test]
                        fn then_increases_front_capacity_to_exactly_requested() {
                            for elements in 1..32 {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        let mut actual: Dynamic<_> = (0..elements).collect();

                                        _ = actual.reserve_back(back).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, 0);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.reserve_front(front).expect("successful allocation");

                                        assert_eq!(actual.front_capacity, front);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_back_capacity() {
                            for elements in 1..32 {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        let mut actual: Dynamic<_> = (0..elements).collect();

                                        _ = actual.reserve_back(back).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, 0);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.reserve_front(front).expect("successful allocation");

                                        assert_eq!(actual.back_capacity, back);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_initialized_elements() {
                            for elements in 1..32 {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        let expected = 0..elements;

                                        let mut actual: Dynamic<_> = expected.clone().collect();

                                        _ = actual.reserve_back(back).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, 0);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.reserve_front(front).expect("already enough capacity");

                                        assert!(actual.eq(expected));
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_requested_many_elements_can_be_prepended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        let expected = 0..elements;

                                        let mut actual: Dynamic<_> = expected.clone().collect();

                                        _ = actual.reserve_back(back).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, 0);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.reserve_front(front).expect("already enough capacity");

                                        let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                        for _ in 0..front {
                                            // NOTE: this is distinct from the expected values.
                                            _ = actual.prepend(usize::MAX).expect("uses capacity");
                                        }

                                        assert!(pointers.iter().copied().eq(expected));
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_capacity_many_elements_can_be_appended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        let expected = 0..elements;

                                        let mut actual: Dynamic<_> = expected.clone().collect();

                                        _ = actual.reserve_back(back).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, 0);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.reserve_front(front).expect("already enough capacity");

                                        let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                        for _ in 0..back {
                                            // NOTE: this is distinct from the expected values.
                                            _ = actual.append(usize::MAX).expect("uses capacity");
                                        }

                                        assert!(pointers.iter().copied().eq(expected));
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_both_requested_many_elements_can_be_prepended_and_capacity_many_elements_can_be_appended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        let expected = 0..elements;

                                        let mut actual: Dynamic<_> = expected.clone().collect();

                                        _ = actual.reserve_back(back).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, 0);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.reserve_front(front).expect("already enough capacity");

                                        let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                        for _ in 0..front {
                                            // NOTE: this is distinct from the expected values.
                                            _ = actual.prepend(usize::MAX).expect("uses capacity");
                                        }

                                        for _ in 0..back {
                                            // NOTE: this is distinct from the expected values.
                                            _ = actual.append(usize::MAX).expect("uses capacity");
                                        }

                                        assert!(pointers.iter().copied().eq(expected));
                                    }
                                }
                            }
                        }
                    }
                }

                mod when_exactly_requested {
                    use super::*;

                    mod when_empty {
                        use super::*;

                        #[test]
                        fn when_zero_size_type_then_can_allocate_maximum_possible_amount() {
                            let mut actual = Dynamic::<()>::default();

                            _ = actual.reserve_back(isize::MAX as usize).expect("successful allocation");

                            debug_assert_eq!(actual.initialized, 0);
                            debug_assert_eq!(actual.front_capacity, 0);
                            debug_assert_eq!(actual.back_capacity, isize::MAX as usize);

                            _ = actual.reserve_front(isize::MAX as usize).expect("ZSTs do not occupy memory");

                            assert_eq!(actual.capacity(), isize::MAX as usize);
                        }

                        #[test]
                        fn then_does_not_modify_capacity() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_back(capacity).expect("successful allocation");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, 0);
                                debug_assert_eq!(actual.back_capacity, capacity);

                                _ = actual.reserve_front(capacity).expect("already enough capacity");

                                assert_eq!(actual.capacity(), capacity);
                            }
                        }

                        #[test]
                        fn then_does_not_initialize_elements() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_back(capacity).expect("successful allocation");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, 0);
                                debug_assert_eq!(actual.back_capacity, capacity);

                                _ = actual.reserve_front(capacity).expect("already enough capacity");

                                assert_eq!(actual.initialized, 0);
                            }
                        }

                        #[test]
                        fn then_does_not_reallocate_memory() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_back(capacity).expect("successful allocation");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, 0);
                                debug_assert_eq!(actual.back_capacity, capacity);

                                let allocation = actual.buffer;

                                _ = actual.reserve_front(capacity).expect("already enough capacity");

                                assert_eq!(actual.buffer, allocation);
                            }
                        }

                        #[test]
                        fn then_requested_many_elements_can_be_prepended_without_reallocating_memory() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_back(capacity).expect("successful allocation");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, 0);
                                debug_assert_eq!(actual.back_capacity, capacity);

                                _ = actual.reserve_front(capacity).expect("already enough capacity");

                                let allocation = actual.buffer;

                                for element in 0..capacity {
                                    _ = actual.prepend(element).expect("uses capacity");
                                }

                                assert_eq!(actual.buffer, allocation);
                            }
                        }
                    }

                    mod when_not_empty {
                        use super::*;

                        #[test]
                        fn then_increases_front_capacity_to_exactly_requested() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let mut actual: Dynamic<_> = (0..elements).collect();

                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    _ = actual.reserve_front(capacity).expect("successful allocation");

                                    assert_eq!(actual.front_capacity, capacity);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_back_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let mut actual: Dynamic<_> = (0..elements).collect();

                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    _ = actual.reserve_front(capacity).expect("successful allocation");

                                    assert_eq!(actual.back_capacity, capacity);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_initialized_elements() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let expected = 0..elements;

                                    let mut actual: Dynamic<_> = expected.clone().collect();

                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    _ = actual.reserve_front(capacity).expect("successful allocation");

                                    assert!(actual.eq(expected));
                                }
                            }
                        }

                        #[test]
                        fn then_requested_many_elements_can_be_prepended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let expected = 0..elements;

                                    let mut actual: Dynamic<_> = expected.clone().collect();

                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    _ = actual.reserve_front(capacity).expect("successful allocation");

                                    let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                    for _ in 0..capacity {
                                        // NOTE: this is distinct from the expected values.
                                        _ = actual.prepend(usize::MAX).expect("uses capacity");
                                    }

                                    assert!(pointers.iter().copied().eq(expected));
                                }
                            }
                        }

                        #[test]
                        fn then_capacity_many_elements_can_be_appended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let expected = 0..elements;

                                    let mut actual: Dynamic<_> = expected.clone().collect();

                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    _ = actual.reserve_front(capacity).expect("successful allocation");

                                    let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                    for _ in 0..capacity {
                                        // NOTE: this is distinct from the expected values.
                                        _ = actual.append(usize::MAX).expect("uses capacity");
                                    }

                                    assert!(pointers.iter().copied().eq(expected));
                                }
                            }
                        }

                        #[test]
                        fn then_both_requested_many_elements_can_be_prepended_and_capacity_many_elements_can_be_appended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let expected = 0..elements;

                                    let mut actual: Dynamic<_> = expected.clone().collect();

                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    _ = actual.reserve_front(capacity).expect("successful allocation");

                                    let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                    for _ in 0..capacity {
                                        // NOTE: this is distinct from the expected values.
                                        _ = actual.prepend(usize::MAX).expect("uses capacity");
                                    }

                                    for _ in 0..capacity {
                                        // NOTE: this is distinct from the expected values.
                                        _ = actual.append(usize::MAX).expect("uses capacity");
                                    }

                                    assert!(pointers.iter().copied().eq(expected));
                                }
                            }
                        }
                    }
                }

                mod when_more_than_requested {
                    use super::*;

                    mod when_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_capacity() {
                            for capacity in 1..32 {
                                for additional in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_back(capacity + additional).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, capacity + additional);

                                    _ = actual.reserve_front(capacity).expect("already enough capacity");

                                    assert_eq!(actual.capacity(), capacity + additional);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_initialize_elements() {
                            for capacity in 1..32 {
                                for additional in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_back(capacity + additional).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, capacity + additional);

                                    _ = actual.reserve_front(capacity).expect("already enough capacity");

                                    assert_eq!(actual.initialized, 0);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_reallocate_memory() {
                            for capacity in 1..32 {
                                for additional in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_back(capacity + additional).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, capacity + additional);

                                    let allocation = actual.buffer;

                                    _ = actual.reserve_front(capacity).expect("already enough capacity");

                                    assert_eq!(actual.buffer, allocation);
                                }
                            }
                        }

                        #[test]
                        fn then_capacity_many_elements_can_be_appended_without_reallocating_memory() {
                            for capacity in 1..32 {
                                for additional in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_back(capacity + additional).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, capacity + additional);

                                    _ = actual.reserve_front(capacity).expect("already enough capacity");

                                    let allocation = actual.buffer;

                                    for element in 0..(capacity + additional) {
                                        _ = actual.append(element).expect("uses capacity");
                                    }

                                    assert_eq!(actual.buffer, allocation);
                                }
                            }
                        }
                    }

                    mod when_not_empty {
                        use super::*;

                        #[test]
                        fn then_increases_front_capacity_to_requested() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let mut actual: Dynamic<_> = (0..elements).collect();

                                        _ = actual.reserve_back(capacity + additional).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, 0);
                                        debug_assert_eq!(actual.back_capacity, capacity + additional);

                                        _ = actual.reserve_front(capacity).expect("successful allocation");

                                        assert_eq!(actual.front_capacity, capacity);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_decrease_back_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let mut actual: Dynamic<_> = (0..elements).collect();

                                        _ = actual.reserve_back(capacity + additional).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, 0);
                                        debug_assert_eq!(actual.back_capacity, capacity + additional);

                                        _ = actual.reserve_front(capacity).expect("successful allocation");

                                        assert_eq!(actual.back_capacity, capacity + additional);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_initialized_elements() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let expected = 0..elements;

                                        let mut actual: Dynamic<_> = expected.clone().collect();

                                        _ = actual.reserve_back(capacity + additional).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, 0);
                                        debug_assert_eq!(actual.back_capacity, capacity + additional);

                                        _ = actual.reserve_front(capacity).expect("successful allocation");

                                        assert!(actual.eq(expected));
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_requested_many_elements_can_be_prepended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let expected = 0..elements;

                                        let mut actual: Dynamic<_> = expected.clone().collect();

                                        _ = actual.reserve_back(capacity + additional).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, 0);
                                        debug_assert_eq!(actual.back_capacity, capacity + additional);

                                        _ = actual.reserve_front(capacity).expect("successful allocation");

                                        let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                        for _ in 0..capacity {
                                            // NOTE: this is distinct from the expected values.
                                            _ = actual.prepend(usize::MAX).expect("uses capacity");
                                        }

                                        assert!(pointers.iter().copied().eq(expected));
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_capacity_many_elements_can_be_appended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let expected = 0..elements;

                                        let mut actual: Dynamic<_> = expected.clone().collect();

                                        _ = actual.reserve_back(capacity + additional).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, 0);
                                        debug_assert_eq!(actual.back_capacity, capacity + additional);

                                        _ = actual.reserve_front(capacity).expect("successful allocation");

                                        let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                        for _ in 0..(capacity + additional) {
                                            // NOTE: this is distinct from the expected values.
                                            _ = actual.append(usize::MAX).expect("uses capacity");
                                        }

                                        assert!(pointers.iter().copied().eq(expected));
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_both_requested_many_elements_can_be_prepended_and_capacity_many_element_can_be_appended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let expected = 0..elements;

                                        let mut actual: Dynamic<_> = expected.clone().collect();

                                        _ = actual.reserve_back(capacity + additional).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, 0);
                                        debug_assert_eq!(actual.back_capacity, capacity + additional);

                                        _ = actual.reserve_front(capacity).expect("successful allocation");

                                        let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                        for _ in 0..capacity {
                                            // NOTE: this is distinct from the expected values.
                                            _ = actual.prepend(usize::MAX).expect("uses capacity");
                                        }

                                        for _ in 0..(capacity + additional) {
                                            // NOTE: this is distinct from the expected values.
                                            _ = actual.append(usize::MAX).expect("uses capacity");
                                        }

                                        assert!(pointers.iter().copied().eq(expected));
                                    }
                                }
                            }
                        }
                    }
                }
            }

            mod when_both_front_and_back_capacity {
                use super::*;

                mod when_zero_requested {
                    use super::*;

                    mod when_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_capacity() {
                            for front in 1..32 {
                                for back in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_back(front + back).expect("successful allocation");

                                    _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, front);
                                    debug_assert_eq!(actual.back_capacity, back);

                                    _ = actual.reserve_front(0).expect("already enough capacity");

                                    assert_eq!(actual.capacity(), front + back);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_initialize_elements() {
                            for front in 1..32 {
                                for back in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_back(front + back).expect("successful allocation");

                                    _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, front);
                                    debug_assert_eq!(actual.back_capacity, back);

                                    _ = actual.reserve_front(0).expect("already enough capacity");

                                    assert_eq!(actual.initialized, 0);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_reallocate_memory() {
                            for front in 1..32 {
                                for back in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_back(front + back).expect("successful allocation");

                                    _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, front);
                                    debug_assert_eq!(actual.back_capacity, back);

                                    let allocation = actual.buffer;

                                    _ = actual.reserve_front(0).expect("already enough capacity");

                                    assert_eq!(actual.buffer, allocation);
                                }
                            }
                        }

                        #[test]
                        fn then_capacity_many_elements_can_be_prepended_without_reallocating_memory() {
                            for front in 1..32 {
                                for back in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_back(front + back).expect("successful allocation");

                                    _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, front);
                                    debug_assert_eq!(actual.back_capacity, back);

                                    _ = actual.reserve_front(0).expect("already enough capacity");

                                    let allocation = actual.buffer;

                                    for element in 0..(front + back) {
                                        _ = actual.prepend(element).expect("uses capacity");
                                    }

                                    assert_eq!(actual.buffer, allocation);
                                }
                            }
                        }
                    }

                    mod when_not_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_front_capacity() {
                            for elements in 1..32 {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        let mut actual: Dynamic<_> = (0..elements).collect();

                                        _ = actual.reserve_front(front).expect("successful allocation");
                                        _ = actual.reserve_back(back).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.reserve_front(0).expect("already enough capacity");

                                        assert_eq!(actual.front_capacity, front);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_back_capacity() {
                            for elements in 1..32 {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        let mut actual: Dynamic<_> = (0..elements).collect();

                                        _ = actual.reserve_front(front).expect("successful allocation");
                                        _ = actual.reserve_back(back).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.reserve_front(0).expect("already enough capacity");

                                        assert_eq!(actual.back_capacity, back);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_initialized_elements() {
                            for elements in 1..32 {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        let expected = 0..elements;

                                        let mut actual: Dynamic<_> = expected.clone().collect();

                                        _ = actual.reserve_front(front).expect("successful allocation");
                                        _ = actual.reserve_back(back).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.reserve_front(0).expect("already enough capacity");

                                        assert!(actual.eq(expected));
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_reallocate_memory() {
                            for elements in 1..32 {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        let mut actual: Dynamic<_> = (0..elements).collect();

                                        _ = actual.reserve_front(front).expect("successful allocation");
                                        _ = actual.reserve_back(back).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        let allocation = actual.buffer;

                                        _ = actual.reserve_front(0).expect("already enough capacity");

                                        assert_eq!(actual.buffer, allocation);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_front_many_elements_can_be_prepended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        let expected = 0..elements;

                                        let mut actual: Dynamic<_> = expected.clone().collect();

                                        _ = actual.reserve_front(front).expect("successful allocation");
                                        _ = actual.reserve_back(back).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.reserve_front(0).expect("already enough capacity");

                                        let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                        for _ in 0..front {
                                            // NOTE: this is distinct from the expected values.
                                            _ = actual.prepend(usize::MAX).expect("uses capacity");
                                        }

                                        assert!(pointers.iter().copied().eq(expected));
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_back_many_elements_can_be_appended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        let expected = 0..elements;

                                        let mut actual: Dynamic<_> = expected.clone().collect();

                                        _ = actual.reserve_front(front).expect("successful allocation");
                                        _ = actual.reserve_back(back).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.reserve_front(0).expect("already enough capacity");

                                        let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                        for _ in 0..back {
                                            // NOTE: this is distinct from the expected values.
                                            _ = actual.append(usize::MAX).expect("uses capacity");
                                        }

                                        assert!(pointers.iter().copied().eq(expected));
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_both_front_many_elements_can_be_prepended_and_back_many_elements_can_be_appended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        let expected = 0..elements;

                                        let mut actual: Dynamic<_> = expected.clone().collect();

                                        _ = actual.reserve_front(front).expect("successful allocation");
                                        _ = actual.reserve_back(back).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.reserve_front(0).expect("already enough capacity");

                                        let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                        for _ in 0..front {
                                            // NOTE: this is distinct from the expected values.
                                            _ = actual.prepend(usize::MAX).expect("uses capacity");
                                        }

                                        for _ in 0..back {
                                            // NOTE: this is distinct from the expected values.
                                            _ = actual.append(usize::MAX).expect("uses capacity");
                                        }

                                        assert!(pointers.iter().copied().eq(expected));
                                    }
                                }
                            }
                        }
                    }
                }

                mod when_both_less_than_requested {
                    use super::*;

                    mod when_sum_is_less_than_requested {
                        use super::*;

                        mod when_empty {
                            use super::*;

                            #[test]
                            fn when_zero_size_type_then_can_allocate_maximum_possible_amount() {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        let mut actual = Dynamic::<()>::default();

                                        _ = actual.reserve_back(front + back).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.reserve_front(isize::MAX as usize).expect("ZSTs do not occupy memory");

                                        assert_eq!(actual.capacity(), isize::MAX as usize);
                                    }
                                }
                            }

                            #[test]
                            fn then_increases_capacity_to_exactly_requested() {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        for additional in 1..32 {
                                            let mut actual = Dynamic::<usize>::default();

                                            _ = actual.reserve_back(front + back).expect("successful allocation");

                                            _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                            debug_assert_eq!(actual.initialized, 0);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.reserve_front(front + back + additional).expect("successful allocation");

                                            assert_eq!(actual.capacity(), front + back + additional);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_initialize_elements() {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        for additional in 1..32 {
                                            let mut actual = Dynamic::<usize>::default();

                                            _ = actual.reserve_back(front + back).expect("successful allocation");

                                            _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                            debug_assert_eq!(actual.initialized, 0);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.reserve_front(front + back + additional).expect("successful allocation");

                                            assert_eq!(actual.initialized, 0);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_requested_many_elements_can_be_prepended_without_reallocating_memory() {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        for additional in 1..32 {
                                            let mut actual = Dynamic::<usize>::default();

                                            _ = actual.reserve_back(front + back).expect("successful allocation");

                                            _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                            debug_assert_eq!(actual.initialized, 0);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.reserve_front(front + back + additional).expect("successful allocation");

                                            let allocation = actual.buffer;

                                            for element in 0..(front + back + additional) {
                                                _ = actual.prepend(element).expect("uses capacity");
                                            }

                                            assert_eq!(actual.buffer, allocation);
                                        }
                                    }
                                }
                            }
                        }

                        mod when_not_empty {
                            use super::*;

                            #[test]
                            fn when_zero_size_type_then_can_allocate_maximum_possible_amount() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            let mut actual: Dynamic<_> = core::iter::repeat_n((), elements).collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.reserve_front(isize::MAX as usize - elements - back).expect("ZSTs do not occupy memory");

                                            assert_eq!(actual.capacity(), isize::MAX as usize - elements);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_increases_front_capacity_to_exactly_requested() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            for additional in 1..32 {
                                                let mut actual: Dynamic<_> = (0..elements).collect();

                                                _ = actual.reserve_front(front).expect("successful allocation");
                                                _ = actual.reserve_back(back).expect("successful allocation");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front);
                                                debug_assert_eq!(actual.back_capacity, back);

                                                _ = actual.reserve_front(front + back + additional).expect("successful allocation");

                                                assert_eq!(actual.front_capacity, front + back + additional);
                                            }
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_modify_back_capacity() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            for additional in 1..32 {
                                                let mut actual: Dynamic<_> = (0..elements).collect();

                                                _ = actual.reserve_front(front).expect("successful allocation");
                                                _ = actual.reserve_back(back).expect("successful allocation");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front);
                                                debug_assert_eq!(actual.back_capacity, back);

                                                _ = actual.reserve_front(front + back + additional).expect("successful allocation");

                                                assert_eq!(actual.back_capacity, back);
                                            }
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_modify_initialized_elements() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            for additional in 1..32 {
                                                let expected = 0..elements;

                                                let mut actual: Dynamic<_> = expected.clone().collect();

                                                _ = actual.reserve_front(front).expect("successful allocation");
                                                _ = actual.reserve_back(back).expect("successful allocation");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front);
                                                debug_assert_eq!(actual.back_capacity, back);

                                                _ = actual.reserve_front(front + back + additional).expect("successful allocation");

                                                assert!(actual.eq(expected));
                                            }
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_requested_many_elements_can_be_prepended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            for additional in 1..32 {
                                                let expected = 0..elements;

                                                let mut actual: Dynamic<_> = expected.clone().collect();

                                                _ = actual.reserve_front(front).expect("successful allocation");
                                                _ = actual.reserve_back(back).expect("successful allocation");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front);
                                                debug_assert_eq!(actual.back_capacity, back);

                                                _ = actual.reserve_front(front + back + additional).expect("successful allocation");

                                                let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                                for _ in 0..(front + back + additional) {
                                                    // NOTE: this is distinct from the expected values.
                                                    _ = actual.prepend(usize::MAX).expect("uses capacity");
                                                }

                                                assert!(pointers.iter().copied().eq(expected));
                                            }
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_back_many_elements_can_be_appended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            for additional in 1..32 {
                                                let expected = 0..elements;

                                                let mut actual: Dynamic<_> = expected.clone().collect();

                                                _ = actual.reserve_front(front).expect("successful allocation");
                                                _ = actual.reserve_back(back).expect("successful allocation");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front);
                                                debug_assert_eq!(actual.back_capacity, back);

                                                _ = actual.reserve_front(front + back + additional).expect("successful allocation");

                                                let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                                for _ in 0..back {
                                                    // NOTE: this is distinct from the expected values.
                                                    _ = actual.append(usize::MAX).expect("uses capacity");
                                                }

                                                assert!(pointers.iter().copied().eq(expected));
                                            }
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_both_requested_many_elements_can_be_prepended_and_back_many_elements_can_be_appended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            for additional in 1..32 {
                                                let expected = 0..elements;

                                                let mut actual: Dynamic<_> = expected.clone().collect();

                                                _ = actual.reserve_front(front).expect("successful allocation");
                                                _ = actual.reserve_back(back).expect("successful allocation");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front);
                                                debug_assert_eq!(actual.back_capacity, back);

                                                _ = actual.reserve_front(front + back + additional).expect("successful allocation");

                                                let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                                for _ in 0..(front + back + additional) {
                                                    // NOTE: this is distinct from the expected values.
                                                    _ = actual.prepend(usize::MAX).expect("uses capacity");
                                                }

                                                for _ in 0..back {
                                                    // NOTE: this is distinct from the expected values.
                                                    _ = actual.append(usize::MAX).expect("uses capacity");
                                                }

                                                assert!(pointers.iter().copied().eq(expected));
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }

                    mod when_sum_is_exactly_requested {
                        use super::*;

                        mod when_empty {
                            use super::*;

                            #[test]
                            fn when_zero_size_type_then_can_allocate_maximum_possible_amount() {
                                for exponent in 0..(isize::BITS - 2) {
                                    let mut actual = Dynamic::<()>::default();

                                    _ = actual.reserve_back(isize::MAX as usize).expect("ZSTs do not occupy memory");

                                    let front = usize::pow(2, exponent);

                                    _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, front);
                                    debug_assert_eq!(actual.back_capacity, isize::MAX as usize - front);

                                    _ = actual.reserve_front(isize::MAX as usize).expect("already enough capacity");

                                    assert_eq!(actual.capacity(), isize::MAX as usize);
                                }
                            }

                            #[test]
                            fn then_does_not_modify_capacity() {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(front + back).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.reserve_front(front + back).expect("already enough capacity");

                                        assert_eq!(actual.capacity(), front + back);
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_initialize_elements() {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(front + back).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.reserve_front(front + back).expect("already enough capacity");

                                        assert_eq!(actual.initialized, 0);
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_reallocate_memory() {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(front + back).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        let allocation = actual.buffer;

                                        _ = actual.reserve_front(front + back).expect("already enough capacity");

                                        assert_eq!(actual.buffer, allocation);
                                    }
                                }
                            }

                            #[test]
                            fn then_requested_many_elements_can_be_prepended_without_reallocating_memory() {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(front + back).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.reserve_front(front + back).expect("already enough capacity");

                                        let allocation = actual.buffer;

                                        for element in 0..(front + back) {
                                            _ = actual.prepend(element).expect("uses capacity");
                                        }

                                        assert_eq!(actual.buffer, allocation);
                                    }
                                }
                            }
                        }

                        mod when_not_empty {
                            use super::*;

                            #[test]
                            fn then_increases_front_capacity_to_exactly_requested() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.reserve_front(front + back).expect("successful allocation");

                                            assert_eq!(actual.front_capacity, front + back);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_modify_back_capacity() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.reserve_front(front + back).expect("successful allocation");

                                            assert_eq!(actual.back_capacity, back);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_modify_initialized_elements() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.reserve_front(front + back).expect("successful allocation");

                                            assert!(actual.eq(expected));
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_requested_many_elements_can_be_prepended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.reserve_front(front + back).expect("successful allocation");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..(front + back) {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.prepend(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_back_many_elements_can_be_appended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.reserve_front(front + back).expect("successful allocation");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..back {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.append(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_both_requested_many_elements_can_be_prepended_and_back_many_elements_can_be_appended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.reserve_front(front + back).expect("successful allocation");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..(front + back) {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.prepend(usize::MAX).expect("uses capacity");
                                            }

                                            for _ in 0..back {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.append(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }
                        }
                    }

                    mod when_sum_is_more_than_requested {
                        use super::*;

                        mod when_empty {
                            use super::*;

                            #[test]
                            fn then_does_not_modify_capacity() {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        for additional in 1..usize::min(front, back) {
                                            let mut actual = Dynamic::<usize>::default();

                                            _ = actual.reserve_back(front + back).expect("successful allocation");

                                            _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                            debug_assert_eq!(actual.initialized, 0);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.reserve_front(front + back - additional).expect("already enough capacity");

                                            assert_eq!(actual.capacity(), front + back);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_initialize_elements() {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        for additional in 1..usize::min(front, back) {
                                            let mut actual = Dynamic::<usize>::default();

                                            _ = actual.reserve_back(front + back).expect("successful allocation");

                                            _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                            debug_assert_eq!(actual.initialized, 0);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.reserve_front(front + back - additional).expect("already enough capacity");

                                            assert_eq!(actual.initialized, 0);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_reallocate_memory() {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        for additional in 1..usize::min(front, back) {
                                            let mut actual = Dynamic::<usize>::default();

                                            _ = actual.reserve_back(front + back).expect("successful allocation");

                                            _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                            debug_assert_eq!(actual.initialized, 0);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            let allocation = actual.buffer;

                                            _ = actual.reserve_front(front + back - additional).expect("already enough capacity");

                                            assert_eq!(actual.buffer, allocation);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_capacity_many_elements_can_be_prepended_without_reallocating_memory() {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        for additional in 1..usize::min(front, back) {
                                            let mut actual = Dynamic::<usize>::default();

                                            _ = actual.reserve_back(front + back).expect("successful allocation");

                                            _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                            debug_assert_eq!(actual.initialized, 0);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.reserve_front(front + back - additional).expect("already enough capacity");

                                            let allocation = actual.buffer;

                                            for element in 0..(front + back) {
                                                _ = actual.append(element).expect("uses capacity");
                                            }

                                            assert_eq!(actual.buffer, allocation);
                                        }
                                    }
                                }
                            }
                        }

                        mod when_not_empty {
                            use super::*;

                            #[test]
                            fn then_increases_front_capacity_to_exactly_requested() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            for additional in 1..usize::min(front, back) {
                                                let mut actual: Dynamic<_> = (0..elements).collect();

                                                _ = actual.reserve_front(front).expect("successful allocation");
                                                _ = actual.reserve_back(back).expect("successful allocation");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front);
                                                debug_assert_eq!(actual.back_capacity, back);

                                                _ = actual.reserve_front(front + back - additional).expect("already enough capacity");

                                                assert_eq!(actual.front_capacity, front + back - additional);
                                            }
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_modify_back_capacity() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            for additional in 1..usize::min(front, back) {
                                                let mut actual: Dynamic<_> = (0..elements).collect();

                                                _ = actual.reserve_front(front).expect("successful allocation");
                                                _ = actual.reserve_back(back).expect("successful allocation");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front);
                                                debug_assert_eq!(actual.back_capacity, back);

                                                _ = actual.reserve_front(front + back - additional).expect("already enough capacity");

                                                assert_eq!(actual.back_capacity, back);
                                            }
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_modify_initialized_elements() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            for additional in 1..usize::min(front, back) {
                                                let expected = 0..elements;

                                                let mut actual: Dynamic<_> = expected.clone().collect();

                                                _ = actual.reserve_front(front).expect("successful allocation");
                                                _ = actual.reserve_back(back).expect("successful allocation");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front);
                                                debug_assert_eq!(actual.back_capacity, back);

                                                _ = actual.reserve_front(front + back - additional).expect("already enough capacity");

                                                assert!(actual.eq(expected));
                                            }
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_requested_many_elements_can_be_prepended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            for additional in 1..usize::min(front, back) {
                                                let expected = 0..elements;

                                                let mut actual: Dynamic<_> = expected.clone().collect();

                                                _ = actual.reserve_front(front).expect("successful allocation");
                                                _ = actual.reserve_back(back).expect("successful allocation");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front);
                                                debug_assert_eq!(actual.back_capacity, back);

                                                _ = actual.reserve_front(front + back - additional).expect("already enough capacity");

                                                let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                                for _ in 0..(front + back - additional) {
                                                    // NOTE: this is distinct from the expected values.
                                                    _ = actual.prepend(usize::MAX).expect("uses capacity");
                                                }

                                                assert!(pointers.iter().copied().eq(expected));
                                            }
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_back_many_elements_can_be_appended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            for additional in 1..usize::min(front, back) {
                                                let expected = 0..elements;

                                                let mut actual: Dynamic<_> = expected.clone().collect();

                                                _ = actual.reserve_front(front).expect("successful allocation");
                                                _ = actual.reserve_back(back).expect("successful allocation");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front);
                                                debug_assert_eq!(actual.back_capacity, back);

                                                _ = actual.reserve_front(front + back - additional).expect("already enough capacity");

                                                let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                                for _ in 0..back {
                                                    // NOTE: this is distinct from the expected values.
                                                    _ = actual.append(usize::MAX).expect("uses capacity");
                                                }

                                                assert!(pointers.iter().copied().eq(expected));
                                            }
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_both_requested_many_elements_can_be_prepended_and_back_many_elements_can_be_appended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            for additional in 1..usize::min(front, back) {
                                                let expected = 0..elements;

                                                let mut actual: Dynamic<_> = expected.clone().collect();

                                                _ = actual.reserve_front(front).expect("successful allocation");
                                                _ = actual.reserve_back(back).expect("successful allocation");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front);
                                                debug_assert_eq!(actual.back_capacity, back);

                                                _ = actual.reserve_front(front + back - additional).expect("already enough capacity");

                                                let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                                for _ in 0..(front + back - additional) {
                                                    // NOTE: this is distinct from the expected values.
                                                    _ = actual.prepend(usize::MAX).expect("uses capacity");
                                                }

                                                for _ in 0..back {
                                                    // NOTE: this is distinct from the expected values.
                                                    _ = actual.append(usize::MAX).expect("uses capacity");
                                                }

                                                assert!(pointers.iter().copied().eq(expected));
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                mod when_front_is_exactly_requested {
                    use super::*;

                    mod when_back_is_less_than_requested {
                        use super::*;

                        mod when_empty {
                            use super::*;

                            #[test]
                            fn then_does_not_modify_capacity() {
                                for front in 1..32 {
                                    for back in 1..front {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(front + back).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.reserve_front(front).expect("already enough capacity");

                                        assert_eq!(actual.capacity(), front + back);
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_initialize_elements() {
                                for front in 1..32 {
                                    for back in 1..front {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(front + back).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.reserve_front(front).expect("already enough capacity");

                                        assert_eq!(actual.initialized, 0);
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_reallocate_memory() {
                                for front in 1..32 {
                                    for back in 1..front {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(front + back).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        let allocation = actual.buffer;

                                        _ = actual.reserve_front(front).expect("already enough capacity");

                                        assert_eq!(actual.buffer, allocation);
                                    }
                                }
                            }

                            #[test]
                            fn then_capacity_many_elements_can_be_prepended_without_reallocating_memory() {
                                for front in 1..32 {
                                    for back in 1..front {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(front + back).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.reserve_front(front).expect("already enough capacity");

                                        let allocation = actual.buffer;

                                        for element in 0..(front + back) {
                                            _ = actual.append(element).expect("uses capacity");
                                        }

                                        assert_eq!(actual.buffer, allocation);
                                    }
                                }
                            }
                        }

                        mod when_not_empty {
                            use super::*;

                            #[test]
                            fn then_does_not_modify_front_capacity() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..front {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.reserve_front(front).expect("already enough capacity");

                                            assert_eq!(actual.front_capacity, front);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_modify_back_capacity() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..front {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.reserve_front(front).expect("already enough capacity");

                                            assert_eq!(actual.back_capacity, back);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_modify_initialized_elements() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..front {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.reserve_front(front).expect("already enough capacity");

                                            assert!(actual.eq(expected));
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_reallocate_memory() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..front {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            let allocation = actual.buffer;

                                            _ = actual.reserve_front(front).expect("already enough capacity");

                                            assert_eq!(actual.buffer, allocation);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_requested_many_elements_can_be_prepended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..front {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.reserve_front(front).expect("already enough capacity");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..front {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.prepend(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_back_many_elements_can_be_appended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..front {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.reserve_front(front).expect("already enough capacity");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..back {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.append(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_both_requested_many_elements_can_be_prepended_and_back_many_elements_can_be_appended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..front {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.reserve_front(front).expect("already enough capacity");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..front {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.prepend(usize::MAX).expect("uses capacity");
                                            }

                                            for _ in 0..back {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.append(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }
                        }
                    }

                    mod when_back_is_more_than_requested {
                        use super::*;

                        mod when_empty {
                            use super::*;

                            #[test]
                            fn then_does_not_modify_capacity() {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(capacity + capacity + additional).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(capacity).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, capacity);
                                        debug_assert_eq!(actual.back_capacity, capacity + additional);

                                        _ = actual.reserve_front(capacity).expect("already enough capacity");

                                        assert_eq!(actual.capacity(), capacity + capacity + additional);
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_initialize_elements() {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(capacity + capacity + additional).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(capacity).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, capacity);
                                        debug_assert_eq!(actual.back_capacity, capacity + additional);

                                        _ = actual.reserve_front(capacity).expect("already enough capacity");

                                        assert_eq!(actual.initialized, 0);
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_reallocate_memory() {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(capacity + capacity + additional).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(capacity).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, capacity);
                                        debug_assert_eq!(actual.back_capacity, capacity + additional);

                                        let allocation = actual.buffer;

                                        _ = actual.reserve_front(capacity).expect("already enough capacity");

                                        assert_eq!(actual.buffer, allocation);
                                    }
                                }
                            }

                            #[test]
                            fn then_capacity_many_elements_can_be_prepended_without_reallocating_memory() {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(capacity + capacity + additional).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(capacity).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, capacity);
                                        debug_assert_eq!(actual.back_capacity, capacity + additional);

                                        _ = actual.reserve_front(capacity).expect("already enough capacity");

                                        let allocation = actual.buffer;

                                        for element in 0..(capacity + capacity + additional) {
                                            _ = actual.prepend(element).expect("uses capacity");
                                        }

                                        assert_eq!(actual.buffer, allocation);
                                    }
                                }
                            }
                        }

                        mod when_not_empty {
                            use super::*;

                            #[test]
                            fn then_does_not_modify_front_capacity() {
                                for elements in 1..32 {
                                    for capacity in 1..32 {
                                        for additional in 1..32 {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(capacity).expect("successful allocation");
                                            _ = actual.reserve_back(capacity + additional).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, capacity);
                                            debug_assert_eq!(actual.back_capacity, capacity + additional);

                                            _ = actual.reserve_front(capacity).expect("already enough capacity");

                                            assert_eq!(actual.front_capacity, capacity);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_modify_back_capacity() {
                                for elements in 1..32 {
                                    for capacity in 1..32 {
                                        for additional in 1..32 {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(capacity).expect("successful allocation");
                                            _ = actual.reserve_back(capacity + additional).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, capacity);
                                            debug_assert_eq!(actual.back_capacity, capacity + additional);

                                            _ = actual.reserve_front(capacity).expect("already enough capacity");

                                            assert_eq!(actual.front_capacity, capacity);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_modify_initialized_elements() {
                                for elements in 1..32 {
                                    for capacity in 1..32 {
                                        for additional in 1..32 {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(capacity).expect("successful allocation");
                                            _ = actual.reserve_back(capacity + additional).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, capacity);
                                            debug_assert_eq!(actual.back_capacity, capacity + additional);

                                            _ = actual.reserve_front(capacity).expect("already enough capacity");

                                            assert!(actual.eq(expected));
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_reallocate_memory() {
                                for elements in 1..32 {
                                    for capacity in 1..32 {
                                        for additional in 1..32 {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(capacity).expect("successful allocation");
                                            _ = actual.reserve_back(capacity + additional).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, capacity);
                                            debug_assert_eq!(actual.back_capacity, capacity + additional);

                                            let allocation = actual.buffer;

                                            _ = actual.reserve_front(capacity).expect("already enough capacity");

                                            assert_eq!(actual.buffer, allocation);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_requested_many_elements_can_be_prepended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for capacity in 1..32 {
                                        for additional in 1..32 {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(capacity).expect("successful allocation");
                                            _ = actual.reserve_back(capacity + additional).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, capacity);
                                            debug_assert_eq!(actual.back_capacity, capacity + additional);

                                            _ = actual.reserve_front(capacity).expect("already enough capacity");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..capacity {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.prepend(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_back_many_elements_can_be_appended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for capacity in 1..32 {
                                        for additional in 1..32 {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(capacity).expect("successful allocation");
                                            _ = actual.reserve_back(capacity + additional).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, capacity);
                                            debug_assert_eq!(actual.back_capacity, capacity + additional);

                                            _ = actual.reserve_front(capacity).expect("already enough capacity");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..(capacity  + additional){
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.append(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_both_requested_many_elements_can_be_prepended_and_front_many_elements_can_be_appended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for capacity in 1..32 {
                                        for additional in 1..32 {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(capacity).expect("successful allocation");
                                            _ = actual.reserve_back(capacity + additional).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, capacity);
                                            debug_assert_eq!(actual.back_capacity, capacity + additional);

                                            _ = actual.reserve_front(capacity).expect("already enough capacity");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..capacity {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.prepend(usize::MAX).expect("uses capacity");
                                            }

                                            for _ in 0..(capacity  + additional){
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.append(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                mod when_back_is_exactly_requested {
                    use super::*;

                    mod when_front_is_less_than_requested {
                        use super::*;

                        mod when_empty {
                            use super::*;

                            #[test]
                            fn then_does_not_modify_capacity() {
                                for back in 1..32 {
                                    for front in 1..back {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(front + back).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.reserve_front(back).expect("already enough capacity");

                                        assert_eq!(actual.capacity(), front + back);
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_initialize_elements() {
                                for back in 1..32 {
                                    for front in 1..back {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(front + back).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.reserve_front(back).expect("already enough capacity");

                                        assert_eq!(actual.initialized, 0);
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_reallocate_memory() {
                                for back in 1..32 {
                                    for front in 1..back {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(front + back).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        let allocation = actual.buffer;

                                        _ = actual.reserve_front(back).expect("already enough capacity");

                                        assert_eq!(actual.buffer, allocation);
                                    }
                                }
                            }

                            #[test]
                            fn then_capacity_many_elements_can_be_prepended_without_reallocating_memory() {
                                for back in 1..32 {
                                    for front in 1..back {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(front + back).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.reserve_front(back).expect("already enough capacity");

                                        let allocation = actual.buffer;

                                        for element in 0..(front + back) {
                                            _ = actual.prepend(element).expect("uses capacity");
                                        }

                                        assert_eq!(actual.buffer, allocation);
                                    }
                                }
                            }
                        }

                        mod when_not_empty {
                            use super::*;

                            #[test]
                            fn then_increases_front_capacity_to_exactly_requested() {
                                for elements in 1..32 {
                                    for back in 1..32 {
                                        for front in 1..back {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.reserve_front(back).expect("successful allocation");

                                            assert_eq!(actual.front_capacity, back);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_modify_back_capacity() {
                                for elements in 1..32 {
                                    for back in 1..32 {
                                        for front in 1..back {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.reserve_front(back).expect("successful allocation");

                                            assert_eq!(actual.back_capacity, back);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_modify_initialized_elements() {
                                for elements in 1..32 {
                                    for back in 1..32 {
                                        for front in 1..back {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.reserve_front(back).expect("successful allocation");

                                            assert!(actual.eq(expected));
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_requested_many_elements_can_be_prepended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for back in 1..32 {
                                        for front in 1..back {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.reserve_front(back).expect("successful allocation");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..back {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.prepend(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_back_many_elements_can_be_appended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for back in 1..32 {
                                        for front in 1..back {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.reserve_front(back).expect("successful allocation");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..back {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.append(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_both_requested_many_elements_can_be_prepended_and_back_many_elements_can_be_appended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for back in 1..32 {
                                        for front in 1..back {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.reserve_front(back).expect("successful allocation");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..back {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.append(usize::MAX).expect("uses capacity");
                                            }

                                            for _ in 0..back {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.prepend(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }
                        }
                    }

                    mod when_front_is_more_than_requested {
                        use super::*;

                        mod when_empty {
                            use super::*;

                            #[test]
                            fn then_does_not_modify_capacity() {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(capacity + additional + capacity).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(capacity + additional).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, capacity + additional);
                                        debug_assert_eq!(actual.back_capacity, capacity);

                                        _ = actual.reserve_front(capacity).expect("already enough capacity");

                                        assert_eq!(actual.capacity(), capacity + additional + capacity);
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_initialize_elements() {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(capacity + additional + capacity).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(capacity + additional).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, capacity + additional);
                                        debug_assert_eq!(actual.back_capacity, capacity);

                                        _ = actual.reserve_front(capacity).expect("already enough capacity");

                                        assert_eq!(actual.initialized, 0);
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_reallocate_memory() {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(capacity + additional + capacity).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(capacity + additional).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, capacity + additional);
                                        debug_assert_eq!(actual.back_capacity, capacity);

                                        let allocation = actual.buffer;

                                        _ = actual.reserve_front(capacity).expect("already enough capacity");

                                        assert_eq!(actual.buffer, allocation);
                                    }
                                }
                            }

                            #[test]
                            fn then_capacity_many_elements_can_be_prepended_without_reallocating_memory() {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(capacity + additional + capacity).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(capacity + additional).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, capacity + additional);
                                        debug_assert_eq!(actual.back_capacity, capacity);

                                        _ = actual.reserve_front(capacity).expect("already enough capacity");

                                        let allocation = actual.buffer;

                                        for element in 0..(capacity + additional + capacity) {
                                            _ = actual.prepend(element).expect("uses capacity");
                                        }

                                        assert_eq!(actual.buffer, allocation);
                                    }
                                }
                            }
                        }

                        mod when_not_empty {
                            use super::*;

                            #[test]
                            fn then_does_not_modify_front_capacity() {
                                for elements in 1..32 {
                                    for capacity in 1..32 {
                                        for additional in 1..32 {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(capacity + additional).expect("successful allocation");
                                            _ = actual.reserve_back(capacity).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, capacity + additional);
                                            debug_assert_eq!(actual.back_capacity, capacity);

                                            _ = actual.reserve_front(capacity).expect("already enough capacity");

                                            assert_eq!(actual.front_capacity, capacity + additional);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_modify_back_capacity() {
                                for elements in 1..32 {
                                    for capacity in 1..32 {
                                        for additional in 1..32 {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(capacity + additional).expect("successful allocation");
                                            _ = actual.reserve_back(capacity).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, capacity + additional);
                                            debug_assert_eq!(actual.back_capacity, capacity);

                                            _ = actual.reserve_front(capacity).expect("already enough capacity");

                                            assert_eq!(actual.back_capacity, capacity);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_modify_initialized_elements() {
                                for elements in 1..32 {
                                    for capacity in 1..32 {
                                        for additional in 1..32 {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(capacity + additional).expect("successful allocation");
                                            _ = actual.reserve_back(capacity).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, capacity + additional);
                                            debug_assert_eq!(actual.back_capacity, capacity);

                                            _ = actual.reserve_front(capacity).expect("already enough capacity");

                                            assert!(actual.eq(expected));
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_reallocate_memory() {
                                for elements in 1..32 {
                                    for capacity in 1..32 {
                                        for additional in 1..32 {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(capacity + additional).expect("successful allocation");
                                            _ = actual.reserve_back(capacity).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, capacity + additional);
                                            debug_assert_eq!(actual.back_capacity, capacity);

                                            let allocation = actual.buffer;

                                            _ = actual.reserve_front(capacity).expect("already enough capacity");

                                            assert_eq!(actual.buffer, allocation);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_front_many_elements_can_be_prepended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for capacity in 1..32 {
                                        for additional in 1..32 {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(capacity + additional).expect("successful allocation");
                                            _ = actual.reserve_back(capacity).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, capacity + additional);
                                            debug_assert_eq!(actual.back_capacity, capacity);

                                            _ = actual.reserve_front(capacity).expect("already enough capacity");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..(capacity + additional) {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.prepend(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_back_many_elements_can_be_appended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for capacity in 1..32 {
                                        for additional in 1..32 {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(capacity + additional).expect("successful allocation");
                                            _ = actual.reserve_back(capacity).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, capacity + additional);
                                            debug_assert_eq!(actual.back_capacity, capacity);

                                            _ = actual.reserve_front(capacity).expect("already enough capacity");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..capacity {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.append(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_both_front_many_elements_can_be_prepended_and_back_many_elements_can_be_appended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for capacity in 1..32 {
                                        for additional in 1..32 {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(capacity + additional).expect("successful allocation");
                                            _ = actual.reserve_back(capacity).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, capacity + additional);
                                            debug_assert_eq!(actual.back_capacity, capacity);

                                            _ = actual.reserve_front(capacity).expect("already enough capacity");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..(capacity + additional) {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.prepend(usize::MAX).expect("uses capacity");
                                            }

                                            for _ in 0..capacity {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.append(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                mod when_both_exactly_requested {
                    use super::*;

                    mod when_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_capacity() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_back(capacity + capacity).expect("successful allocation");

                                _ = actual.shift(isize::try_from(capacity).expect("too small to wrap")).expect("enough back capacity to shift into");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, capacity);
                                debug_assert_eq!(actual.back_capacity, capacity);

                                _ = actual.reserve_front(capacity).expect("already enough capacity");

                                assert_eq!(actual.capacity(), capacity + capacity);
                            }
                        }

                        #[test]
                        fn then_does_not_initialize_elements() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_back(capacity + capacity).expect("successful allocation");

                                _ = actual.shift(isize::try_from(capacity).expect("too small to wrap")).expect("enough back capacity to shift into");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, capacity);
                                debug_assert_eq!(actual.back_capacity, capacity);

                                _ = actual.reserve_front(capacity).expect("already enough capacity");

                                assert_eq!(actual.initialized, 0);
                            }
                        }

                        #[test]
                        fn then_does_not_reallocate_memory() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_back(capacity + capacity).expect("successful allocation");

                                _ = actual.shift(isize::try_from(capacity).expect("too small to wrap")).expect("enough back capacity to shift into");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, capacity);
                                debug_assert_eq!(actual.back_capacity, capacity);

                                let allocation = actual.buffer;

                                _ = actual.reserve_front(capacity).expect("already enough capacity");

                                assert_eq!(actual.buffer, allocation);
                            }
                        }

                        #[test]
                        fn then_capacity_many_elements_can_be_prepended_without_reallocating_memory() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_back(capacity + capacity).expect("successful allocation");

                                _ = actual.shift(isize::try_from(capacity).expect("too small to wrap")).expect("enough back capacity to shift into");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, capacity);
                                debug_assert_eq!(actual.back_capacity, capacity);

                                _ = actual.reserve_front(capacity).expect("already enough capacity");

                                let allocation = actual.buffer;

                                for element in 0..(capacity + capacity) {
                                    _ = actual.prepend(element).expect("uses capacity");
                                }

                                assert_eq!(actual.buffer, allocation);
                            }
                        }
                    }

                    mod when_not_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_front_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let mut actual: Dynamic<_> = (0..elements).collect();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");
                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    _ = actual.reserve_front(capacity).expect("already enough capacity");

                                    assert_eq!(actual.front_capacity, capacity);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_back_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let mut actual: Dynamic<_> = (0..elements).collect();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");
                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    _ = actual.reserve_front(capacity).expect("already enough capacity");

                                    assert_eq!(actual.back_capacity, capacity);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_initialized_elements() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let expected = 0..elements;

                                    let mut actual: Dynamic<_> = expected.clone().collect();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");
                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    _ = actual.reserve_front(capacity).expect("already enough capacity");

                                    assert!(actual.eq(expected));
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_reallocate_memory() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let mut actual: Dynamic<_> = (0..elements).collect();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");
                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    let allocation = actual.buffer;

                                    _ = actual.reserve_front(capacity).expect("already enough capacity");

                                    assert_eq!(actual.buffer, allocation);
                                }
                            }
                        }

                        #[test]
                        fn then_requested_many_elements_can_be_prepended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let expected = 0..elements;

                                    let mut actual: Dynamic<_> = expected.clone().collect();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");
                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    _ = actual.reserve_front(capacity).expect("already enough capacity");

                                    let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                    for _ in 0..capacity {
                                        // NOTE: this is distinct from the expected values.
                                        _ = actual.prepend(usize::MAX).expect("uses capacity");
                                    }

                                    assert!(pointers.iter().copied().eq(expected));
                                }
                            }
                        }

                        #[test]
                        fn then_back_many_elements_can_be_appended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let expected = 0..elements;

                                    let mut actual: Dynamic<_> = expected.clone().collect();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");
                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    _ = actual.reserve_front(capacity).expect("already enough capacity");

                                    let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                    for _ in 0..capacity {
                                        // NOTE: this is distinct from the expected values.
                                        _ = actual.append(usize::MAX).expect("uses capacity");
                                    }

                                    assert!(pointers.iter().copied().eq(expected));
                                }
                            }
                        }

                        #[test]
                        fn then_both_requested_many_elements_can_be_prepended_and_back_many_elements_can_be_appended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let expected = 0..elements;

                                    let mut actual: Dynamic<_> = expected.clone().collect();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");
                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    _ = actual.reserve_front(capacity).expect("already enough capacity");

                                    let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                    for _ in 0..capacity {
                                        // NOTE: this is distinct from the expected values.
                                        _ = actual.prepend(usize::MAX).expect("uses capacity");
                                    }

                                    for _ in 0..capacity {
                                        // NOTE: this is distinct from the expected values.
                                        _ = actual.append(usize::MAX).expect("uses capacity");
                                    }

                                    assert!(pointers.iter().copied().eq(expected));
                                }
                            }
                        }
                    }
                }

                mod when_front_is_more_than_requested_and_back_is_less_than_requested {
                    use super::*;

                    mod when_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_capacity() {
                            for capacity in 1..32 {
                                for more in capacity..(capacity + 32) {
                                    for less in 1..capacity {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(more + less).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(more).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, more);
                                        debug_assert_eq!(actual.back_capacity, less);

                                        _ = actual.reserve_front(capacity).expect("already enough capacity");

                                        assert_eq!(actual.capacity(), more + less);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_initialize_elements() {
                            for capacity in 1..32 {
                                for more in capacity..(capacity + 32) {
                                    for less in 1..capacity {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(more + less).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(more).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, more);
                                        debug_assert_eq!(actual.back_capacity, less);

                                        _ = actual.reserve_front(capacity).expect("already enough capacity");

                                        assert_eq!(actual.initialized, 0);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_reallocate_memory() {
                            for capacity in 1..32 {
                                for more in capacity..(capacity + 32) {
                                    for less in 1..capacity {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(more + less).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(more).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, more);
                                        debug_assert_eq!(actual.back_capacity, less);

                                        let allocation = actual.buffer;

                                        _ = actual.reserve_front(capacity).expect("already enough capacity");

                                        assert_eq!(actual.buffer, allocation);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_capacity_many_elements_can_be_prepended_without_reallocating_memory() {
                            for capacity in 1..32 {
                                for more in capacity..(capacity + 32) {
                                    for less in 1..capacity {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(more + less).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(more).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, more);
                                        debug_assert_eq!(actual.back_capacity, less);

                                        _ = actual.reserve_front(capacity).expect("already enough capacity");

                                        let allocation = actual.buffer;

                                        for element in 0..(more + less) {
                                            _ = actual.prepend(element).expect("uses capacity");
                                        }

                                        assert_eq!(actual.buffer, allocation);
                                    }
                                }
                            }
                        }
                    }

                    mod when_not_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_front_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for more in capacity..(capacity + 32) {
                                        for less in 1..capacity {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(more).expect("successful allocation");
                                            _ = actual.reserve_back(less).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, more);
                                            debug_assert_eq!(actual.back_capacity, less);

                                            _ = actual.reserve_front(capacity).expect("already enough capacity");

                                            assert_eq!(actual.front_capacity, more);
                                        }
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_back_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for more in capacity..(capacity + 32) {
                                        for less in 1..capacity {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(more).expect("successful allocation");
                                            _ = actual.reserve_back(less).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, more);
                                            debug_assert_eq!(actual.back_capacity, less);

                                            _ = actual.reserve_front(capacity).expect("already enough capacity");

                                            assert_eq!(actual.back_capacity, less);
                                        }
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_initialized_elements() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for more in capacity..(capacity + 32) {
                                        for less in 1..capacity {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(more).expect("successful allocation");
                                            _ = actual.reserve_back(less).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, more);
                                            debug_assert_eq!(actual.back_capacity, less);

                                            _ = actual.reserve_front(capacity).expect("already enough capacity");

                                            assert!(actual.eq(expected));
                                        }
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_reallocate_memory() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for more in capacity..(capacity + 32) {
                                        for less in 1..capacity {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(more).expect("successful allocation");
                                            _ = actual.reserve_back(less).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, more);
                                            debug_assert_eq!(actual.back_capacity, less);

                                            let allocation = actual.buffer;

                                            _ = actual.reserve_front(capacity).expect("already enough capacity");

                                            assert_eq!(actual.buffer, allocation);
                                        }
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_front_many_elements_can_be_prepended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for more in capacity..(capacity + 32) {
                                        for less in 1..capacity {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(more).expect("successful allocation");
                                            _ = actual.reserve_back(less).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, more);
                                            debug_assert_eq!(actual.back_capacity, less);

                                            _ = actual.reserve_front(capacity).expect("already enough capacity");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..more {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.prepend(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_back_many_elements_can_be_appended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for more in capacity..(capacity + 32) {
                                        for less in 1..capacity {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(more).expect("successful allocation");
                                            _ = actual.reserve_back(less).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, more);
                                            debug_assert_eq!(actual.back_capacity, less);

                                            _ = actual.reserve_front(capacity).expect("already enough capacity");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..less {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.append(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_both_front_many_elements_can_be_prepended_and_back_many_elements_can_be_appended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for more in capacity..(capacity + 32) {
                                        for less in 1..capacity {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(more).expect("successful allocation");
                                            _ = actual.reserve_back(less).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, more);
                                            debug_assert_eq!(actual.back_capacity, less);

                                            _ = actual.reserve_front(capacity).expect("already enough capacity");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..more {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.prepend(usize::MAX).expect("uses capacity");
                                            }

                                            for _ in 0..less {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.append(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                mod when_front_is_less_than_requested_and_back_is_more_than_requested {
                    use super::*;

                    mod when_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_capacity() {
                            for capacity in 1..32 {
                                for more in capacity..(capacity + 32) {
                                    for less in 1..capacity {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(less + more).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(less).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, less);
                                        debug_assert_eq!(actual.back_capacity, more);

                                        _ = actual.reserve_front(capacity).expect("already enough capacity");

                                        assert_eq!(actual.capacity(), less + more);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_initialize_elements() {
                            for capacity in 1..32 {
                                for more in capacity..(capacity + 32) {
                                    for less in 1..capacity {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(less + more).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(less).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, less);
                                        debug_assert_eq!(actual.back_capacity, more);

                                        _ = actual.reserve_front(capacity).expect("already enough capacity");

                                        assert_eq!(actual.initialized, 0);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_reallocate_memory() {
                            for capacity in 1..32 {
                                for more in capacity..(capacity + 32) {
                                    for less in 1..capacity {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(less + more).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(less).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, less);
                                        debug_assert_eq!(actual.back_capacity, more);

                                        let allocation = actual.buffer;

                                        _ = actual.reserve_front(capacity).expect("already enough capacity");

                                        assert_eq!(actual.buffer, allocation);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_capacity_many_elements_can_be_prepended_without_reallocating_memory() {
                            for capacity in 1..32 {
                                for more in capacity..(capacity + 32) {
                                    for less in 1..capacity {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(less + more).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(less).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, less);
                                        debug_assert_eq!(actual.back_capacity, more);

                                        _ = actual.reserve_front(capacity).expect("already enough capacity");

                                        let allocation = actual.buffer;

                                        for element in 0..(less + more) {
                                            _ = actual.prepend(element).expect("uses capacity");
                                        }

                                        assert_eq!(actual.buffer, allocation);
                                    }
                                }
                            }
                        }
                    }

                    mod when_not_empty {
                        use super::*;

                        #[test]
                        fn then_increases_front_capacity_to_exactly_requested() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for more in capacity..(capacity + 32) {
                                        for less in 1..capacity {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(less).expect("successful allocation");
                                            _ = actual.reserve_back(more).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, less);
                                            debug_assert_eq!(actual.back_capacity, more);

                                            _ = actual.reserve_front(capacity).expect("successful allocation");

                                            assert_eq!(actual.front_capacity, capacity);
                                        }
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_back_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for more in capacity..(capacity + 32) {
                                        for less in 1..capacity {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(less).expect("successful allocation");
                                            _ = actual.reserve_back(more).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, less);
                                            debug_assert_eq!(actual.back_capacity, more);

                                            _ = actual.reserve_front(capacity).expect("successful allocation");

                                            assert_eq!(actual.back_capacity, more);
                                        }
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_initialized_elements() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for more in capacity..(capacity + 32) {
                                        for less in 1..capacity {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(less).expect("successful allocation");
                                            _ = actual.reserve_back(more).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, less);
                                            debug_assert_eq!(actual.back_capacity, more);

                                            _ = actual.reserve_front(capacity).expect("successful allocation");

                                            assert!(actual.eq(expected));
                                        }
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_requested_many_elements_can_be_prepended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for more in capacity..(capacity + 32) {
                                        for less in 1..capacity {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(less).expect("successful allocation");
                                            _ = actual.reserve_back(more).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, less);
                                            debug_assert_eq!(actual.back_capacity, more);

                                            _ = actual.reserve_front(capacity).expect("successful allocation");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..capacity {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.prepend(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_back_many_elements_can_be_appended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for more in capacity..(capacity + 32) {
                                        for less in 1..capacity {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(less).expect("successful allocation");
                                            _ = actual.reserve_back(more).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, less);
                                            debug_assert_eq!(actual.back_capacity, more);

                                            _ = actual.reserve_front(capacity).expect("successful allocation");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..more {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.append(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_both_requested_many_elements_can_be_prepended_and_back_many_elements_can_be_appended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for more in capacity..(capacity + 32) {
                                        for less in 1..capacity {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(less).expect("successful allocation");
                                            _ = actual.reserve_back(more).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, less);
                                            debug_assert_eq!(actual.back_capacity, more);

                                            _ = actual.reserve_front(capacity).expect("successful allocation");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..capacity {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.prepend(usize::MAX).expect("uses capacity");
                                            }

                                            for _ in 0..more {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.append(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                mod when_both_more_than_requested {
                    use super::*;

                    mod when_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_capacity() {
                            for capacity in 1..32 {
                                for additional_front in 1..32 {
                                    for additional_back in 1..32 {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(capacity + additional_front + capacity + additional_back).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(capacity + additional_front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, capacity + additional_front);
                                        debug_assert_eq!(actual.back_capacity, capacity + additional_back);

                                        _ = actual.reserve_front(capacity).expect("already enough capacity");

                                        assert_eq!(actual.capacity(), capacity + additional_front + capacity + additional_back);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_initialize_elements() {
                            for capacity in 1..32 {
                                for additional_front in 1..32 {
                                    for additional_back in 1..32 {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(capacity + additional_front + capacity + additional_back).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(capacity + additional_front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, capacity + additional_front);
                                        debug_assert_eq!(actual.back_capacity, capacity + additional_back);

                                        _ = actual.reserve_front(capacity).expect("already enough capacity");

                                        assert_eq!(actual.initialized, 0);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_reallocate_memory() {
                            for capacity in 1..32 {
                                for additional_front in 1..32 {
                                    for additional_back in 1..32 {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(capacity + additional_front + capacity + additional_back).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(capacity + additional_front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, capacity + additional_front);
                                        debug_assert_eq!(actual.back_capacity, capacity + additional_back);

                                        let allocation = actual.buffer;

                                        _ = actual.reserve_front(capacity).expect("already enough capacity");

                                        assert_eq!(actual.buffer, allocation);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_capacity_many_elements_can_be_prepended_without_reallocating_memory() {
                            for capacity in 1..32 {
                                for additional_front in 1..32 {
                                    for additional_back in 1..32 {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(capacity + additional_front + capacity + additional_back).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(capacity + additional_front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, capacity + additional_front);
                                        debug_assert_eq!(actual.back_capacity, capacity + additional_back);

                                        _ = actual.reserve_front(capacity).expect("already enough capacity");

                                        let allocation = actual.buffer;

                                        for element in 0..(capacity + additional_front + capacity + additional_back) {
                                            _ = actual.prepend(element).expect("uses capacity");
                                        }

                                        assert_eq!(actual.buffer, allocation);
                                    }
                                }
                            }
                        }
                    }

                    mod when_not_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_front_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional_front in 1..32 {
                                        for additional_back in 1..32 {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(capacity + additional_front).expect("successful allocation");
                                            _ = actual.reserve_back(capacity + additional_back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, capacity + additional_front);
                                            debug_assert_eq!(actual.back_capacity, capacity + additional_back);

                                            _ = actual.reserve_front(capacity).expect("already enough capacity");

                                            assert_eq!(actual.front_capacity, capacity + additional_front);
                                        }
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_back_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional_front in 1..32 {
                                        for additional_back in 1..32 {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(capacity + additional_front).expect("successful allocation");
                                            _ = actual.reserve_back(capacity + additional_back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, capacity + additional_front);
                                            debug_assert_eq!(actual.back_capacity, capacity + additional_back);

                                            _ = actual.reserve_front(capacity).expect("already enough capacity");

                                            assert_eq!(actual.back_capacity, capacity + additional_back);
                                        }
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_initialized_elements() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional_front in 1..32 {
                                        for additional_back in 1..32 {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(capacity + additional_front).expect("successful allocation");
                                            _ = actual.reserve_back(capacity + additional_back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, capacity + additional_front);
                                            debug_assert_eq!(actual.back_capacity, capacity + additional_back);

                                            _ = actual.reserve_front(capacity).expect("already enough capacity");

                                            assert!(actual.eq(expected));
                                        }
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_reallocate_memory() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional_front in 1..32 {
                                        for additional_back in 1..32 {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(capacity + additional_front).expect("successful allocation");
                                            _ = actual.reserve_back(capacity + additional_back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, capacity + additional_front);
                                            debug_assert_eq!(actual.back_capacity, capacity + additional_back);

                                            let allocation = actual.buffer;

                                            _ = actual.reserve_front(capacity).expect("already enough capacity");

                                            assert_eq!(actual.buffer, allocation);
                                        }
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_front_many_elements_can_be_prepended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional_front in 1..32 {
                                        for additional_back in 1..32 {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(capacity + additional_front).expect("successful allocation");
                                            _ = actual.reserve_back(capacity + additional_back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, capacity + additional_front);
                                            debug_assert_eq!(actual.back_capacity, capacity + additional_back);

                                            _ = actual.reserve_front(capacity).expect("already enough capacity");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..(capacity + additional_front) {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.prepend(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_back_many_elements_can_be_appended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional_front in 1..32 {
                                        for additional_back in 1..32 {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(capacity + additional_front).expect("successful allocation");
                                            _ = actual.reserve_back(capacity + additional_back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, capacity + additional_front);
                                            debug_assert_eq!(actual.back_capacity, capacity + additional_back);

                                            _ = actual.reserve_front(capacity).expect("already enough capacity");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..(capacity + additional_back) {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.append(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_both_front_many_elements_can_be_prepended_and_back_many_elements_can_be_appended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional_front in 1..32 {
                                        for additional_back in 1..32 {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(capacity + additional_front).expect("successful allocation");
                                            _ = actual.reserve_back(capacity + additional_back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, capacity + additional_front);
                                            debug_assert_eq!(actual.back_capacity, capacity + additional_back);

                                            _ = actual.reserve_front(capacity).expect("already enough capacity");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..(capacity + additional_front) {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.prepend(usize::MAX).expect("uses capacity");
                                            }

                                            for _ in 0..(capacity + additional_back) {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.append(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        mod reserve_back {
            use super::*;

            mod when_no_capacity {
                use super::*;

                mod when_zero_requested {
                    use super::*;

                    mod when_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_capacity() {
                            let mut actual = Dynamic::<usize>::default();

                            debug_assert_eq!(actual.initialized, 0);
                            debug_assert_eq!(actual.front_capacity, 0);
                            debug_assert_eq!(actual.back_capacity, 0);

                            _ = actual.reserve_back(0).expect("does no allocation");

                            assert_eq!(actual.capacity(), 0);
                        }

                        #[test]
                        fn then_does_not_initialize_elements() {
                            let mut actual = Dynamic::<usize>::default();

                            debug_assert_eq!(actual.initialized, 0);
                            debug_assert_eq!(actual.front_capacity, 0);
                            debug_assert_eq!(actual.back_capacity, 0);

                            _ = actual.reserve_back(0).expect("does no allocation");

                            assert_eq!(actual.initialized, 0);
                        }
                    }

                    mod when_not_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_front_capacity() {
                            for elements in 1..32 {
                                let mut actual: Dynamic<_> = (0..elements).collect();

                                debug_assert_eq!(actual.initialized, elements);
                                debug_assert_eq!(actual.front_capacity, 0);
                                debug_assert_eq!(actual.back_capacity, 0);

                                _ = actual.reserve_back(0).expect("already enough capacity");

                                assert_eq!(actual.front_capacity, 0);
                            }
                        }

                        #[test]
                        fn then_does_not_modify_back_capacity() {
                            for elements in 1..32 {
                                let mut actual: Dynamic<_> = (0..elements).collect();

                                debug_assert_eq!(actual.initialized, elements);
                                debug_assert_eq!(actual.front_capacity, 0);
                                debug_assert_eq!(actual.back_capacity, 0);

                                _ = actual.reserve_back(0).expect("already enough capacity");

                                assert_eq!(actual.back_capacity, 0);
                            }
                        }

                        #[test]
                        fn then_does_not_modify_initialized_elements() {
                            for elements in 1..32 {
                                let expected = 0..elements;

                                let mut actual: Dynamic<_> = expected.clone().collect();

                                debug_assert_eq!(actual.initialized, elements);
                                debug_assert_eq!(actual.front_capacity, 0);
                                debug_assert_eq!(actual.back_capacity, 0);

                                _ = actual.reserve_back(0).expect("already enough capacity");

                                assert!(actual.eq(expected));
                            }
                        }
                    }
                }

                mod when_more_than_zero_requested {
                    use super::*;

                    mod when_empty {
                        use super::*;

                        #[test]
                        fn when_zero_size_type_then_can_allocate_maximum_possible_amount() {
                            let mut actual = Dynamic::<()>::default();

                            debug_assert_eq!(actual.initialized, 0);
                            debug_assert_eq!(actual.front_capacity, 0);
                            debug_assert_eq!(actual.back_capacity, 0);

                            _ = actual.reserve_back(isize::MAX as usize).expect("ZSTs do not occupy memory");

                            assert_eq!(actual.capacity(), isize::MAX as usize);
                        }

                        #[test]
                        fn then_increases_capacity_to_exactly_requested() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, 0);
                                debug_assert_eq!(actual.back_capacity, 0);

                                _ = actual.reserve_back(capacity).expect("successful allocation");

                                assert_eq!(actual.capacity(), capacity);
                            }
                        }

                        #[test]
                        fn then_does_not_initialize_elements() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, 0);
                                debug_assert_eq!(actual.back_capacity, 0);

                                _ = actual.reserve_back(capacity).expect("successful allocation");

                                assert_eq!(actual.initialized, 0);
                            }
                        }

                        #[test]
                        fn that_many_elements_can_be_appended_without_reallocation() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, 0);
                                debug_assert_eq!(actual.back_capacity, 0);

                                _ = actual.reserve_back(capacity).expect("successful allocation");

                                let allocation = actual.buffer;

                                for element in 0..capacity {
                                    _ = actual.append(element).expect("uses capacity");
                                }

                                assert_eq!(actual.buffer, allocation);
                            }
                        }
                    }

                    mod when_not_empty {
                        use super::*;

                        #[test]
                        fn when_zero_size_type_then_can_allocate_maximum_possible_amount() {
                            for elements in 1..32 {
                                let mut actual: Dynamic<_> = core::iter::repeat_n((), elements).collect();

                                debug_assert_eq!(actual.initialized, elements);
                                debug_assert_eq!(actual.front_capacity, 0);
                                debug_assert_eq!(actual.back_capacity, 0);

                                _ = actual.reserve_back(isize::MAX as usize - elements).expect("ZSTs do not occupy memory");

                                assert_eq!(actual.back_capacity, isize::MAX as usize - elements);
                            }
                        }

                        #[test]
                        fn then_does_not_modify_front_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let mut actual: Dynamic<_> = (0..elements).collect();

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    assert_eq!(actual.front_capacity, 0);
                                }
                            }
                        }

                        #[test]
                        fn then_increases_back_capacity_to_exactly_requested() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let mut actual: Dynamic<_> = (0..elements).collect();

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    assert_eq!(actual.back_capacity, capacity);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_initialized_elements() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let expected = 0..elements;

                                    let mut actual: Dynamic<_> = expected.clone().collect();

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    assert!(actual.eq(expected));
                                }
                            }
                        }

                        #[test]
                        fn then_requested_many_elements_can_be_appended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let expected = 0..elements;

                                    let mut actual: Dynamic<_> = expected.clone().collect();

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                    for _ in 0..capacity {
                                        // NOTE: this is distinct from the expected values.
                                        _ = actual.append(usize::MAX).expect("uses capacity");
                                    }

                                    assert!(pointers.iter().copied().eq(expected));
                                }
                            }
                        }
                    }
                }
            }

            mod when_only_front_capacity {
                use super::*;

                mod when_zero_requested {
                    use super::*;

                    mod when_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_capacity() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_front(capacity).expect("successful allocation");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, capacity);
                                debug_assert_eq!(actual.back_capacity, 0);

                                _ = actual.reserve_back(0).expect("already enough capacity");

                                assert_eq!(actual.capacity(), capacity);
                            }
                        }

                        #[test]
                        fn then_does_not_initialize_elements() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_front(capacity).expect("successful allocation");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, capacity);
                                debug_assert_eq!(actual.back_capacity, 0);

                                _ = actual.reserve_back(0).expect("already enough capacity");

                                assert_eq!(actual.initialized, 0);
                            }
                        }

                        #[test]
                        fn then_does_not_reallocate_memory() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_front(capacity).expect("successful allocation");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, capacity);
                                debug_assert_eq!(actual.back_capacity, 0);

                                let allocation = actual.buffer;

                                _ = actual.reserve_back(0).expect("already enough capacity");

                                assert_eq!(actual.buffer, allocation);
                            }
                        }

                        #[test]
                        fn then_capacity_many_elements_can_be_prepended_without_reallocating_memory() {
                            for capacity in 0..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_front(capacity).expect("successful allocation");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, capacity);
                                debug_assert_eq!(actual.back_capacity, 0);

                                _ = actual.reserve_back(0).expect("already enough capacity");

                                let allocation = actual.buffer;

                                for element in 0..capacity {
                                    _ = actual.prepend(element).expect("uses capacity");
                                }

                                assert_eq!(actual.buffer, allocation);
                            }
                        }
                    }

                    mod when_not_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_front_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let mut actual: Dynamic<_> = (0..elements).collect();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.reserve_back(0).expect("already enough capacity");

                                    assert_eq!(actual.front_capacity, capacity);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_back_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let mut actual: Dynamic<_> = (0..elements).collect();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.reserve_back(0).expect("already enough capacity");

                                    assert_eq!(actual.back_capacity, 0);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_initialized_elements() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let expected = 0..elements;

                                    let mut actual: Dynamic<_> = expected.clone().collect();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.reserve_back(0).expect("already enough capacity");

                                    assert!(actual.eq(expected));
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_reallocate_memory() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let mut actual: Dynamic<_> = (0..elements).collect();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    let allocation = actual.buffer;

                                    _ = actual.reserve_back(0).expect("already enough capacity");

                                    assert_eq!(actual.buffer, allocation);
                                }
                            }
                        }

                        #[test]
                        fn then_capacity_many_elements_can_be_prepended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for capacity in 0..32 {
                                    let expected = 0..elements;

                                    let mut actual: Dynamic<_> = expected.clone().collect();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.reserve_back(0).expect("already enough capacity");

                                    let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                    for _ in 0..capacity {
                                        // NOTE: this is distinct from the expected values.
                                        _ = actual.prepend(usize::MAX).expect("uses capacity");
                                    }

                                    assert!(pointers.iter().copied().eq(expected));
                                }
                            }
                        }
                    }
                }

                mod when_less_than_requested {
                    use super::*;

                    mod when_empty {
                        use super::*;

                        #[test]
                        fn when_zero_size_type_then_can_allocate_maximum_possible_amount() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<()>::default();

                                _ = actual.reserve_front(capacity).expect("successful allocation");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, capacity);
                                debug_assert_eq!(actual.back_capacity, 0);

                                _ = actual.reserve_back(isize::MAX as usize).expect("ZSTs do not occupy memory");

                                assert_eq!(actual.capacity(), isize::MAX as usize);
                            }
                        }

                        #[test]
                        fn then_increases_capacity_to_exactly_requested() {
                            for capacity in 1..32 {
                                for additional in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.reserve_back(capacity + additional).expect("successful allocation");

                                    assert_eq!(actual.capacity(), capacity + additional);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_initialize_elements() {
                            for capacity in 1..32 {
                                for additional in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.reserve_back(capacity + additional).expect("successful allocation");

                                    assert_eq!(actual.initialized, 0);
                                }
                            }
                        }

                        #[test]
                        fn then_capacity_many_elements_can_be_appended_without_reallocating_memory() {
                            for capacity in 1..32 {
                                for additional in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.reserve_back(capacity + additional).expect("successful allocation");

                                    let allocation = actual.buffer;

                                    for element in 0..(capacity + additional) {
                                        _ = actual.append(element).expect("uses capacity");
                                    }

                                    assert_eq!(actual.buffer, allocation);
                                }
                            }
                        }
                    }

                    mod when_not_empty {
                        use super::*;

                        #[test]
                        fn when_zero_size_type_then_can_allocate_maximum_possible_amount() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let mut actual: Dynamic<_> = core::iter::repeat_n((), elements).collect();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.reserve_back(isize::MAX as usize - elements - capacity).expect("ZSTs do not occupy memory");

                                    assert_eq!(actual.back_capacity, isize::MAX as usize - elements - capacity);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_front_capacity() {
                            for elements in 1..32 {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        let mut actual: Dynamic<_> = (0..elements).collect();

                                        _ = actual.reserve_front(front).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, 0);

                                        _ = actual.reserve_back(back).expect("successful allocation");

                                        assert_eq!(actual.front_capacity, front);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_increases_back_capacity_to_exactly_requested() {
                            for elements in 1..32 {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        let mut actual: Dynamic<_> = (0..elements).collect();

                                        _ = actual.reserve_front(front).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, 0);

                                        _ = actual.reserve_back(back).expect("successful allocation");

                                        assert_eq!(actual.back_capacity, back);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_initialized_elements() {
                            for elements in 1..32 {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        let expected = 0..elements;

                                        let mut actual: Dynamic<_> = expected.clone().collect();

                                        _ = actual.reserve_front(front).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, 0);

                                        _ = actual.reserve_back(back).expect("successful allocation");

                                        assert!(actual.eq(expected));
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_capacity_many_elements_can_be_prepended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        let expected = 0..elements;

                                        let mut actual: Dynamic<_> = expected.clone().collect();

                                        _ = actual.reserve_front(front).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, 0);

                                        _ = actual.reserve_back(back).expect("successful allocation");

                                        let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                        for _ in 0..front {
                                            // NOTE: this is distinct from the expected values.
                                            _ = actual.prepend(usize::MAX).expect("uses capacity");
                                        }

                                        assert!(pointers.iter().copied().eq(expected));
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_requested_many_elements_can_be_appended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        let expected = 0..elements;

                                        let mut actual: Dynamic<_> = expected.clone().collect();

                                        _ = actual.reserve_front(front).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, 0);

                                        _ = actual.reserve_back(back).expect("successful allocation");

                                        let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                        for _ in 0..back {
                                            // NOTE: this is distinct from the expected values.
                                            _ = actual.append(usize::MAX).expect("uses capacity");
                                        }

                                        assert!(pointers.iter().copied().eq(expected));
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_both_capacity_many_elements_can_be_prepended_and_requested_many_elements_can_be_appended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        let expected = 0..elements;

                                        let mut actual: Dynamic<_> = expected.clone().collect();

                                        _ = actual.reserve_front(front).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, 0);

                                        _ = actual.reserve_back(back).expect("successful allocation");

                                        let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                        for _ in 0..front {
                                            // NOTE: this is distinct from the expected values.
                                            _ = actual.prepend(usize::MAX).expect("uses capacity");
                                        }

                                        for _ in 0..back {
                                            // NOTE: this is distinct from the expected values.
                                            _ = actual.append(usize::MAX).expect("uses capacity");
                                        }

                                        assert!(pointers.iter().copied().eq(expected));
                                    }
                                }
                            }
                        }
                    }
                }

                mod when_exactly_requested {
                    use super::*;

                    mod when_empty {
                        use super::*;

                        #[test]
                        fn when_zero_size_type_then_can_allocate_maximum_possible_amount() {
                            let mut actual = Dynamic::<()>::default();

                            _ = actual.reserve_front(isize::MAX as usize).expect("successful allocation");

                            debug_assert_eq!(actual.initialized, 0);
                            debug_assert_eq!(actual.front_capacity, isize::MAX as usize);
                            debug_assert_eq!(actual.back_capacity, 0);

                            _ = actual.reserve_back(isize::MAX as usize).expect("ZSTs do not occupy memory");

                            assert_eq!(actual.capacity(), isize::MAX as usize);
                        }

                        #[test]
                        fn then_does_not_modify_capacity() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_front(capacity).expect("successful allocation");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, capacity);
                                debug_assert_eq!(actual.back_capacity, 0);

                                _ = actual.reserve_back(capacity).expect("already enough capacity");

                                assert_eq!(actual.capacity(), capacity);
                            }
                        }

                        #[test]
                        fn then_does_not_initialize_elements() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_front(capacity).expect("successful allocation");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, capacity);
                                debug_assert_eq!(actual.back_capacity, 0);

                                _ = actual.reserve_back(capacity).expect("already enough capacity");

                                assert_eq!(actual.initialized, 0);
                            }
                        }

                        #[test]
                        fn then_does_not_reallocate_memory() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_front(capacity).expect("successful allocation");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, capacity);
                                debug_assert_eq!(actual.back_capacity, 0);

                                let allocation = actual.buffer;

                                _ = actual.reserve_back(capacity).expect("already enough capacity");

                                assert_eq!(actual.buffer, allocation);
                            }
                        }

                        #[test]
                        fn then_requested_many_elements_can_be_appended_without_reallocating_memory() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_front(capacity).expect("successful allocation");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, capacity);
                                debug_assert_eq!(actual.back_capacity, 0);

                                _ = actual.reserve_back(capacity).expect("already enough capacity");

                                let allocation = actual.buffer;

                                for element in 0..capacity {
                                    _ = actual.append(element).expect("uses capacity");
                                }

                                assert_eq!(actual.buffer, allocation);
                            }
                        }
                    }

                    mod when_not_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_front_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let mut actual: Dynamic<_> = (0..elements).collect();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    assert_eq!(actual.front_capacity, capacity);
                                }
                            }
                        }

                        #[test]
                        fn then_increases_back_capacity_to_exactly_requested() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let mut actual: Dynamic<_> = (0..elements).collect();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    assert_eq!(actual.back_capacity, capacity);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_initialized_elements() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let expected = 0..elements;

                                    let mut actual: Dynamic<_> = expected.clone().collect();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    assert!(actual.eq(expected));
                                }
                            }
                        }

                        #[test]
                        fn then_capacity_many_elements_can_be_prepended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let expected = 0..elements;

                                    let mut actual: Dynamic<_> = expected.clone().collect();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                    for _ in 0..capacity {
                                        // NOTE: this is distinct from the expected values.
                                        _ = actual.prepend(usize::MAX).expect("uses capacity");
                                    }

                                    assert!(pointers.iter().copied().eq(expected));
                                }
                            }
                        }

                        #[test]
                        fn then_requested_many_elements_can_be_appended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let expected = 0..elements;

                                    let mut actual: Dynamic<_> = expected.clone().collect();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                    for _ in 0..capacity {
                                        // NOTE: this is distinct from the expected values.
                                        _ = actual.append(usize::MAX).expect("uses capacity");
                                    }

                                    assert!(pointers.iter().copied().eq(expected));
                                }
                            }
                        }

                        #[test]
                        fn then_both_capacity_many_elements_can_be_prepended_and_requested_many_elements_can_be_appended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let expected = 0..elements;

                                    let mut actual: Dynamic<_> = expected.clone().collect();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                    for _ in 0..capacity {
                                        // NOTE: this is distinct from the expected values.
                                        _ = actual.prepend(usize::MAX).expect("uses capacity");
                                    }

                                    for _ in 0..capacity {
                                        // NOTE: this is distinct from the expected values.
                                        _ = actual.append(usize::MAX).expect("uses capacity");
                                    }

                                    assert!(pointers.iter().copied().eq(expected));
                                }
                            }
                        }
                    }
                }

                mod when_more_than_requested {
                    use super::*;

                    mod when_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_capacity() {
                            for capacity in 1..32 {
                                for additional in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_front(capacity + additional).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, capacity + additional);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.reserve_back(capacity).expect("already enough capacity");

                                    assert_eq!(actual.capacity(), capacity + additional);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_initialize_elements() {
                            for capacity in 1..32 {
                                for additional in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_front(capacity + additional).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, capacity + additional);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.reserve_back(capacity).expect("already enough capacity");

                                    assert_eq!(actual.initialized, 0);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_reallocate_memory() {
                            for capacity in 1..32 {
                                for additional in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_front(capacity + additional).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, capacity + additional);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    let allocation = actual.buffer;

                                    _ = actual.reserve_back(capacity).expect("already enough capacity");

                                    assert_eq!(actual.buffer, allocation);
                                }
                            }
                        }

                        #[test]
                        fn then_capacity_many_elements_can_be_prepended_without_reallocating_memory() {
                            for capacity in 1..32 {
                                for additional in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_front(capacity + additional).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, capacity + additional);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    let allocation = actual.buffer;

                                    _ = actual.reserve_back(capacity).expect("already enough capacity");

                                    for element in 0..(capacity + additional) {
                                        _ = actual.prepend(element).expect("uses capacity");
                                    }

                                    assert_eq!(actual.buffer, allocation);
                                }
                            }
                        }
                    }

                    mod when_not_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_front_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let mut actual: Dynamic<_> = (0..elements).collect();

                                        _ = actual.reserve_front(capacity + additional);

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, capacity + additional);
                                        debug_assert_eq!(actual.back_capacity, 0);

                                        _ = actual.reserve_back(capacity).expect("successful allocation");

                                        assert_eq!(actual.front_capacity, capacity + additional);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_increases_back_capacity_to_exactly_requested() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let mut actual: Dynamic<_> = (0..elements).collect();

                                        _ = actual.reserve_front(capacity + additional);

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, capacity + additional);
                                        debug_assert_eq!(actual.back_capacity, 0);

                                        _ = actual.reserve_back(capacity).expect("successful allocation");

                                        assert_eq!(actual.back_capacity, capacity);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_initialized_elements() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let expected = 0..elements;

                                        let mut actual: Dynamic<_> = expected.clone().collect();

                                        _ = actual.reserve_front(capacity + additional);

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, capacity + additional);
                                        debug_assert_eq!(actual.back_capacity, 0);

                                        _ = actual.reserve_back(capacity).expect("successful allocation");

                                        assert!(actual.eq(expected));
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_capacity_many_elements_can_be_prepended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let expected = 0..elements;

                                        let mut actual: Dynamic<_> = expected.clone().collect();

                                        _ = actual.reserve_front(capacity + additional);

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, capacity + additional);
                                        debug_assert_eq!(actual.back_capacity, 0);

                                        _ = actual.reserve_back(capacity).expect("successful allocation");

                                        let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                        for _ in 0..(capacity + additional) {
                                            // NOTE: this is distinct from the expected values.
                                            _ = actual.prepend(usize::MAX).expect("uses capacity");
                                        }

                                        assert!(pointers.iter().copied().eq(expected));
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_requested_many_elements_can_be_appended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let expected = 0..elements;

                                        let mut actual: Dynamic<_> = expected.clone().collect();

                                        _ = actual.reserve_front(capacity + additional);

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, capacity + additional);
                                        debug_assert_eq!(actual.back_capacity, 0);

                                        _ = actual.reserve_back(capacity).expect("successful allocation");

                                        let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                        for _ in 0..capacity {
                                            // NOTE: this is distinct from the expected values.
                                            _ = actual.append(usize::MAX).expect("uses capacity");
                                        }

                                        assert!(pointers.iter().copied().eq(expected));
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_both_capacity_many_elements_can_be_prepended_and_requested_many_elements_can_be_appended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let expected = 0..elements;

                                        let mut actual: Dynamic<_> = expected.clone().collect();

                                        _ = actual.reserve_front(capacity + additional);

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, capacity + additional);
                                        debug_assert_eq!(actual.back_capacity, 0);

                                        _ = actual.reserve_back(capacity).expect("successful allocation");

                                        let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                        for _ in 0..(capacity + additional) {
                                            // NOTE: this is distinct from the expected values.
                                            _ = actual.prepend(usize::MAX).expect("uses capacity");
                                        }

                                        for _ in 0..capacity {
                                            // NOTE: this is distinct from the expected values.
                                            _ = actual.append(usize::MAX).expect("uses capacity");
                                        }

                                        assert!(pointers.iter().copied().eq(expected));
                                    }
                                }
                            }
                        }
                    }
                }
            }

            mod when_only_back_capacity {
                use super::*;

                mod when_zero_requested {
                    use super::*;

                    mod when_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_capacity() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_back(capacity).expect("successful allocation");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, 0);
                                debug_assert_eq!(actual.back_capacity, capacity);

                                _ = actual.reserve_back(0).expect("already enough capacity");

                                assert_eq!(actual.capacity(), capacity);
                            }
                        }

                        #[test]
                        fn then_does_not_initialize_elements() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_back(capacity).expect("successful allocation");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, 0);
                                debug_assert_eq!(actual.back_capacity, capacity);

                                _ = actual.reserve_back(0).expect("already enough capacity");

                                assert_eq!(actual.initialized, 0);
                            }
                        }

                        #[test]
                        fn then_does_not_reallocate_memory() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_back(capacity).expect("successful allocation");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, 0);
                                debug_assert_eq!(actual.back_capacity, capacity);

                                let allocation = actual.buffer;

                                _ = actual.reserve_back(0).expect("already enough capacity");

                                assert_eq!(actual.buffer, allocation);
                            }
                        }

                        #[test]
                        fn then_capacity_many_elements_can_be_appended_without_reallocating_memory() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_back(capacity).expect("successful allocation");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, 0);
                                debug_assert_eq!(actual.back_capacity, capacity);

                                _ = actual.reserve_back(0).expect("already enough capacity");

                                let allocation = actual.buffer;

                                for element in 0..capacity {
                                    _ = actual.append(element).expect("uses capacity");
                                }

                                assert_eq!(actual.buffer, allocation);
                            }
                        }
                    }

                    mod when_not_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_front_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let mut actual: Dynamic<_> = (0..elements).collect();

                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    _ = actual.reserve_back(0).expect("already enough capacity");

                                    assert_eq!(actual.front_capacity, 0);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_decrease_back_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let mut actual: Dynamic<_> = (0..elements).collect();

                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    _ = actual.reserve_back(0).expect("already enough capacity");

                                    assert_eq!(actual.back_capacity, capacity);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_initialized_elements() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let expected = 0..elements;

                                    let mut actual: Dynamic<_> = expected.clone().collect();

                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    _ = actual.reserve_back(0).expect("already enough capacity");

                                    assert!(actual.eq(expected));
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_reallocate_memory() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let mut actual: Dynamic<_> = (0..elements).collect();

                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    let allocation = actual.buffer;

                                    _ = actual.reserve_back(0).expect("already enough capacity");

                                    assert_eq!(actual.buffer, allocation);
                                }
                            }
                        }

                        #[test]
                        fn then_capacity_many_elements_can_be_appended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let expected = 0..elements;

                                    let mut actual: Dynamic<_> = expected.clone().collect();

                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    _ = actual.reserve_back(0).expect("already enough capacity");

                                    let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                    for _ in 0..capacity {
                                        // NOTE: this is distinct from the expected values.
                                        _ = actual.append(usize::MAX).expect("uses capacity");
                                    }

                                    assert!(pointers.iter().copied().eq(expected));
                                }
                            }
                        }
                    }
                }

                mod when_less_than_requested {
                    use super::*;

                    mod when_empty {
                        use super::*;

                        #[test]
                        fn when_zero_size_type_then_can_allocate_maximum_possible_amount() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<()>::default();

                                _ = actual.reserve_back(capacity).expect("successful allocation");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, 0);
                                debug_assert_eq!(actual.back_capacity, capacity);

                                _ = actual.reserve_back(isize::MAX as usize).expect("ZSTs do not occupy memory");

                                assert_eq!(actual.capacity(), isize::MAX as usize);
                            }
                        }

                        #[test]
                        fn then_increases_capacity_to_exactly_requested() {
                            for capacity in 1..32 {
                                for additional in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    _ = actual.reserve_back(capacity + additional).expect("successful allocation");

                                    assert_eq!(actual.capacity(), capacity + additional);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_initialize_elements() {
                            for capacity in 1..32 {
                                for additional in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    _ = actual.reserve_back(capacity + additional).expect("successful allocation");

                                    assert_eq!(actual.initialized, 0);
                                }
                            }
                        }

                        #[test]
                        fn then_requested_many_elements_can_be_appended_without_reallocating_memory() {
                            for capacity in 1..32 {
                                for additional in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    _ = actual.reserve_back(capacity + additional).expect("successful allocation");

                                    let allocation = actual.buffer;

                                    for element in 0..(capacity + additional) {
                                        _ = actual.append(element).expect("uses capacity");
                                    }

                                    assert_eq!(actual.buffer, allocation);
                                }
                            }
                        }
                    }

                    mod when_not_empty {
                        use super::*;

                        #[test]
                        fn when_zero_size_type_then_can_allocate_maximum_possible_amount() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let mut actual: Dynamic<_> = core::iter::repeat_n((), elements).collect();

                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    _ = actual.reserve_back(isize::MAX as usize - elements).expect("ZSTs do not occupy memory");

                                    assert_eq!(actual.back_capacity, isize::MAX as usize - elements);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_front_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let mut actual: Dynamic<_> = (0..elements).collect();

                                        _ = actual.reserve_back(capacity).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, 0);
                                        debug_assert_eq!(actual.back_capacity, capacity);

                                        _ = actual.reserve_back(capacity + additional).expect("successful allocation");

                                        assert_eq!(actual.front_capacity, 0);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_increases_back_capacity_to_exactly_requested() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let mut actual: Dynamic<_> = (0..elements).collect();

                                        _ = actual.reserve_back(capacity).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, 0);
                                        debug_assert_eq!(actual.back_capacity, capacity);

                                        _ = actual.reserve_back(capacity + additional).expect("successful allocation");

                                        assert_eq!(actual.back_capacity, capacity + additional);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_initialized_elements() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let expected = 0..elements;

                                        let mut actual: Dynamic<_> = expected.clone().collect();

                                        _ = actual.reserve_back(capacity).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, 0);
                                        debug_assert_eq!(actual.back_capacity, capacity);

                                        _ = actual.reserve_back(capacity + additional).expect("already enough capacity");

                                        assert!(actual.eq(expected));
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_requested_many_elements_can_be_appended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let expected = 0..elements;

                                        let mut actual: Dynamic<_> = expected.clone().collect();

                                        _ = actual.reserve_back(capacity).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, 0);
                                        debug_assert_eq!(actual.back_capacity, capacity);

                                        _ = actual.reserve_back(capacity + additional).expect("already enough capacity");

                                        let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                        for _ in 0..(capacity + additional) {
                                            // NOTE: this is distinct from the expected values.
                                            _ = actual.append(usize::MAX).expect("uses capacity");
                                        }

                                        assert!(pointers.iter().copied().eq(expected));
                                    }
                                }
                            }
                        }
                    }
                }

                mod when_exactly_requested {
                    use super::*;

                    mod when_empty {
                        use super::*;

                        #[test]
                        fn when_zero_size_type_then_can_allocate_maximum_possible_amount() {
                            let mut actual = Dynamic::<()>::default();

                            _ = actual.reserve_back(isize::MAX as usize).expect("successful allocation");

                            debug_assert_eq!(actual.initialized, 0);
                            debug_assert_eq!(actual.front_capacity, 0);
                            debug_assert_eq!(actual.back_capacity, isize::MAX as usize);

                            _ = actual.reserve_back(isize::MAX as usize).expect("ZSTs do not occupy memory");

                            assert_eq!(actual.capacity(), isize::MAX as usize);
                        }

                        #[test]
                        fn then_does_not_modify_capacity() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_back(capacity).expect("successful allocation");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, 0);
                                debug_assert_eq!(actual.back_capacity, capacity);

                                _ = actual.reserve_back(capacity).expect("already enough capacity");

                                assert_eq!(actual.capacity(), capacity);
                            }
                        }

                        #[test]
                        fn then_does_not_initialize_elements() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_back(capacity).expect("successful allocation");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, 0);
                                debug_assert_eq!(actual.back_capacity, capacity);

                                _ = actual.reserve_back(capacity).expect("already enough capacity");

                                assert_eq!(actual.initialized, 0);
                            }
                        }

                        #[test]
                        fn then_does_not_reallocate_memory() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_back(capacity).expect("successful allocation");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, 0);
                                debug_assert_eq!(actual.back_capacity, capacity);

                                let allocation = actual.buffer;

                                _ = actual.reserve_back(capacity).expect("already enough capacity");

                                assert_eq!(actual.buffer, allocation);
                            }
                        }

                        #[test]
                        fn then_requested_many_elements_can_be_appended_without_reallocating_memory() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_back(capacity).expect("successful allocation");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, 0);
                                debug_assert_eq!(actual.back_capacity, capacity);

                                _ = actual.reserve_back(capacity).expect("already enough capacity");

                                let allocation = actual.buffer;

                                for element in 0..capacity {
                                    _ = actual.append(element).expect("uses capacity");
                                }

                                assert_eq!(actual.buffer, allocation);
                            }
                        }
                    }

                    mod when_not_empty {
                        use super::*;

                        #[test]
                        fn when_zero_size_type_then_can_allocate_maximum_possible_amount() {
                            for elements in 1..32 {
                                let mut actual: Dynamic<_> = core::iter::repeat_n((), elements).collect();

                                _ = actual.reserve_back(isize::MAX as usize - elements).expect("successful allocation");

                                debug_assert_eq!(actual.initialized, elements);
                                debug_assert_eq!(actual.front_capacity, 0);
                                debug_assert_eq!(actual.back_capacity, isize::MAX as usize - elements);

                                _ = actual.reserve_back(isize::MAX as usize - elements).expect("ZSTs do not occupy memory");

                                assert_eq!(actual.back_capacity, isize::MAX as usize - elements);
                            }
                        }

                        #[test]
                        fn then_does_not_modify_front_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let mut actual: Dynamic<_> = (0..elements).collect();

                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    _ = actual.reserve_back(capacity).expect("already enough capacity");

                                    assert_eq!(actual.front_capacity, 0);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_back_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let mut actual: Dynamic<_> = (0..elements).collect();

                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    _ = actual.reserve_back(capacity).expect("already enough capacity");

                                    assert_eq!(actual.back_capacity, capacity);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_initialized_elements() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let expected = 0..elements;

                                    let mut actual: Dynamic<_> = expected.clone().collect();

                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    _ = actual.reserve_back(capacity).expect("already enough capacity");

                                    assert!(actual.eq(expected));
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_reallocate_memory() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let mut actual: Dynamic<_> = (0..elements).collect();

                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    let allocation = actual.buffer;

                                    _ = actual.reserve_back(capacity).expect("already enough capacity");

                                    assert_eq!(actual.buffer, allocation);
                                }
                            }
                        }

                        #[test]
                        fn then_requested_many_elements_can_be_appended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let expected = 0..elements;

                                    let mut actual: Dynamic<_> = expected.clone().collect();

                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    _ = actual.reserve_back(capacity).expect("already enough capacity");

                                    let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                    for _ in 0..capacity {
                                        // NOTE: this is distinct from the expected values.
                                        _ = actual.append(usize::MAX).expect("uses capacity");
                                    }

                                    assert!(pointers.iter().copied().eq(expected));
                                }
                            }
                        }
                    }
                }

                mod when_more_than_requested {
                    use super::*;

                    mod when_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_capacity() {
                            for capacity in 1..32 {
                                for additional in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_back(capacity + additional).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, capacity + additional);

                                    _ = actual.reserve_back(capacity).expect("already enough capacity");

                                    assert_eq!(actual.capacity(), capacity + additional);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_initialize_elements() {
                            for capacity in 1..32 {
                                for additional in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_back(capacity + additional).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, capacity + additional);

                                    _ = actual.reserve_back(capacity).expect("already enough capacity");

                                    assert_eq!(actual.initialized, 0);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_reallocate_memory() {
                            for capacity in 1..32 {
                                for additional in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_back(capacity + additional).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, capacity + additional);

                                    let allocation = actual.buffer;

                                    _ = actual.reserve_back(capacity).expect("already enough capacity");

                                    assert_eq!(actual.buffer, allocation);
                                }
                            }
                        }

                        #[test]
                        fn then_capacity_many_elements_can_be_appended_without_reallocating_memory() {
                            for capacity in 1..32 {
                                for additional in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_back(capacity + additional).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, capacity + additional);

                                    _ = actual.reserve_back(capacity).expect("already enough capacity");

                                    let allocation = actual.buffer;

                                    for element in 0..(capacity + additional) {
                                        _ = actual.append(element).expect("uses capacity");
                                    }

                                    assert_eq!(actual.buffer, allocation);
                                }
                            }
                        }
                    }

                    mod when_not_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_front_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let mut actual: Dynamic<_> = (0..elements).collect();

                                        _ = actual.reserve_back(capacity + additional).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, 0);
                                        debug_assert_eq!(actual.back_capacity, capacity + additional);

                                        _ = actual.reserve_back(capacity).expect("already enough capacity");

                                        assert_eq!(actual.front_capacity, 0);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_decrease_back_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let mut actual: Dynamic<_> = (0..elements).collect();

                                        _ = actual.reserve_back(capacity + additional).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, 0);
                                        debug_assert_eq!(actual.back_capacity, capacity + additional);

                                        _ = actual.reserve_back(capacity).expect("already enough capacity");

                                        assert_eq!(actual.back_capacity, capacity + additional);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_initialized_elements() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let expected = 0..elements;

                                        let mut actual: Dynamic<_> = expected.clone().collect();

                                        _ = actual.reserve_back(capacity + additional).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, 0);
                                        debug_assert_eq!(actual.back_capacity, capacity + additional);

                                        _ = actual.reserve_back(capacity).expect("already enough capacity");

                                        assert!(actual.eq(expected));
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_reallocate_memory() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let mut actual: Dynamic<_> = (0..elements).collect();

                                        _ = actual.reserve_back(capacity + additional).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, 0);
                                        debug_assert_eq!(actual.back_capacity, capacity + additional);

                                        let allocation = actual.buffer;

                                        _ = actual.reserve_back(capacity).expect("already enough capacity");

                                        assert_eq!(actual.buffer, allocation);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_capacity_many_elements_can_be_appended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let expected = 0..elements;

                                        let mut actual: Dynamic<_> = expected.clone().collect();

                                        _ = actual.reserve_back(capacity + additional).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, 0);
                                        debug_assert_eq!(actual.back_capacity, capacity + additional);

                                        _ = actual.reserve_back(capacity).expect("already enough capacity");

                                        let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                        for _ in 0..(capacity + additional) {
                                            // NOTE: this is distinct from the expected values.
                                            _ = actual.append(usize::MAX).expect("uses capacity");
                                        }

                                        assert!(pointers.iter().copied().eq(expected));
                                    }
                                }
                            }
                        }
                    }
                }
            }

            mod when_both_front_and_back_capacity {
                use super::*;

                mod when_zero_requested {
                    use super::*;

                    mod when_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_capacity() {
                            for front in 1..32 {
                                for back in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_back(front + back).expect("successful allocation");

                                    _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, front);
                                    debug_assert_eq!(actual.back_capacity, back);

                                    _ = actual.reserve_back(0).expect("already enough capacity");

                                    assert_eq!(actual.capacity(), front + back);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_initialize_elements() {
                            for front in 1..32 {
                                for back in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_back(front + back).expect("successful allocation");

                                    _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, front);
                                    debug_assert_eq!(actual.back_capacity, back);

                                    _ = actual.reserve_back(0).expect("already enough capacity");

                                    assert_eq!(actual.initialized, 0);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_reallocate_memory() {
                            for front in 1..32 {
                                for back in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_back(front + back).expect("successful allocation");

                                    _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, front);
                                    debug_assert_eq!(actual.back_capacity, back);

                                    let allocation = actual.buffer;

                                    _ = actual.reserve_back(0).expect("already enough capacity");

                                    assert_eq!(actual.buffer, allocation);
                                }
                            }
                        }

                        #[test]
                        fn then_capacity_many_elements_can_be_appended_without_invalidating_pointers() {
                            for front in 1..32 {
                                for back in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_back(front + back).expect("successful allocation");

                                    _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, front);
                                    debug_assert_eq!(actual.back_capacity, back);

                                    _ = actual.reserve_back(0).expect("already enough capacity");

                                    let allocation = actual.buffer;

                                    for element in 0..(front + back) {
                                        _ = actual.append(element).expect("uses capacity");
                                    }

                                    assert_eq!(actual.buffer, allocation);
                                }
                            }
                        }
                    }

                    mod when_not_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_front_capacity() {
                            for elements in 1..32 {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        let mut actual: Dynamic<_> = (0..elements).collect();

                                        _ = actual.reserve_front(front).expect("successful allocation");
                                        _ = actual.reserve_back(back).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.reserve_back(0).expect("already enough capacity");

                                        assert_eq!(actual.front_capacity, front);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_back_capacity() {
                            for elements in 1..32 {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        let mut actual: Dynamic<_> = (0..elements).collect();

                                        _ = actual.reserve_front(front).expect("successful allocation");
                                        _ = actual.reserve_back(back).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.reserve_back(0).expect("already enough capacity");

                                        assert_eq!(actual.back_capacity, back);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_initialized_elements() {
                            for elements in 1..32 {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        let expected = 0..elements;

                                        let mut actual: Dynamic<_> = expected.clone().collect();

                                        _ = actual.reserve_front(front).expect("successful allocation");
                                        _ = actual.reserve_back(back).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.reserve_back(0).expect("already enough capacity");

                                        assert!(actual.eq(expected));
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_reallocate_memory() {
                            for elements in 1..32 {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        let mut actual: Dynamic<_> = (0..elements).collect();

                                        _ = actual.reserve_front(front).expect("successful allocation");
                                        _ = actual.reserve_back(back).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        let allocation = actual.buffer;

                                        _ = actual.reserve_back(0).expect("already enough capacity");

                                        assert_eq!(actual.buffer, allocation);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_front_many_elements_can_be_prepended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        let expected = 0..elements;

                                        let mut actual: Dynamic<_> = expected.clone().collect();

                                        _ = actual.reserve_front(front).expect("successful allocation");
                                        _ = actual.reserve_back(back).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.reserve_back(0).expect("already enough capacity");

                                        let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                        for _ in 0..front {
                                            // NOTE: this is distinct from the expected values.
                                            _ = actual.prepend(usize::MAX).expect("uses capacity");
                                        }

                                        assert!(pointers.iter().copied().eq(expected));
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_back_many_elements_can_be_appended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        let expected = 0..elements;

                                        let mut actual: Dynamic<_> = expected.clone().collect();

                                        _ = actual.reserve_front(front).expect("successful allocation");
                                        _ = actual.reserve_back(back).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.reserve_back(0).expect("already enough capacity");

                                        let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                        for _ in 0..back {
                                            // NOTE: this is distinct from the expected values.
                                            _ = actual.append(usize::MAX).expect("uses capacity");
                                        }

                                        assert!(pointers.iter().copied().eq(expected));
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_both_front_many_elements_can_be_prepended_and_back_many_elements_can_be_appended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        let expected = 0..elements;

                                        let mut actual: Dynamic<_> = expected.clone().collect();

                                        _ = actual.reserve_front(front).expect("successful allocation");
                                        _ = actual.reserve_back(back).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.reserve_back(0).expect("already enough capacity");

                                        let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                        for _ in 0..front {
                                            // NOTE: this is distinct from the expected values.
                                            _ = actual.prepend(usize::MAX).expect("uses capacity");
                                        }

                                        for _ in 0..back {
                                            // NOTE: this is distinct from the expected values.
                                            _ = actual.append(usize::MAX).expect("uses capacity");
                                        }

                                        assert!(pointers.iter().copied().eq(expected));
                                    }
                                }
                            }
                        }
                    }
                }

                mod when_both_less_than_requested {
                    use super::*;

                    mod when_sum_is_less_than_requested {
                        use super::*;

                        mod when_empty {
                            use super::*;

                            #[test]
                            fn when_zero_size_type_then_can_allocate_maximum_possible_amount() {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        let mut actual = Dynamic::<()>::default();

                                        _ = actual.reserve_back(front + back).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.reserve_back(isize::MAX as usize).expect("ZSTs do not occupy memory");

                                        assert_eq!(actual.capacity(), isize::MAX as usize);
                                    }
                                }
                            }

                            #[test]
                            fn then_increases_capacity_to_exactly_requested() {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        for additional in 1..32 {
                                            let mut actual = Dynamic::<usize>::default();

                                            _ = actual.reserve_back(front + back).expect("successful allocation");

                                            _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                            debug_assert_eq!(actual.initialized, 0);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.reserve_back(front + back + additional).expect("successful allocation");

                                            assert_eq!(actual.capacity(), front + back + additional);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_initialize_elements() {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        for additional in 1..32 {
                                            let mut actual = Dynamic::<usize>::default();

                                            _ = actual.reserve_back(front + back).expect("successful allocation");

                                            _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                            debug_assert_eq!(actual.initialized, 0);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.reserve_back(front + back + additional).expect("successful allocation");

                                            assert_eq!(actual.initialized, 0);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_requested_many_elements_can_be_appended_without_reallocating_memory() {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        for additional in 1..32 {
                                            let mut actual = Dynamic::<usize>::default();

                                            _ = actual.reserve_back(front + back).expect("successful allocation");

                                            _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                            debug_assert_eq!(actual.initialized, 0);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.reserve_back(front + back + additional).expect("successful allocation");

                                            let allocation = actual.buffer;

                                            for element in 0..(front + back + additional) {
                                                _ = actual.append(element).expect("uses capacity");
                                            }

                                            assert_eq!(actual.buffer, allocation);
                                        }
                                    }
                                }
                            }
                        }

                        mod when_not_empty {
                            use super::*;

                            #[test]
                            fn when_zero_size_type_then_can_allocate_maximum_possible_amount() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            let mut actual: Dynamic<_> = core::iter::repeat_n((), elements).collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.reserve_back(isize::MAX as usize - elements - front).expect("ZSTs do not occupy memory");

                                            assert_eq!(actual.capacity(), isize::MAX as usize - elements);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_modify_front_capacity() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            for additional in 1..32 {
                                                let mut actual: Dynamic<_> = (0..elements).collect();

                                                _ = actual.reserve_front(front).expect("successful allocation");
                                                _ = actual.reserve_back(back).expect("successful allocation");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front);
                                                debug_assert_eq!(actual.back_capacity, back);

                                                _ = actual.reserve_back(front + back + additional).expect("successful allocation");

                                                assert_eq!(actual.front_capacity, front);
                                            }
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_increases_back_capacity_to_exactly_requested() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            for additional in 1..32 {
                                                let mut actual: Dynamic<_> = (0..elements).collect();

                                                _ = actual.reserve_front(front).expect("successful allocation");
                                                _ = actual.reserve_back(back).expect("successful allocation");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front);
                                                debug_assert_eq!(actual.back_capacity, back);

                                                _ = actual.reserve_back(front + back + additional).expect("successful allocation");

                                                assert_eq!(actual.back_capacity, front + back + additional);
                                            }
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_modify_initialized_elements() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            for additional in 1..32 {
                                                let expected = 0..elements;

                                                let mut actual: Dynamic<_> = expected.clone().collect();

                                                _ = actual.reserve_front(front).expect("successful allocation");
                                                _ = actual.reserve_back(back).expect("successful allocation");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front);
                                                debug_assert_eq!(actual.back_capacity, back);

                                                _ = actual.reserve_back(front + back + additional).expect("successful allocation");

                                                assert!(actual.eq(expected));
                                            }
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_front_many_elements_can_be_prepended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            for additional in 1..32 {
                                                let expected = 0..elements;

                                                let mut actual: Dynamic<_> = expected.clone().collect();

                                                _ = actual.reserve_front(front).expect("successful allocation");
                                                _ = actual.reserve_back(back).expect("successful allocation");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front);
                                                debug_assert_eq!(actual.back_capacity, back);

                                                _ = actual.reserve_back(front + back + additional).expect("successful allocation");

                                                let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                                for _ in 0..front {
                                                    // NOTE: this is distinct from the expected values.
                                                    _ = actual.prepend(usize::MAX).expect("uses capacity");
                                                }

                                                assert!(pointers.iter().copied().eq(expected));
                                            }
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_requested_many_elements_can_be_appended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            for additional in 1..32 {
                                                let expected = 0..elements;

                                                let mut actual: Dynamic<_> = expected.clone().collect();

                                                _ = actual.reserve_front(front).expect("successful allocation");
                                                _ = actual.reserve_back(back).expect("successful allocation");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front);
                                                debug_assert_eq!(actual.back_capacity, back);

                                                _ = actual.reserve_back(front + back + additional).expect("successful allocation");

                                                let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                                for _ in 0..(front + back + additional) {
                                                    // NOTE: this is distinct from the expected values.
                                                    _ = actual.append(usize::MAX).expect("uses capacity");
                                                }

                                                assert!(pointers.iter().copied().eq(expected));
                                            }
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_both_front_many_elements_can_be_prepended_and_requested_many_elements_can_be_appended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            for additional in 1..32 {
                                                let expected = 0..elements;

                                                let mut actual: Dynamic<_> = expected.clone().collect();

                                                _ = actual.reserve_front(front).expect("successful allocation");
                                                _ = actual.reserve_back(back).expect("successful allocation");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front);
                                                debug_assert_eq!(actual.back_capacity, back);

                                                _ = actual.reserve_back(front + back + additional).expect("successful allocation");

                                                let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                                for _ in 0..front {
                                                    // NOTE: this is distinct from the expected values.
                                                    _ = actual.prepend(usize::MAX).expect("uses capacity");
                                                }

                                                for _ in 0..(front + back + additional) {
                                                    // NOTE: this is distinct from the expected values.
                                                    _ = actual.append(usize::MAX).expect("uses capacity");
                                                }

                                                assert!(pointers.iter().copied().eq(expected));
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }

                    mod when_sum_is_exactly_requested {
                        use super::*;

                        mod when_empty {
                            use super::*;

                            #[test]
                            fn when_zero_size_type_then_can_allocate_maximum_possible_amount() {
                                for exponent in 0..(isize::BITS - 2) {
                                    let mut actual = Dynamic::<()>::default();

                                    _ = actual.reserve_back(isize::MAX as usize).expect("ZSTs do not occupy memory");

                                    let front = usize::pow(2, exponent);

                                    _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, front);
                                    debug_assert_eq!(actual.back_capacity, isize::MAX as usize - front);

                                    _ = actual.reserve_back(isize::MAX as usize).expect("already enough capacity");

                                    assert_eq!(actual.capacity(), isize::MAX as usize);
                                }
                            }

                            #[test]
                            fn then_does_not_modify_capacity() {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(front + back).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.reserve_back(front + back).expect("already enough capacity");

                                        assert_eq!(actual.capacity(), front + back);
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_initialize_elements() {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(front + back).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.reserve_back(front + back).expect("already enough capacity");

                                        assert_eq!(actual.initialized, 0);
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_reallocate_memory() {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(front + back).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        let allocation = actual.buffer;

                                        _ = actual.reserve_back(front + back).expect("already enough capacity");

                                        assert_eq!(actual.buffer, allocation);
                                    }
                                }
                            }

                            #[test]
                            fn then_requested_many_elements_can_be_appended_without_reallocating_memory() {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(front + back).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.reserve_back(front + back).expect("already enough capacity");

                                        let allocation = actual.buffer;

                                        for element in 0..(front + back) {
                                            _ = actual.append(element).expect("uses capacity");
                                        }

                                        assert_eq!(actual.buffer, allocation);
                                    }
                                }
                            }
                        }

                        mod when_not_empty {
                            use super::*;

                            #[test]
                            fn then_does_not_modify_front_capacity() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.reserve_back(front + back).expect("successful allocation");

                                            assert_eq!(actual.front_capacity, front);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_increases_back_capacity_to_exactly_requested() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.reserve_back(front + back).expect("successful allocation");

                                            assert_eq!(actual.back_capacity, front + back);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_modify_initialized_elements() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.reserve_back(front + back).expect("successful allocation");

                                            assert!(actual.eq(expected));
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_front_many_elements_can_be_prepended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.reserve_back(front + back).expect("successful allocation");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..front {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.prepend(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_requested_many_elements_can_be_appended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.reserve_back(front + back).expect("successful allocation");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..(front + back) {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.append(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_both_front_many_elements_can_be_prepended_and_requested_many_elements_can_be_appended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.reserve_back(front + back).expect("successful allocation");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..front {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.prepend(usize::MAX).expect("uses capacity");
                                            }

                                            for _ in 0..(front + back) {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.append(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }
                        }
                    }

                    mod when_sum_is_more_than_requested {
                        use super::*;

                        mod when_empty {
                            use super::*;

                            #[test]
                            fn then_does_not_modify_capacity() {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        for additional in 1..usize::min(front, back) {
                                            let mut actual = Dynamic::<usize>::default();

                                            _ = actual.reserve_back(front + back).expect("successful allocation");

                                            _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                            debug_assert_eq!(actual.initialized, 0);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.reserve_back(front + back - additional).expect("already enough capacity");

                                            assert_eq!(actual.capacity(), front + back);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_initialize_elements() {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        for additional in 1..usize::min(front, back) {
                                            let mut actual = Dynamic::<usize>::default();

                                            _ = actual.reserve_back(front + back).expect("successful allocation");

                                            _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                            debug_assert_eq!(actual.initialized, 0);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.reserve_back(front + back - additional).expect("already enough capacity");

                                            assert_eq!(actual.initialized, 0);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_reallocate_memory() {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        for additional in 1..usize::min(front, back) {
                                            let mut actual = Dynamic::<usize>::default();

                                            _ = actual.reserve_back(front + back).expect("successful allocation");

                                            _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                            debug_assert_eq!(actual.initialized, 0);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            let allocation = actual.buffer;

                                            _ = actual.reserve_back(front + back - additional).expect("already enough capacity");

                                            assert_eq!(actual.buffer, allocation);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_capacity_many_elements_can_be_prepended_without_reallocating_memory() {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        for additional in 1..usize::min(front, back) {
                                            let mut actual = Dynamic::<usize>::default();

                                            _ = actual.reserve_back(front + back).expect("successful allocation");

                                            _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                            debug_assert_eq!(actual.initialized, 0);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.reserve_back(front + back - additional).expect("already enough capacity");

                                            let allocation = actual.buffer;

                                            for element in 0..(front + back) {
                                                _ = actual.prepend(element).expect("uses capacity");
                                            }

                                            assert_eq!(actual.buffer, allocation);
                                        }
                                    }
                                }
                            }
                        }

                        mod when_not_empty {
                            use super::*;

                            #[test]
                            fn then_does_not_modify_front_capacity() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            for additional in 1..usize::min(front, back) {
                                                let mut actual: Dynamic<_> = (0..elements).collect();

                                                _ = actual.reserve_front(front).expect("successful allocation");
                                                _ = actual.reserve_back(back).expect("successful allocation");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front);
                                                debug_assert_eq!(actual.back_capacity, back);

                                                _ = actual.reserve_back(front + back - additional).expect("successful allocation");

                                                assert_eq!(actual.front_capacity, front);
                                            }
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_increases_back_capacity_to_exactly_requested() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            for additional in 1..usize::min(front, back) {
                                                let mut actual: Dynamic<_> = (0..elements).collect();

                                                _ = actual.reserve_front(front).expect("successful allocation");
                                                _ = actual.reserve_back(back).expect("successful allocation");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front);
                                                debug_assert_eq!(actual.back_capacity, back);

                                                _ = actual.reserve_back(front + back - additional).expect("successful allocation");

                                                assert_eq!(actual.back_capacity, front + back - additional);
                                            }
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_modify_initialized_elements() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            for additional in 1..usize::min(front, back) {
                                                let expected = 0..elements;

                                                let mut actual: Dynamic<_> = expected.clone().collect();

                                                _ = actual.reserve_front(front).expect("successful allocation");
                                                _ = actual.reserve_back(back).expect("successful allocation");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front);
                                                debug_assert_eq!(actual.back_capacity, back);

                                                _ = actual.reserve_back(front + back - additional).expect("successful allocation");

                                                assert!(actual.eq(expected));
                                            }
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_front_many_elements_can_be_prepended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            for additional in 1..usize::min(front, back) {
                                                let expected = 0..elements;

                                                let mut actual: Dynamic<_> = expected.clone().collect();

                                                _ = actual.reserve_front(front).expect("successful allocation");
                                                _ = actual.reserve_back(back).expect("successful allocation");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front);
                                                debug_assert_eq!(actual.back_capacity, back);

                                                _ = actual.reserve_back(front + back - additional).expect("successful allocation");

                                                let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                                for _ in 0..front {
                                                    // NOTE: this is distinct from the expected values.
                                                    _ = actual.prepend(usize::MAX).expect("uses capacity");
                                                }

                                                assert!(pointers.iter().copied().eq(expected));
                                            }
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_requested_many_elements_can_be_appended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            for additional in 1..usize::min(front, back) {
                                                let expected = 0..elements;

                                                let mut actual: Dynamic<_> = expected.clone().collect();

                                                _ = actual.reserve_front(front).expect("successful allocation");
                                                _ = actual.reserve_back(back).expect("successful allocation");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front);
                                                debug_assert_eq!(actual.back_capacity, back);

                                                _ = actual.reserve_back(front + back - additional).expect("successful allocation");

                                                let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                                for _ in 0..(front + back - additional) {
                                                    // NOTE: this is distinct from the expected values.
                                                    _ = actual.append(usize::MAX).expect("uses capacity");
                                                }

                                                assert!(pointers.iter().copied().eq(expected));
                                            }
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_both_front_many_elements_can_be_prepended_and_requested_many_elements_can_be_appended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            for additional in 1..usize::min(front, back) {
                                                let expected = 0..elements;

                                                let mut actual: Dynamic<_> = expected.clone().collect();

                                                _ = actual.reserve_front(front).expect("successful allocation");
                                                _ = actual.reserve_back(back).expect("successful allocation");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front);
                                                debug_assert_eq!(actual.back_capacity, back);

                                                _ = actual.reserve_back(front + back - additional).expect("successful allocation");

                                                let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                                for _ in 0..front {
                                                    // NOTE: this is distinct from the expected values.
                                                    _ = actual.prepend(usize::MAX).expect("uses capacity");
                                                }

                                                for _ in 0..(front + back - additional) {
                                                    // NOTE: this is distinct from the expected values.
                                                    _ = actual.append(usize::MAX).expect("uses capacity");
                                                }

                                                assert!(pointers.iter().copied().eq(expected));
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                mod when_front_is_exactly_requested {
                    use super::*;

                    mod when_back_is_less_than_requested {
                        use super::*;

                        mod when_empty {
                            use super::*;

                            #[test]
                            fn then_does_not_modify_capacity() {
                                for front in 1..32 {
                                    for back in 1..front {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(front + back).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.reserve_back(front).expect("already enough capacity");

                                        assert_eq!(actual.capacity(), front + back);
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_initialize_elements() {
                                for front in 1..32 {
                                    for back in 1..front {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(front + back).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.reserve_back(front).expect("already enough capacity");

                                        assert_eq!(actual.initialized, 0);
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_reallocate_memory() {
                                for front in 1..32 {
                                    for back in 1..front {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(front + back).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        let allocation = actual.buffer;

                                        _ = actual.reserve_back(front).expect("already enough capacity");

                                        assert_eq!(actual.buffer, allocation);
                                    }
                                }
                            }

                            #[test]
                            fn then_capacity_many_elements_can_be_appended_without_reallocating_memory() {
                                for front in 1..32 {
                                    for back in 1..front {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(front + back).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.reserve_back(front).expect("already enough capacity");

                                        let allocation = actual.buffer;

                                        for element in 0..(front + back) {
                                            _ = actual.append(element).expect("uses capacity");
                                        }

                                        assert_eq!(actual.buffer, allocation);
                                    }
                                }
                            }
                        }

                        mod when_not_empty {
                            use super::*;

                            #[test]
                            fn then_does_not_modify_front_capacity() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..front {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.reserve_back(front).expect("successful reallocation");

                                            assert_eq!(actual.front_capacity, front);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_increases_back_capacity_to_exactly_requested() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..front {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.reserve_back(front).expect("successful reallocation");

                                            assert_eq!(actual.back_capacity, front);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_modify_initialized_elements() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..front {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.reserve_back(front).expect("successful allocation");

                                            assert!(actual.eq(expected));
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_front_many_elements_can_be_prepended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..front {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.reserve_back(front).expect("successful allocation");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..front {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.prepend(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_requested_many_elements_can_be_appended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..front {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.reserve_back(front).expect("successful allocation");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..front {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.append(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_both_front_many_elements_can_be_prepended_and_requested_many_elements_can_be_appended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..front {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.reserve_back(front).expect("successful allocation");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..front {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.prepend(usize::MAX).expect("uses capacity");
                                            }

                                            for _ in 0..front {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.append(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }
                        }
                    }

                    mod when_back_is_more_than_requested {
                        use super::*;

                        mod when_empty {
                            use super::*;

                            #[test]
                            fn then_does_not_modify_capacity() {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(capacity + capacity + additional).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(capacity).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, capacity);
                                        debug_assert_eq!(actual.back_capacity, capacity + additional);

                                        _ = actual.reserve_back(capacity).expect("already enough capacity");

                                        assert_eq!(actual.capacity(), capacity + capacity + additional);
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_initialize_elements() {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(capacity + capacity + additional).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(capacity).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, capacity);
                                        debug_assert_eq!(actual.back_capacity, capacity + additional);

                                        _ = actual.reserve_back(capacity).expect("already enough capacity");

                                        assert_eq!(actual.initialized, 0);
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_reallocate_memory() {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(capacity + capacity + additional).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(capacity).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, capacity);
                                        debug_assert_eq!(actual.back_capacity, capacity + additional);

                                        let allocation = actual.buffer;

                                        _ = actual.reserve_back(capacity).expect("already enough capacity");

                                        assert_eq!(actual.buffer, allocation);
                                    }
                                }
                            }

                            #[test]
                            fn then_capacity_many_elements_can_be_appended_without_reallocating_memory() {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(capacity + capacity + additional).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(capacity).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, capacity);
                                        debug_assert_eq!(actual.back_capacity, capacity + additional);

                                        _ = actual.reserve_back(capacity).expect("already enough capacity");

                                        let allocation = actual.buffer;

                                        for element in 0..(capacity + capacity + additional) {
                                            _ = actual.append(element).expect("uses capacity");
                                        }

                                        assert_eq!(actual.buffer, allocation);
                                    }
                                }
                            }
                        }

                        mod when_not_empty {
                            use super::*;

                            #[test]
                            fn then_does_not_modify_front_capacity() {
                                for elements in 1..32 {
                                    for capacity in 1..32 {
                                        for additional in 1..32 {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(capacity).expect("successful allocation");
                                            _ = actual.reserve_back(capacity + additional).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, capacity);
                                            debug_assert_eq!(actual.back_capacity, capacity + additional);

                                            _ = actual.reserve_back(capacity).expect("already enough capacity");

                                            assert_eq!(actual.front_capacity, capacity);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_modify_back_capacity() {
                                for elements in 1..32 {
                                    for capacity in 1..32 {
                                        for additional in 1..32 {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(capacity).expect("successful allocation");
                                            _ = actual.reserve_back(capacity + additional).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, capacity);
                                            debug_assert_eq!(actual.back_capacity, capacity + additional);

                                            _ = actual.reserve_back(capacity).expect("already enough capacity");

                                            assert_eq!(actual.back_capacity, capacity + additional);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_modify_initialized_elements() {
                                for elements in 1..32 {
                                    for capacity in 1..32 {
                                        for additional in 1..32 {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(capacity).expect("successful allocation");
                                            _ = actual.reserve_back(capacity + additional).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, capacity);
                                            debug_assert_eq!(actual.back_capacity, capacity + additional);

                                            _ = actual.reserve_back(capacity).expect("already enough capacity");

                                            assert!(actual.eq(expected));
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_reallocate_memory() {
                                for elements in 1..32 {
                                    for capacity in 1..32 {
                                        for additional in 1..32 {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(capacity).expect("successful allocation");
                                            _ = actual.reserve_back(capacity + additional).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, capacity);
                                            debug_assert_eq!(actual.back_capacity, capacity + additional);

                                            let allocation = actual.buffer;

                                            _ = actual.reserve_back(capacity).expect("already enough capacity");

                                            assert_eq!(actual.buffer, allocation);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_front_many_elements_can_be_prepended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for capacity in 1..32 {
                                        for additional in 1..32 {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(capacity).expect("successful allocation");
                                            _ = actual.reserve_back(capacity + additional).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, capacity);
                                            debug_assert_eq!(actual.back_capacity, capacity + additional);

                                            _ = actual.reserve_back(capacity).expect("already enough capacity");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..capacity {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.prepend(elements).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_back_many_elements_can_be_appended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for capacity in 1..32 {
                                        for additional in 1..32 {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(capacity).expect("successful allocation");
                                            _ = actual.reserve_back(capacity + additional).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, capacity);
                                            debug_assert_eq!(actual.back_capacity, capacity + additional);

                                            _ = actual.reserve_back(capacity).expect("already enough capacity");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..(capacity + additional) {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.append(elements).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_both_front_many_elements_can_be_prepended_and_back_many_elements_can_be_appended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for capacity in 1..32 {
                                        for additional in 1..32 {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(capacity).expect("successful allocation");
                                            _ = actual.reserve_back(capacity + additional).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, capacity);
                                            debug_assert_eq!(actual.back_capacity, capacity + additional);

                                            _ = actual.reserve_back(capacity).expect("already enough capacity");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..capacity {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.prepend(elements).expect("uses capacity");
                                            }

                                            for _ in 0..(capacity + additional) {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.append(elements).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                mod when_back_is_exactly_requested {
                    use super::*;

                    mod when_front_is_less_than_requested {
                        use super::*;

                        mod when_empty {
                            use super::*;

                            #[test]
                            fn then_does_not_modify_capacity() {
                                for back in 1..32 {
                                    for front in 1..back {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(front + back).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.reserve_back(back).expect("already enough capacity");

                                        assert_eq!(actual.capacity(), front + back);
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_initialize_elements() {
                                for back in 1..32 {
                                    for front in 1..back {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(front + back).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.reserve_back(back).expect("already enough capacity");

                                        assert_eq!(actual.initialized, 0);
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_reallocate_memory() {
                                for back in 1..32 {
                                    for front in 1..back {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(front + back).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        let allocation = actual.buffer;

                                        _ = actual.reserve_back(back).expect("already enough capacity");

                                        assert_eq!(actual.buffer, allocation);
                                    }
                                }
                            }

                            #[test]
                            fn then_capacity_many_elements_can_be_appended_without_reallocating_memory() {
                                for back in 1..32 {
                                    for front in 1..back {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(front + back).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.reserve_back(back).expect("already enough capacity");

                                        let allocation = actual.buffer;

                                        for element in 0..(front + back) {
                                            _ = actual.append(element).expect("uses capacity");
                                        }

                                        assert_eq!(actual.buffer, allocation);
                                    }
                                }
                            }
                        }

                        mod when_not_empty {
                            use super::*;

                            #[test]
                            fn then_does_not_modify_front_capacity() {
                                for elements in 1..32 {
                                    for back in 1..32 {
                                        for front in 1..back {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.reserve_back(back).expect("already enough capacity");

                                            assert_eq!(actual.front_capacity, front);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_modify_back_capacity() {
                                for elements in 1..32 {
                                    for back in 1..32 {
                                        for front in 1..back {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.reserve_back(back).expect("already enough capacity");

                                            assert_eq!(actual.back_capacity, back);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_modify_initialized_elements() {
                                for elements in 1..32 {
                                    for back in 1..32 {
                                        for front in 1..back {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.reserve_back(back).expect("already enough capacity");

                                            assert!(actual.eq(expected));
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_reallocate_memory() {
                                for elements in 1..32 {
                                    for back in 1..32 {
                                        for front in 1..back {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            let allocation = actual.buffer;

                                            _ = actual.reserve_back(back).expect("already enough capacity");

                                            assert_eq!(actual.buffer, allocation);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_front_many_elements_can_be_prepended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for back in 1..32 {
                                        for front in 1..back {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.reserve_back(back).expect("already enough capacity");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..front {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.prepend(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_requested_many_elements_can_be_appended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for back in 1..32 {
                                        for front in 1..back {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.reserve_back(back).expect("already enough capacity");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..back {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.append(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_both_front_many_elements_can_be_prepended_and_requested_many_elements_can_be_appended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for back in 1..32 {
                                        for front in 1..back {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.reserve_back(back).expect("already enough capacity");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..front {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.prepend(usize::MAX).expect("uses capacity");
                                            }

                                            for _ in 0..back {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.append(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }
                        }
                    }

                    mod when_front_is_more_than_requested {
                        use super::*;

                        mod when_empty {
                            use super::*;

                            #[test]
                            fn then_does_not_modify_capacity() {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(capacity + additional + capacity).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(capacity + additional).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, capacity + additional);
                                        debug_assert_eq!(actual.back_capacity, capacity);

                                        _ = actual.reserve_back(capacity).expect("already enough capacity");

                                        assert_eq!(actual.capacity(), capacity + additional + capacity);
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_initialize_elements() {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(capacity + additional + capacity).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(capacity + additional).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, capacity + additional);
                                        debug_assert_eq!(actual.back_capacity, capacity);

                                        _ = actual.reserve_back(capacity).expect("already enough capacity");

                                        assert_eq!(actual.initialized, 0);
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_reallocate_memory() {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(capacity + additional + capacity).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(capacity + additional).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, capacity + additional);
                                        debug_assert_eq!(actual.back_capacity, capacity);

                                        let allocation = actual.buffer;

                                        _ = actual.reserve_back(capacity).expect("already enough capacity");

                                        assert_eq!(actual.buffer, allocation);
                                    }
                                }
                            }

                            #[test]
                            fn then_capacity_many_elements_can_be_appended_without_reallocating_memory() {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(capacity + additional + capacity).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(capacity + additional).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, capacity + additional);
                                        debug_assert_eq!(actual.back_capacity, capacity);

                                        _ = actual.reserve_back(capacity).expect("already enough capacity");

                                        let allocation = actual.buffer;

                                        for element in 0..(capacity + additional) {
                                            _ = actual.append(element).expect("uses capacity");
                                        }

                                        assert_eq!(actual.buffer, allocation);
                                    }
                                }
                            }
                        }

                        mod when_not_empty {
                            use super::*;

                            #[test]
                            fn then_does_not_modify_front_capacity() {
                                for elements in 1..32 {
                                    for capacity in 1..32 {
                                        for additional in 1..32 {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(capacity + additional).expect("successful allocation");
                                            _ = actual.reserve_back(capacity).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, capacity + additional);
                                            debug_assert_eq!(actual.back_capacity, capacity);

                                            _ = actual.reserve_back(capacity).expect("already enough capacity");

                                            assert_eq!(actual.front_capacity, capacity + additional);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_modify_back_capacity() {
                                for elements in 1..32 {
                                    for capacity in 1..32 {
                                        for additional in 1..32 {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(capacity + additional).expect("successful allocation");
                                            _ = actual.reserve_back(capacity).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, capacity + additional);
                                            debug_assert_eq!(actual.back_capacity, capacity);

                                            _ = actual.reserve_back(capacity).expect("already enough capacity");

                                            assert_eq!(actual.back_capacity, capacity);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_modify_initialized_elements() {
                                for elements in 1..32 {
                                    for capacity in 1..32 {
                                        for additional in 1..32 {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(capacity + additional).expect("successful allocation");
                                            _ = actual.reserve_back(capacity).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, capacity + additional);
                                            debug_assert_eq!(actual.back_capacity, capacity);

                                            _ = actual.reserve_back(capacity).expect("already enough capacity");

                                            assert!(actual.eq(expected));
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_reallocate_memory() {
                                for elements in 1..32 {
                                    for capacity in 1..32 {
                                        for additional in 1..32 {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(capacity + additional).expect("successful allocation");
                                            _ = actual.reserve_back(capacity).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, capacity + additional);
                                            debug_assert_eq!(actual.back_capacity, capacity);

                                            let allocation = actual.buffer;

                                            _ = actual.reserve_back(capacity).expect("already enough capacity");

                                            assert_eq!(actual.buffer, allocation);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_front_many_elements_can_be_prepended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for capacity in 1..32 {
                                        for additional in 1..32 {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(capacity + additional).expect("successful allocation");
                                            _ = actual.reserve_back(capacity).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, capacity + additional);
                                            debug_assert_eq!(actual.back_capacity, capacity);

                                            _ = actual.reserve_back(capacity).expect("already enough capacity");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..(capacity + additional) {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.prepend(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_requested_many_elements_can_be_appended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for capacity in 1..32 {
                                        for additional in 1..32 {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(capacity + additional).expect("successful allocation");
                                            _ = actual.reserve_back(capacity).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, capacity + additional);
                                            debug_assert_eq!(actual.back_capacity, capacity);

                                            _ = actual.reserve_back(capacity).expect("already enough capacity");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..capacity {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.append(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_both_front_many_elements_can_be_appended_and_requested_many_elements_can_be_appended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for capacity in 1..32 {
                                        for additional in 1..32 {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(capacity + additional).expect("successful allocation");
                                            _ = actual.reserve_back(capacity).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, capacity + additional);
                                            debug_assert_eq!(actual.back_capacity, capacity);

                                            _ = actual.reserve_back(capacity).expect("already enough capacity");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..(capacity + additional) {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.prepend(usize::MAX).expect("uses capacity");
                                            }

                                            for _ in 0..capacity {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.append(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                mod when_both_exactly_requested {
                    use super::*;

                    mod when_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_capacity() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_back(capacity + capacity).expect("successful allocation");

                                _ = actual.shift(isize::try_from(capacity).expect("too small to wrap")).expect("enough back capacity to shift into");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, capacity);
                                debug_assert_eq!(actual.back_capacity, capacity);

                                _ = actual.reserve_back(capacity).expect("already enough capacity");

                                assert_eq!(actual.capacity(), capacity + capacity);
                            }
                        }

                        #[test]
                        fn then_does_not_initialize_elements() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_back(capacity + capacity).expect("successful allocation");

                                _ = actual.shift(isize::try_from(capacity).expect("too small to wrap")).expect("enough back capacity to shift into");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, capacity);
                                debug_assert_eq!(actual.back_capacity, capacity);

                                _ = actual.reserve_back(capacity).expect("already enough capacity");

                                assert_eq!(actual.initialized, 0);
                            }
                        }

                        #[test]
                        fn then_does_not_reallocate_memory() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_back(capacity + capacity).expect("successful allocation");

                                _ = actual.shift(isize::try_from(capacity).expect("too small to wrap")).expect("enough back capacity to shift into");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, capacity);
                                debug_assert_eq!(actual.back_capacity, capacity);

                                let allocation = actual.buffer;

                                _ = actual.reserve_back(capacity).expect("already enough capacity");

                                assert_eq!(actual.buffer, allocation);
                            }
                        }

                        #[test]
                        fn then_capacity_many_elements_can_be_appended_without_reallocating_memory() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_back(capacity + capacity).expect("successful allocation");

                                _ = actual.shift(isize::try_from(capacity).expect("too small to wrap")).expect("enough back capacity to shift into");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, capacity);
                                debug_assert_eq!(actual.back_capacity, capacity);

                                _ = actual.reserve_back(capacity).expect("already enough capacity");

                                let allocation = actual.buffer;

                                for element in 0..(capacity + capacity) {
                                    _ = actual.append(element).expect("uses capacity");
                                }

                                assert_eq!(actual.buffer, allocation);
                            }
                        }
                    }

                    mod when_not_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_front_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let mut actual: Dynamic<_> = (0..elements).collect();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");
                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    _ = actual.reserve_back(capacity).expect("already enough capacity");

                                    assert_eq!(actual.front_capacity, capacity);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_back_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let mut actual: Dynamic<_> = (0..elements).collect();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");
                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    _ = actual.reserve_back(capacity).expect("already enough capacity");

                                    assert_eq!(actual.back_capacity, capacity);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_initialized_elements() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let expected = 0..elements;

                                    let mut actual: Dynamic<_> = expected.clone().collect();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");
                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    _ = actual.reserve_back(capacity).expect("already enough capacity");

                                    assert!(actual.eq(expected));
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_reallocate_memory() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let mut actual: Dynamic<_> = (0..elements).collect();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");
                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    let allocation = actual.buffer;

                                    _ = actual.reserve_back(capacity).expect("already enough capacity");

                                    assert_eq!(actual.buffer, allocation);
                                }
                            }
                        }

                        #[test]
                        fn then_front_many_elements_can_be_prepended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let expected = 0..elements;

                                    let mut actual: Dynamic<_> = expected.clone().collect();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");
                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    _ = actual.reserve_back(capacity).expect("already enough capacity");

                                    let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                    for _ in 0..capacity {
                                        // NOTE: this is distinct from the expected values.
                                        _ = actual.prepend(usize::MAX).expect("uses capacity");
                                    }

                                    assert!(pointers.iter().copied().eq(expected));
                                }
                            }
                        }

                        #[test]
                        fn then_requested_many_elements_can_be_appended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let expected = 0..elements;

                                    let mut actual: Dynamic<_> = expected.clone().collect();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");
                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    _ = actual.reserve_back(capacity).expect("already enough capacity");

                                    let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                    for _ in 0..capacity {
                                        // NOTE: this is distinct from the expected values.
                                        _ = actual.append(usize::MAX).expect("uses capacity");
                                    }

                                    assert!(pointers.iter().copied().eq(expected));
                                }
                            }
                        }

                        #[test]
                        fn then_both_front_many_elements_can_be_prepended_and_requested_many_elements_can_be_appended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let expected = 0..elements;

                                    let mut actual: Dynamic<_> = expected.clone().collect();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");
                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    _ = actual.reserve_back(capacity).expect("already enough capacity");

                                    let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                    for _ in 0..capacity {
                                        // NOTE: this is distinct from the expected values.
                                        _ = actual.prepend(usize::MAX).expect("uses capacity");
                                    }

                                    for _ in 0..capacity {
                                        // NOTE: this is distinct from the expected values.
                                        _ = actual.append(usize::MAX).expect("uses capacity");
                                    }

                                    assert!(pointers.iter().copied().eq(expected));
                                }
                            }
                        }
                    }
                }

                mod when_front_is_more_than_requested_and_back_is_less_than_requested {
                    use super::*;

                    mod when_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_capacity() {
                            for capacity in 1..32 {
                                for more in capacity..(capacity + 32) {
                                    for less in 1..capacity {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(more + less).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(more).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, more);
                                        debug_assert_eq!(actual.back_capacity, less);

                                        _ = actual.reserve_back(capacity).expect("already enough capacity");

                                        assert_eq!(actual.capacity(), more + less);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_initialize_elements() {
                            for capacity in 1..32 {
                                for more in capacity..(capacity + 32) {
                                    for less in 1..capacity {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(more + less).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(more).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, more);
                                        debug_assert_eq!(actual.back_capacity, less);

                                        _ = actual.reserve_back(capacity).expect("already enough capacity");

                                        assert_eq!(actual.initialized, 0);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_reallocate_memory() {
                            for capacity in 1..32 {
                                for more in capacity..(capacity + 32) {
                                    for less in 1..capacity {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(more + less).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(more).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, more);
                                        debug_assert_eq!(actual.back_capacity, less);

                                        let allocation = actual.buffer;

                                        _ = actual.reserve_back(capacity).expect("already enough capacity");

                                        assert_eq!(actual.buffer, allocation);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_capacity_many_elements_can_be_appended_without_reallocating_memory() {
                            for capacity in 1..32 {
                                for more in capacity..(capacity + 32) {
                                    for less in 1..capacity {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(more + less).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(more).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, more);
                                        debug_assert_eq!(actual.back_capacity, less);

                                        _ = actual.reserve_front(capacity).expect("already enough capacity");

                                        let allocation = actual.buffer;

                                        for element in 0..(more + less) {
                                            _ = actual.append(element).expect("uses capacity");
                                        }

                                        assert_eq!(actual.buffer, allocation);
                                    }
                                }
                            }
                        }
                    }

                    mod when_not_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_front_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for more in capacity..(capacity + 32) {
                                        for less in 1..capacity {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(more).expect("successful allocation");
                                            _ = actual.reserve_back(less).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, more);
                                            debug_assert_eq!(actual.back_capacity, less);

                                            _ = actual.reserve_back(capacity).expect("successful allocation");

                                            assert_eq!(actual.front_capacity, more);
                                        }
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_increases_back_capacity_to_exactly_requested() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for more in capacity..(capacity + 32) {
                                        for less in 1..capacity {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(more).expect("successful allocation");
                                            _ = actual.reserve_back(less).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, more);
                                            debug_assert_eq!(actual.back_capacity, less);

                                            _ = actual.reserve_back(capacity).expect("successful allocation");

                                            assert_eq!(actual.back_capacity, capacity);
                                        }
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_initialized_elements() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for more in capacity..(capacity + 32) {
                                        for less in 1..capacity {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(more).expect("successful allocation");
                                            _ = actual.reserve_back(less).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, more);
                                            debug_assert_eq!(actual.back_capacity, less);

                                            _ = actual.reserve_back(capacity).expect("successful allocation");

                                            assert!(actual.eq(expected));
                                        }
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_front_many_elements_can_be_prepended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for more in capacity..(capacity + 32) {
                                        for less in 1..capacity {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(more).expect("successful allocation");
                                            _ = actual.reserve_back(less).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, more);
                                            debug_assert_eq!(actual.back_capacity, less);

                                            _ = actual.reserve_back(capacity).expect("successful allocation");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..more {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.prepend(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_requested_many_elements_can_be_appended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for more in capacity..(capacity + 32) {
                                        for less in 1..capacity {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(more).expect("successful allocation");
                                            _ = actual.reserve_back(less).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, more);
                                            debug_assert_eq!(actual.back_capacity, less);

                                            _ = actual.reserve_back(capacity).expect("successful allocation");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..capacity {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.append(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_both_front_many_elements_can_be_prepended_and_requested_many_elements_can_be_appended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for more in capacity..(capacity + 32) {
                                        for less in 1..capacity {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(more).expect("successful allocation");
                                            _ = actual.reserve_back(less).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, more);
                                            debug_assert_eq!(actual.back_capacity, less);

                                            _ = actual.reserve_back(capacity).expect("successful allocation");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..more {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.prepend(usize::MAX).expect("uses capacity");
                                            }

                                            for _ in 0..capacity {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.append(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                mod when_front_is_less_than_requested_and_back_is_more_than_requested {
                    use super::*;

                    mod when_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_capacity() {
                            for capacity in 1..32 {
                                for more in capacity..(capacity + 32) {
                                    for less in 1..capacity {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(less + more).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(less).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, less);
                                        debug_assert_eq!(actual.back_capacity, more);

                                        _ = actual.reserve_back(capacity).expect("already enough capacity");

                                        assert_eq!(actual.capacity(), less + more);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_initialize_elements() {
                            for capacity in 1..32 {
                                for more in capacity..(capacity + 32) {
                                    for less in 1..capacity {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(less + more).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(less).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, less);
                                        debug_assert_eq!(actual.back_capacity, more);

                                        _ = actual.reserve_back(capacity).expect("already enough capacity");

                                        assert_eq!(actual.initialized, 0);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_reallocate_memory() {
                            for capacity in 1..32 {
                                for more in capacity..(capacity + 32) {
                                    for less in 1..capacity {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(less + more).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(less).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, less);
                                        debug_assert_eq!(actual.back_capacity, more);

                                        let allocation = actual.buffer;

                                        _ = actual.reserve_back(capacity).expect("already enough capacity");

                                        assert_eq!(actual.buffer, allocation);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_capacity_many_elements_can_be_appended_without_reallocating_memory() {
                            for capacity in 1..32 {
                                for more in capacity..(capacity + 32) {
                                    for less in 1..capacity {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(less + more).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(less).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, less);
                                        debug_assert_eq!(actual.back_capacity, more);

                                        _ = actual.reserve_back(capacity).expect("already enough capacity");

                                        let allocation = actual.buffer;

                                        for element in 0..(less + more) {
                                            _ = actual.append(element).expect("uses capacity");
                                        }

                                        assert_eq!(actual.buffer, allocation);
                                    }
                                }
                            }
                        }
                    }

                    mod when_not_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_front_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for more in capacity..(capacity + 32) {
                                        for less in 1..capacity {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(less).expect("successful allocation");
                                            _ = actual.reserve_back(more).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, less);
                                            debug_assert_eq!(actual.back_capacity, more);

                                            _ = actual.reserve_back(capacity).expect("already enough capacity");

                                            assert_eq!(actual.front_capacity, less);
                                        }
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_back_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for more in capacity..(capacity + 32) {
                                        for less in 1..capacity {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(less).expect("successful allocation");
                                            _ = actual.reserve_back(more).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, less);
                                            debug_assert_eq!(actual.back_capacity, more);

                                            _ = actual.reserve_back(capacity).expect("already enough capacity");

                                            assert_eq!(actual.back_capacity, more);
                                        }
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_initialized_elements() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for more in capacity..(capacity + 32) {
                                        for less in 1..capacity {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(less).expect("successful allocation");
                                            _ = actual.reserve_back(more).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, less);
                                            debug_assert_eq!(actual.back_capacity, more);

                                            _ = actual.reserve_back(capacity).expect("already enough capacity");

                                            assert!(actual.eq(expected));
                                        }
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_reallocate_memory() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for more in capacity..(capacity + 32) {
                                        for less in 1..capacity {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(less).expect("successful allocation");
                                            _ = actual.reserve_back(more).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, less);
                                            debug_assert_eq!(actual.back_capacity, more);

                                            let allocation = actual.buffer;

                                            _ = actual.reserve_back(capacity).expect("already enough capacity");

                                            assert_eq!(actual.buffer, allocation);
                                        }
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_front_many_elements_can_be_prepended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for more in capacity..(capacity + 32) {
                                        for less in 1..capacity {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(less).expect("successful allocation");
                                            _ = actual.reserve_back(more).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, less);
                                            debug_assert_eq!(actual.back_capacity, more);

                                            _ = actual.reserve_back(capacity).expect("already enough capacity");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..less {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.prepend(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_back_many_elements_can_be_appended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for more in capacity..(capacity + 32) {
                                        for less in 1..capacity {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(less).expect("successful allocation");
                                            _ = actual.reserve_back(more).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, less);
                                            debug_assert_eq!(actual.back_capacity, more);

                                            _ = actual.reserve_back(capacity).expect("already enough capacity");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..more {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.append(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_both_front_many_elements_can_be_prepended_and_back_many_elements_can_be_appended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for more in capacity..(capacity + 32) {
                                        for less in 1..capacity {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(less).expect("successful allocation");
                                            _ = actual.reserve_back(more).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, less);
                                            debug_assert_eq!(actual.back_capacity, more);

                                            _ = actual.reserve_back(capacity).expect("already enough capacity");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..less {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.prepend(usize::MAX).expect("uses capacity");
                                            }

                                            for _ in 0..more {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.append(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                mod when_both_more_than_requested {
                    use super::*;

                    mod when_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_capacity() {
                            for capacity in 1..32 {
                                for additional_front in 1..32 {
                                    for additional_back in 1..32 {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(capacity + additional_front + capacity + additional_back).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(capacity + additional_front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, capacity + additional_front);
                                        debug_assert_eq!(actual.back_capacity, capacity + additional_back);

                                        _ = actual.reserve_back(capacity).expect("already enough capacity");

                                        assert_eq!(actual.capacity(), capacity + additional_front + capacity + additional_back);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_initialize_elements() {
                            for capacity in 1..32 {
                                for additional_front in 1..32 {
                                    for additional_back in 1..32 {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(capacity + additional_front + capacity + additional_back).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(capacity + additional_front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, capacity + additional_front);
                                        debug_assert_eq!(actual.back_capacity, capacity + additional_back);

                                        _ = actual.reserve_back(capacity).expect("already enough capacity");

                                        assert_eq!(actual.initialized, 0);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_reallocate_memory() {
                            for capacity in 1..32 {
                                for additional_front in 1..32 {
                                    for additional_back in 1..32 {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(capacity + additional_front + capacity + additional_back).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(capacity + additional_front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, capacity + additional_front);
                                        debug_assert_eq!(actual.back_capacity, capacity + additional_back);

                                        let allocation = actual.buffer;

                                        _ = actual.reserve_back(capacity).expect("already enough capacity");

                                        assert_eq!(actual.buffer, allocation);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_capacity_many_elements_can_be_prepended_without_reallocating_memory() {
                            for capacity in 1..32 {
                                for additional_front in 1..32 {
                                    for additional_back in 1..32 {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(capacity + additional_front + capacity + additional_back).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(capacity + additional_front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, capacity + additional_front);
                                        debug_assert_eq!(actual.back_capacity, capacity + additional_back);

                                        _ = actual.reserve_back(capacity).expect("already enough capacity");

                                        let allocation = actual.buffer;

                                        for element in 0..(capacity + capacity) {
                                            _ = actual.append(element).expect("uses capacity");
                                        }

                                        assert_eq!(actual.buffer, allocation);
                                    }
                                }
                            }
                        }
                    }

                    mod when_not_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_front_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional_front in 1..32 {
                                        for additional_back in 1..32 {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(capacity + additional_front).expect("successful allocation");
                                            _ = actual.reserve_back(capacity + additional_back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, capacity + additional_front);
                                            debug_assert_eq!(actual.back_capacity, capacity + additional_back);

                                            _ = actual.reserve_back(capacity).expect("already enough capacity");

                                            assert_eq!(actual.front_capacity, capacity + additional_front);
                                        }
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_back_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional_front in 1..32 {
                                        for additional_back in 1..32 {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(capacity + additional_front).expect("successful allocation");
                                            _ = actual.reserve_back(capacity + additional_back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, capacity + additional_front);
                                            debug_assert_eq!(actual.back_capacity, capacity + additional_back);

                                            _ = actual.reserve_back(capacity).expect("already enough capacity");

                                            assert_eq!(actual.back_capacity, capacity + additional_back);
                                        }
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_initialized_elements() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional_front in 1..32 {
                                        for additional_back in 1..32 {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(capacity + additional_front).expect("successful allocation");
                                            _ = actual.reserve_back(capacity + additional_back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, capacity + additional_front);
                                            debug_assert_eq!(actual.back_capacity, capacity + additional_back);

                                            _ = actual.reserve_back(capacity).expect("already enough capacity");

                                            assert!(actual.eq(expected));
                                        }
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_reallocate_memory() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional_front in 1..32 {
                                        for additional_back in 1..32 {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(capacity + additional_front).expect("successful allocation");
                                            _ = actual.reserve_back(capacity + additional_back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, capacity + additional_front);
                                            debug_assert_eq!(actual.back_capacity, capacity + additional_back);

                                            let allocation = actual.buffer;

                                            _ = actual.reserve_back(capacity).expect("already enough capacity");

                                            assert_eq!(actual.buffer, allocation);
                                        }
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_front_many_elements_can_be_prepended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional_front in 1..32 {
                                        for additional_back in 1..32 {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(capacity + additional_front).expect("successful allocation");
                                            _ = actual.reserve_back(capacity + additional_back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, capacity + additional_front);
                                            debug_assert_eq!(actual.back_capacity, capacity + additional_back);

                                            _ = actual.reserve_back(capacity).expect("already enough capacity");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..(capacity + additional_front) {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.prepend(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_back_many_elements_can_be_appended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional_front in 1..32 {
                                        for additional_back in 1..32 {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(capacity + additional_front).expect("successful allocation");
                                            _ = actual.reserve_back(capacity + additional_back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, capacity + additional_front);
                                            debug_assert_eq!(actual.back_capacity, capacity + additional_back);

                                            _ = actual.reserve_back(capacity).expect("already enough capacity");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..(capacity + additional_back) {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.append(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_both_front_many_elements_can_be_prepended_and_back_many_elements_can_be_appended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional_front in 1..32 {
                                        for additional_back in 1..32 {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(capacity + additional_front).expect("successful allocation");
                                            _ = actual.reserve_back(capacity + additional_back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, capacity + additional_front);
                                            debug_assert_eq!(actual.back_capacity, capacity + additional_back);

                                            _ = actual.reserve_back(capacity).expect("already enough capacity");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..(capacity + additional_front) {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.prepend(usize::MAX).expect("uses capacity");
                                            }

                                            for _ in 0..(capacity + additional_back) {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.append(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        mod shrink {
            use super::*;

            mod when_no_capacity {
                use super::*;

                mod when_zero_requested {
                    use super::*;

                    mod when_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_capacity() {
                            let mut actual = Dynamic::<usize>::default();

                            debug_assert_eq!(actual.initialized, 0);
                            debug_assert_eq!(actual.front_capacity, 0);
                            debug_assert_eq!(actual.back_capacity, 0);

                            _ = actual.shrink(0).expect("already no capacity");

                            assert_eq!(actual.capacity(), 0);
                        }

                        #[test]
                        fn then_does_not_initialize_elements() {
                            let mut actual = Dynamic::<usize>::default();

                            debug_assert_eq!(actual.initialized, 0);
                            debug_assert_eq!(actual.front_capacity, 0);
                            debug_assert_eq!(actual.back_capacity, 0);

                            _ = actual.shrink(0).expect("already no capacity");

                            assert_eq!(actual.initialized, 0);
                        }
                    }

                    mod when_not_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_front_capacity() {
                            for elements in 1..32 {
                                let mut actual: Dynamic<_> = (0..elements).collect();

                                debug_assert_eq!(actual.initialized, elements);
                                debug_assert_eq!(actual.front_capacity, 0);
                                debug_assert_eq!(actual.back_capacity, 0);

                                _ = actual.shrink(0).expect("already no capacity");

                                assert_eq!(actual.front_capacity, 0);
                            }
                        }

                        #[test]
                        fn then_does_not_modify_back_capacity() {
                            for elements in 1..32 {
                                let mut actual: Dynamic<_> = (0..elements).collect();

                                debug_assert_eq!(actual.initialized, elements);
                                debug_assert_eq!(actual.front_capacity, 0);
                                debug_assert_eq!(actual.back_capacity, 0);

                                _ = actual.shrink(0).expect("already no capacity");

                                assert_eq!(actual.back_capacity, 0);
                            }
                        }

                        #[test]
                        fn then_does_not_modify_initialized_elements() {
                            for elements in 1..32 {
                                let expected = 0..elements;

                                let mut actual: Dynamic<_> = expected.clone().collect();

                                debug_assert_eq!(actual.initialized, elements);
                                debug_assert_eq!(actual.front_capacity, 0);
                                debug_assert_eq!(actual.back_capacity, 0);

                                _ = actual.shrink(0).expect("already no capacity");

                                assert!(actual.eq(expected));
                            }
                        }

                        #[test]
                        fn then_does_not_reallocate_memory() {
                            for elements in 1..32 {
                                let mut actual: Dynamic<_> = (0..elements).collect();

                                debug_assert_eq!(actual.initialized, elements);
                                debug_assert_eq!(actual.front_capacity, 0);
                                debug_assert_eq!(actual.back_capacity, 0);

                                let allocation = actual.buffer;

                                _ = actual.shrink(0).expect("already no capacity");

                                assert_eq!(actual.buffer, allocation);
                            }
                        }
                    }
                }

                mod when_more_than_zero_requested {
                    use super::*;

                    mod when_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_capacity() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, 0);
                                debug_assert_eq!(actual.back_capacity, 0);

                                _ = actual.shrink(capacity).expect_err("already less capacity");

                                assert_eq!(actual.capacity(), 0);
                            }
                        }

                        #[test]
                        fn then_does_not_initialize_elements() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, 0);
                                debug_assert_eq!(actual.back_capacity, 0);

                                _ = actual.shrink(capacity).expect_err("already less capacity");

                                assert_eq!(actual.initialized, 0);
                            }
                        }
                    }

                    mod when_not_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_front_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let mut actual: Dynamic<_> = (0..elements).collect();

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.shrink(capacity).expect_err("already less capacity");

                                    assert_eq!(actual.front_capacity, 0);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_back_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let mut actual: Dynamic<_> = (0..elements).collect();

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.shrink(capacity).expect_err("already less capacity");

                                    assert_eq!(actual.back_capacity, 0);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_initialized_elements() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let expected = 0..elements;

                                    let mut actual: Dynamic<_> = expected.clone().collect();

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.shrink(capacity).expect_err("already less capacity");

                                    assert!(actual.eq(expected));
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_reallocate_memory() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let mut actual: Dynamic<_> = (0..elements).collect();

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    let allocation = actual.buffer;

                                    _ = actual.shrink(capacity).expect_err("already less capacity");

                                    assert_eq!(actual.buffer, allocation);
                                }
                            }
                        }
                    }
                }
            }

            mod when_only_front_capacity {
                use super::*;

                mod when_zero_requested {
                    use super::*;

                    mod when_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_capacity() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_front(capacity).expect("successful allocation");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, capacity);
                                debug_assert_eq!(actual.back_capacity, 0);

                                _ = actual.shrink(0).expect("already no capacity");

                                assert_eq!(actual.capacity(), 0);
                            }
                        }

                        #[test]
                        fn then_does_not_initialize_elements() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_front(capacity).expect("successful allocation");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, capacity);
                                debug_assert_eq!(actual.back_capacity, 0);

                                _ = actual.shrink(0).expect("already no capacity");

                                assert_eq!(actual.initialized, 0);
                            }
                        }
                    }

                    mod when_not_empty {
                        use super::*;

                        #[test]
                        fn then_decreases_front_capacity_to_zero() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let mut actual: Dynamic<_> = (0..elements).collect();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.shrink(0).expect("already no capacity");

                                    assert_eq!(actual.front_capacity, 0);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_back_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let mut actual: Dynamic<_> = (0..elements).collect();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.shrink(0).expect("already no capacity");

                                    assert_eq!(actual.back_capacity, 0);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_initialized_elements() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let expected = 0..elements;

                                    let mut actual: Dynamic<_> = expected.clone().collect();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.shrink(0).expect("already no capacity");

                                    assert!(actual.eq(expected));
                                }
                            }
                        }
                    }
                }

                mod when_less_than_requested {
                    use super::*;

                    mod when_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_capacity() {
                            for capacity in 1..32 {
                                for additional in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.shrink(capacity + additional).expect_err("already less capacity");

                                    assert_eq!(actual.capacity(), capacity);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_initialize_elements() {
                            for capacity in 1..32 {
                                for additional in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.shrink(capacity + additional).expect_err("already less capacity");

                                    assert_eq!(actual.initialized, 0);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_reallocate_memory() {
                            for capacity in 1..32 {
                                for additional in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    let allocation = actual.buffer;

                                    _ = actual.shrink(capacity + additional).expect_err("already less capacity");

                                    assert_eq!(actual.buffer, allocation);
                                }
                            }
                        }

                        #[test]
                        fn then_capacity_many_elements_can_be_appended_without_reallocating_memory() {
                            for capacity in 1..32 {
                                for additional in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.shrink(capacity + additional).expect_err("already less capacity");

                                    let allocation = actual.buffer;

                                    for element in 0..capacity {
                                        _ = actual.append(element).expect("uses capacity");
                                    }

                                    assert_eq!(actual.buffer, allocation);
                                }
                            }
                        }
                    }

                    mod when_not_empty {
                        use super::*;

                        #[test]
                        fn then_decreases_front_capacity_to_zero() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let mut actual: Dynamic<_> = (0..elements).collect();

                                        _ = actual.reserve_front(capacity).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, capacity);
                                        debug_assert_eq!(actual.back_capacity, 0);

                                        _ = actual.shrink(capacity + additional).expect_err("already less capacity");

                                        assert_eq!(actual.front_capacity, 0);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_increases_back_capacity_to_front_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let mut actual: Dynamic<_> = (0..elements).collect();

                                        _ = actual.reserve_front(capacity).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, capacity);
                                        debug_assert_eq!(actual.back_capacity, 0);

                                        _ = actual.shrink(capacity + additional).expect_err("already less capacity");

                                        assert_eq!(actual.back_capacity, capacity);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_initialized_elements() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let expected = 0..elements;

                                        let mut actual: Dynamic<_> = expected.clone().collect();

                                        _ = actual.reserve_front(capacity).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, capacity);
                                        debug_assert_eq!(actual.back_capacity, 0);

                                        _ = actual.shrink(capacity + additional).expect_err("already less capacity");

                                        assert!(actual.eq(expected));
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_reallocate_memory() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let mut actual: Dynamic<_> = (0..elements).collect();

                                        _ = actual.reserve_front(capacity).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, capacity);
                                        debug_assert_eq!(actual.back_capacity, 0);

                                        let allocation = actual.buffer;

                                        _ = actual.shrink(capacity + additional).expect_err("already less capacity");

                                        assert_eq!(actual.buffer, allocation);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_capacity_many_elements_can_be_appended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let expected = 0..elements;

                                        let mut actual: Dynamic<_> = expected.clone().collect();

                                        _ = actual.reserve_front(capacity).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, capacity);
                                        debug_assert_eq!(actual.back_capacity, 0);

                                        _ = actual.shrink(capacity + additional).expect_err("already less capacity");

                                        let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                        for _ in 0..capacity {
                                            // NOTE: this is distinct from the expected values.
                                            _ = actual.append(usize::MAX).expect("uses capacity");
                                        }

                                        assert!(pointers.iter().copied().eq(expected));
                                    }
                                }
                            }
                        }
                    }
                }

                mod when_exactly_requested {
                    use super::*;

                    mod when_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_capacity() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_front(capacity).expect("successfull allocation");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, capacity);
                                debug_assert_eq!(actual.back_capacity, 0);

                                _ = actual.shrink(capacity).expect("exactly enough capacity");

                                assert_eq!(actual.capacity(), capacity);
                            }
                        }

                        #[test]
                        fn then_does_not_initialize_elements() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_front(capacity).expect("successfull allocation");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, capacity);
                                debug_assert_eq!(actual.back_capacity, 0);

                                _ = actual.shrink(capacity).expect("exactly enough capacity");

                                assert_eq!(actual.initialized, 0);
                            }
                        }

                        #[test]
                        fn then_does_not_reallocate_memory() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_front(capacity).expect("successfull allocation");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, capacity);
                                debug_assert_eq!(actual.back_capacity, 0);

                                let allocation = actual.buffer;

                                _ = actual.shrink(capacity).expect("exactly enough capacity");

                                assert_eq!(actual.buffer, allocation);
                            }
                        }

                        #[test]
                        fn then_requested_many_elements_can_be_appended_without_reallocating_memory() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_front(capacity).expect("successfull allocation");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, capacity);
                                debug_assert_eq!(actual.back_capacity, 0);

                                _ = actual.shrink(capacity).expect("exactly enough capacity");

                                let allocation = actual.buffer;

                                for element in 0..capacity {
                                    _ = actual.append(element).expect("uses capacity");
                                }

                                assert_eq!(actual.buffer, allocation);
                            }
                        }
                    }

                    mod when_not_empty {
                        use super::*;

                        #[test]
                        fn then_decreases_front_capacity_to_zero() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let mut actual: Dynamic<_> = (0..elements).collect();

                                    _ = actual.reserve_front(capacity).expect("successfull allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.shrink(capacity).expect("exactly enough capacity");

                                    assert_eq!(actual.front_capacity, 0);
                                }
                            }
                        }

                        #[test]
                        fn then_increases_back_capacity_to_front_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let mut actual: Dynamic<_> = (0..elements).collect();

                                    _ = actual.reserve_front(capacity).expect("successfull allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.shrink(capacity).expect("exactly enough capacity");

                                    assert_eq!(actual.back_capacity, capacity);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_initialized_elements() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let expected  = 0..elements;

                                    let mut actual: Dynamic<_> = expected.clone().collect();

                                    _ = actual.reserve_front(capacity).expect("successfull allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.shrink(capacity).expect("exactly enough capacity");

                                    assert!(actual.eq(expected));
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_reallocate_memory() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let mut actual: Dynamic<_> = (0..elements).collect();

                                    _ = actual.reserve_front(capacity).expect("successfull allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    let allocation = actual.buffer;

                                    _ = actual.shrink(capacity).expect("exactly enough capacity");

                                    assert_eq!(actual.buffer, allocation);
                                }
                            }
                        }

                        #[test]
                        fn then_requested_many_elements_can_be_appended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let expected  = 0..elements;

                                    let mut actual: Dynamic<_> = expected.clone().collect();

                                    _ = actual.reserve_front(capacity).expect("successfull allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.shrink(capacity).expect("exactly enough capacity");

                                    let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                    for _ in 0..capacity {
                                        // NOTE: this is distinct from the expected values.
                                        _ = actual.append(usize::MAX).expect("uses capacity");
                                    }

                                    assert!(pointers.iter().copied().eq(expected));
                                }
                            }
                        }
                    }
                }

                mod when_more_than_requested {
                    use super::*;

                    mod when_empty {
                        use super::*;

                        #[test]
                        fn then_decreases_capacity_to_exactly_requested() {
                            for capacity in 1..32 {
                                for additional in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_front(capacity + additional).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, capacity + additional);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.shrink(capacity).expect("successful reallocation");

                                    assert_eq!(actual.capacity(), capacity);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_initialize_elements() {
                            for capacity in 1..32 {
                                for additional in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_front(capacity + additional).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, capacity + additional);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.shrink(capacity).expect("successful reallocation");

                                    assert_eq!(actual.initialized, 0);
                                }
                            }
                        }

                        #[test]
                        fn then_requested_many_elements_can_be_appended_without_reallocating_memory() {
                            for capacity in 1..32 {
                                for additional in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_front(capacity + additional).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, capacity + additional);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.shrink(capacity).expect("successful reallocation");

                                    let allocation = actual.buffer;

                                    for element in 0..capacity {
                                        _ = actual.append(element).expect("uses capacity");
                                    }

                                    assert_eq!(actual.buffer, allocation);
                                }
                            }
                        }
                    }

                    mod when_not_empty {
                        use super::*;

                        #[test]
                        fn then_decreases_front_capacity_to_zero() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let mut actual: Dynamic<_> = (0..elements).collect();

                                        _ = actual.reserve_front(capacity + additional).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, capacity + additional);
                                        debug_assert_eq!(actual.back_capacity, 0);

                                        _ = actual.shrink(capacity).expect("successful reallocation");

                                        assert_eq!(actual.front_capacity, 0);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_increases_back_capacity_to_exactly_requested() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let mut actual: Dynamic<_> = (0..elements).collect();

                                        _ = actual.reserve_front(capacity + additional).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, capacity + additional);
                                        debug_assert_eq!(actual.back_capacity, 0);

                                        _ = actual.shrink(capacity).expect("successful reallocation");

                                        assert_eq!(actual.back_capacity, capacity);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_initialized_elements() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let expected = 0..elements;

                                        let mut actual: Dynamic<_> = expected.clone().collect();

                                        _ = actual.reserve_front(capacity + additional).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, capacity + additional);
                                        debug_assert_eq!(actual.back_capacity, 0);

                                        _ = actual.shrink(capacity).expect("successful reallocation");

                                        assert!(actual.eq(expected));
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_requested_many_elements_can_be_appended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let expected = 0..elements;

                                        let mut actual: Dynamic<_> = expected.clone().collect();

                                        _ = actual.reserve_front(capacity + additional).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, capacity + additional);
                                        debug_assert_eq!(actual.back_capacity, 0);

                                        _ = actual.shrink(capacity).expect("successful reallocation");

                                        let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                        for _ in 0..capacity {
                                            // NOTE: this is distinct from the expected values.
                                            _ = actual.append(usize::MAX).expect("uses capacity");
                                        }

                                        assert!(pointers.iter().copied().eq(expected));
                                    }
                                }
                            }
                        }
                    }
                }
            }

            mod when_only_back_capacity {
                use super::*;

                mod when_zero_requested {
                    use super::*;

                    mod when_empty {
                        use super::*;

                        #[test]
                        fn then_decreases_capacity_to_zero() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_back(capacity).expect("successful allocation");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, 0);
                                debug_assert_eq!(actual.back_capacity, capacity);

                                _ = actual.shrink(0).expect("successful deallocation");

                                assert_eq!(actual.capacity(), 0);
                            }
                        }

                        #[test]
                        fn then_does_not_initialize_elements() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_back(capacity).expect("successful allocation");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, 0);
                                debug_assert_eq!(actual.back_capacity, capacity);

                                _ = actual.shrink(0).expect("successful deallocation");

                                assert_eq!(actual.initialized, 0);
                            }
                        }
                    }

                    mod when_not_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_front_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let mut actual: Dynamic<_> = (0..elements).collect();

                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    _ = actual.shrink(0).expect("successful deallocation");

                                    assert_eq!(actual.front_capacity, 0);
                                }
                            }
                        }

                        #[test]
                        fn then_decreases_back_capacity_to_zero() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let mut actual: Dynamic<_> = (0..elements).collect();

                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    _ = actual.shrink(0).expect("successful deallocation");

                                    assert_eq!(actual.back_capacity, 0);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_initialized_elements() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let expected = 0..elements;

                                    let mut actual: Dynamic<_> = expected.clone().collect();

                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    _ = actual.shrink(0).expect("successful deallocation");

                                    assert!(actual.eq(expected));
                                }
                            }
                        }
                    }
                }

                mod when_less_than_requested {
                    use super::*;

                    mod when_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_capacity() {
                            for capacity in 1..32 {
                                for additional in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    _ = actual.shrink(capacity + additional).expect_err("already less capacity");

                                    assert_eq!(actual.capacity(), capacity);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_initialize_elements() {
                            for capacity in 1..32 {
                                for additional in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    _ = actual.shrink(capacity + additional).expect_err("already less capacity");

                                    assert_eq!(actual.initialized, 0);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_reallocate_memory() {
                            for capacity in 1..32 {
                                for additional in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    let allocation = actual.buffer;

                                    _ = actual.shrink(capacity + additional).expect_err("already less capacity");

                                    assert_eq!(actual.buffer, allocation);
                                }
                            }
                        }

                        #[test]
                        fn then_capacity_many_elements_can_be_appended_without_reallocating_memory() {
                            for capacity in 1..32 {
                                for additional in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    _ = actual.shrink(capacity + additional).expect_err("already less capacity");

                                    let allocation = actual.buffer;

                                    for element in 0..capacity {
                                        _ = actual.append(element).expect("uses capacity");
                                    }

                                    assert_eq!(actual.buffer, allocation);
                                }
                            }
                        }
                    }

                    mod when_not_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_front_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let mut actual: Dynamic<_> = (0..elements).collect();

                                        _ = actual.reserve_back(capacity).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, 0);
                                        debug_assert_eq!(actual.back_capacity, capacity);

                                        _ = actual.shrink(capacity + additional).expect_err("already less capacity");

                                        assert_eq!(actual.front_capacity, 0);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_back_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let mut actual: Dynamic<_> = (0..elements).collect();

                                        _ = actual.reserve_back(capacity).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, 0);
                                        debug_assert_eq!(actual.back_capacity, capacity);

                                        _ = actual.shrink(capacity + additional).expect_err("already less capacity");

                                        assert_eq!(actual.back_capacity, capacity);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_initialized_elements() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let expected = 0..elements;

                                        let mut actual: Dynamic<_> = expected.clone().collect();

                                        _ = actual.reserve_back(capacity).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, 0);
                                        debug_assert_eq!(actual.back_capacity, capacity);

                                        _ = actual.shrink(capacity + additional).expect_err("already less capacity");

                                        assert!(actual.eq(expected));
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_reallocate_memory() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let mut actual: Dynamic<_> = (0..elements).collect();

                                        _ = actual.reserve_back(capacity).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, 0);
                                        debug_assert_eq!(actual.back_capacity, capacity);

                                        let allocation = actual.buffer;

                                        _ = actual.shrink(capacity + additional).expect_err("already less capacity");

                                        assert_eq!(actual.buffer, allocation);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_capacity_many_elements_can_be_appended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let expected = 0..elements;

                                        let mut actual: Dynamic<_> = expected.clone().collect();

                                        _ = actual.reserve_back(capacity).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, 0);
                                        debug_assert_eq!(actual.back_capacity, capacity);

                                        _ = actual.shrink(capacity + additional).expect_err("already less capacity");

                                        let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                        for _ in 0..capacity {
                                            // NOTE: this is distinct from the expected values.
                                            _ = actual.append(usize::MAX).expect("uses capacity");
                                        }

                                        assert!(pointers.iter().copied().eq(expected));
                                    }
                                }
                            }
                        }
                    }
                }

                mod when_exactly_requested {
                    use super::*;

                    mod when_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_capacity() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_back(capacity).expect("successful allocation");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, 0);
                                debug_assert_eq!(actual.back_capacity, capacity);

                                _ = actual.shrink(capacity).expect("exactly enough capacity");

                                assert_eq!(actual.capacity(), capacity);
                            }
                        }

                        #[test]
                        fn then_does_not_initialize_elements() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_back(capacity).expect("successful allocation");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, 0);
                                debug_assert_eq!(actual.back_capacity, capacity);

                                _ = actual.shrink(capacity).expect("exactly enough capacity");

                                assert_eq!(actual.initialized, 0);
                            }
                        }

                        #[test]
                        fn then_does_not_reallocate_memory() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_back(capacity).expect("successful allocation");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, 0);
                                debug_assert_eq!(actual.back_capacity, capacity);

                                let allocation = actual.buffer;

                                _ = actual.shrink(capacity).expect("exactly enough capacity");

                                assert_eq!(actual.buffer, allocation);
                            }
                        }

                        #[test]
                        fn then_requested_many_elements_can_be_appended_without_reallocating_memory() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_back(capacity).expect("successful allocation");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, 0);
                                debug_assert_eq!(actual.back_capacity, capacity);

                                _ = actual.shrink(capacity).expect("exactly enough capacity");

                                let allocation = actual.buffer;

                                for element in 0..capacity {
                                    _ = actual.append(element).expect("uses capacity");
                                }

                                assert_eq!(actual.buffer, allocation);
                            }
                        }
                    }

                    mod when_not_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_front_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let mut actual: Dynamic<_> = (0..elements).collect();

                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    _ = actual.shrink(capacity).expect("exactly enough capacity");

                                    assert_eq!(actual.front_capacity, 0);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_back_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let mut actual: Dynamic<_> = (0..elements).collect();

                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    _ = actual.shrink(capacity).expect("exactly enough capacity");

                                    assert_eq!(actual.back_capacity, capacity);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_initialized_elements() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let expected = 0..elements;

                                    let mut actual: Dynamic<_> = expected.clone().collect();

                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    _ = actual.shrink(capacity).expect("exactly enough capacity");

                                    assert!(actual.eq(expected));
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_reallocate_memory() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let mut actual: Dynamic<_> = (0..elements).collect();

                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    let allocation = actual.buffer;

                                    _ = actual.shrink(capacity).expect("exactly enough capacity");

                                    assert_eq!(actual.buffer, allocation);
                                }
                            }
                        }

                        #[test]
                        fn then_requested_many_elements_can_be_appended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let expected = 0..elements;

                                    let mut actual: Dynamic<_> = expected.clone().collect();

                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    _ = actual.shrink(capacity).expect("exactly enough capacity");

                                    let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                    for _ in 0..capacity {
                                        // NOTE: this is distinct from the expected values.
                                        _ = actual.append(usize::MAX).expect("uses capacity");
                                    }

                                    assert!(pointers.iter().copied().eq(expected));
                                }
                            }
                        }
                    }
                }

                mod when_more_than_requested {
                    use super::*;

                    mod when_empty {
                        use super::*;

                        #[test]
                        fn then_decreases_capacity_to_exactly_requested() {
                            for capacity in 1..32 {
                                for additional in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_back(capacity + additional).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, capacity + additional);

                                    _ = actual.shrink(capacity).expect("successful reallocation");

                                    assert_eq!(actual.capacity(), capacity);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_initialize_elements() {
                            for capacity in 1..32 {
                                for additional in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_back(capacity + additional).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, capacity + additional);

                                    _ = actual.shrink(capacity).expect("successful reallocation");

                                    assert_eq!(actual.initialized, 0);
                                }
                            }
                        }

                        #[test]
                        fn then_requested_many_elements_can_be_appended_without_reallocating_memory() {
                            for capacity in 1..32 {
                                for additional in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_back(capacity + additional).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, capacity + additional);

                                    _ = actual.shrink(capacity).expect("successful reallocation");

                                    let allocation = actual.buffer;

                                    for element in 0..capacity {
                                        _ = actual.append(element).expect("uses capacity");
                                    }

                                    assert_eq!(actual.buffer, allocation);
                                }
                            }
                        }
                    }

                    mod when_not_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_front_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let mut actual: Dynamic<_> = (0..elements).collect();

                                        _ = actual.reserve_back(capacity + additional).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, 0);
                                        debug_assert_eq!(actual.back_capacity, capacity + additional);

                                        _ = actual.shrink(capacity).expect("successful reallocation");

                                        assert_eq!(actual.front_capacity, 0);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_back_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let mut actual: Dynamic<_> = (0..elements).collect();

                                        _ = actual.reserve_back(capacity + additional).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, 0);
                                        debug_assert_eq!(actual.back_capacity, capacity + additional);

                                        _ = actual.shrink(capacity).expect("successful reallocation");

                                        assert_eq!(actual.back_capacity, capacity);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_initialized_elements() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let expected = 0..elements;

                                        let mut actual: Dynamic<_> = expected.clone().collect();

                                        _ = actual.reserve_back(capacity + additional).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, 0);
                                        debug_assert_eq!(actual.back_capacity, capacity + additional);

                                        _ = actual.shrink(capacity).expect("successful reallocation");

                                        assert!(actual.eq(expected));
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_requested_many_elements_can_be_appended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let expected = 0..elements;

                                        let mut actual: Dynamic<_> = expected.clone().collect();

                                        _ = actual.reserve_back(capacity + additional).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, 0);
                                        debug_assert_eq!(actual.back_capacity, capacity + additional);

                                        _ = actual.shrink(capacity).expect("successful reallocation");

                                        let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                        for _ in 0..capacity {
                                            // NOTE: this is distinct from the expected values.
                                            _ = actual.append(usize::MAX).expect("uses capacity");
                                        }

                                        assert!(pointers.iter().copied().eq(expected));
                                    }
                                }
                            }
                        }
                    }
                }
            }

            mod when_both_front_and_back_capacity {
                use super::*;

                mod when_zero_requested {
                    use super::*;

                    mod when_empty {
                        use super::*;

                        #[test]
                        fn then_decreases_capacity_to_zero() {
                            for front in 1..32 {
                                for back in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_back(front + back).expect("successful allocation");

                                    _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, front);
                                    debug_assert_eq!(actual.back_capacity, back);

                                    _ = actual.shrink(0).expect("successful deallocation");

                                    assert_eq!(actual.capacity(), 0);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_initialize_elements() {
                            for front in 1..32 {
                                for back in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_back(front + back).expect("successful allocation");

                                    _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, front);
                                    debug_assert_eq!(actual.back_capacity, back);

                                    _ = actual.shrink(0).expect("successful deallocation");

                                    assert_eq!(actual.initialized, 0);
                                }
                            }
                        }
                    }

                    mod when_not_empty {
                        use super::*;

                        #[test]
                        fn then_decreases_front_capacity_to_zero() {
                            for elements in 1..32 {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        let mut actual: Dynamic<_> = (0..elements).collect();

                                        _ = actual.reserve_front(front).expect("successful allocation");
                                        _ = actual.reserve_back(back).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.shrink(0).expect("successful reallocation");

                                        assert_eq!(actual.front_capacity, 0);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_decreases_back_capacity_to_zero() {
                            for elements in 1..32 {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        let mut actual: Dynamic<_> = (0..elements).collect();

                                        _ = actual.reserve_front(front).expect("successful allocation");
                                        _ = actual.reserve_back(back).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.shrink(0).expect("successful reallocation");

                                        assert_eq!(actual.back_capacity, 0);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_initialized_elements() {
                            for elements in 1..32 {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        let expected = 0..elements;

                                        let mut actual: Dynamic<_> = expected.clone().collect();

                                        _ = actual.reserve_front(front).expect("successful allocation");
                                        _ = actual.reserve_back(back).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.shrink(0).expect("successful reallocation");

                                        assert!(actual.eq(expected));
                                    }
                                }
                            }
                        }
                    }
                }

                mod when_both_less_than_requested {
                    use super::*;

                    mod when_sum_is_less_than_requested {
                        use super::*;

                        mod when_empty {
                            use super::*;

                            #[test]
                            fn then_does_not_modify_capacity() {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        for additional in 1..32 {
                                            let mut actual = Dynamic::<usize>::default();

                                            _ = actual.reserve_back(front + back).expect("successful allocation");

                                            _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                            debug_assert_eq!(actual.initialized, 0);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.shrink(front + back + additional).expect_err("already less capacity");

                                            assert_eq!(actual.capacity(), front + back);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_initialize_elements() {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        for additional in 1..32 {
                                            let mut actual = Dynamic::<usize>::default();

                                            _ = actual.reserve_back(front + back).expect("successful allocation");

                                            _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                            debug_assert_eq!(actual.initialized, 0);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.shrink(front + back + additional).expect_err("already less capacity");

                                            assert_eq!(actual.initialized, 0);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_capacity_many_elements_can_be_appended_without_reallocating_memory() {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        for additional in 1..32 {
                                            let mut actual = Dynamic::<usize>::default();

                                            _ = actual.reserve_back(front + back).expect("successful allocation");

                                            _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                            debug_assert_eq!(actual.initialized, 0);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.shrink(front + back + additional).expect_err("already less capacity");

                                            let allocation = actual.buffer;

                                            for element in 0..(front + back) {
                                                _ = actual.append(element).expect("uses capacity");
                                            }

                                            assert_eq!(actual.buffer, allocation);
                                        }
                                    }
                                }
                            }
                        }

                        mod when_not_empty {
                            use super::*;

                            #[test]
                            fn then_decreases_front_capacity_to_zero() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            for additional in 1..32 {
                                                let mut actual: Dynamic<_> = (0..elements).collect();

                                                _ = actual.reserve_front(front).expect("successful allocation");
                                                _ = actual.reserve_back(back).expect("successful allocation");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front);
                                                debug_assert_eq!(actual.back_capacity, back);

                                                _ = actual.shrink(front + back + additional).expect_err("already less capacity");

                                                assert_eq!(actual.front_capacity, 0);
                                            }
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_increases_back_capacity_to_sum_with_front_capacity() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            for additional in 1..32 {
                                                let mut actual: Dynamic<_> = (0..elements).collect();

                                                _ = actual.reserve_front(front).expect("successful allocation");
                                                _ = actual.reserve_back(back).expect("successful allocation");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front);
                                                debug_assert_eq!(actual.back_capacity, back);

                                                _ = actual.shrink(front + back + additional).expect_err("already less capacity");

                                                assert_eq!(actual.back_capacity, front + back);
                                            }
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_modify_initialized_elements() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            for additional in 1..32 {
                                                let expected = 0..elements;

                                                let mut actual: Dynamic<_> = expected.clone().collect();

                                                _ = actual.reserve_front(front).expect("successful allocation");
                                                _ = actual.reserve_back(back).expect("successful allocation");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front);
                                                debug_assert_eq!(actual.back_capacity, back);

                                                _ = actual.shrink(front + back + additional).expect_err("already less capacity");

                                                assert!(actual.eq(expected));
                                            }
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_capacity_many_elements_can_be_appended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            for additional in 1..32 {
                                                let expected = 0..elements;

                                                let mut actual: Dynamic<_> = expected.clone().collect();

                                                _ = actual.reserve_front(front).expect("successful allocation");
                                                _ = actual.reserve_back(back).expect("successful allocation");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front);
                                                debug_assert_eq!(actual.back_capacity, back);

                                                _ = actual.shrink(front + back + additional).expect_err("already less capacity");

                                                let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                                for _ in 0..(front + back) {
                                                    _ = actual.append(usize::MAX).expect("uses capacity");
                                                }

                                                assert!(pointers.iter().copied().eq(expected));
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }

                    mod when_sum_is_exactly_requested {
                        use super::*;

                        mod when_empty {
                            use super::*;

                            #[test]
                            fn then_does_not_modify_capacity() {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(front + back).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.shrink(front + back).expect("exactly enough capacity");

                                        assert_eq!(actual.capacity(), front + back);
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_initialize_elements() {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(front + back).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.shrink(front + back).expect("exactly enough capacity");

                                        assert_eq!(actual.initialized, 0);
                                    }
                                }
                            }

                            #[test]
                            fn then_requested_many_elements_can_be_appended_without_reallocating_memory() {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(front + back).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.shrink(front + back).expect("exactly enough capacity");

                                        let allocation = actual.buffer;

                                        for element in 0..(front + back) {
                                            _ = actual.append(element).expect("uses capacity");
                                        }

                                        assert_eq!(actual.buffer, allocation);
                                    }
                                }
                            }
                        }

                        mod when_not_empty {
                            use super::*;

                            #[test]
                            fn then_decreases_front_capacity_to_zero() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.shrink(front + back).expect("exactly enough capacity");

                                            assert_eq!(actual.front_capacity, 0);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_increases_back_capacity_to_sum_with_front_capacity() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.shrink(front + back).expect("exactly enough capacity");

                                            assert_eq!(actual.back_capacity, front + back);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_modify_initialized_elements() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.shrink(front + back).expect("exactly enough capacity");

                                            assert!(actual.eq(expected));
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_requested_many_elements_can_be_appended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.shrink(front + back).expect("exactly enough capacity");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..(front + back) {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.append(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }
                        }
                    }

                    mod when_sum_is_more_than_requested {
                        use super::*;

                        mod when_empty {
                            use super::*;

                            #[test]
                            fn then_decreases_capacity_to_exactly_requested() {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        for additional in 1..usize::min(front, back) {
                                            let mut actual = Dynamic::<usize>::default();

                                            _ = actual.reserve_back(front + back).expect("successful allocation");

                                            _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                            debug_assert_eq!(actual.initialized, 0);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.shrink(front + back - additional).expect("successful reallocation");

                                            assert_eq!(actual.capacity(), front + back - additional);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_initialize_elements() {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        for additional in 1..usize::min(front, back) {
                                            let mut actual = Dynamic::<usize>::default();

                                            _ = actual.reserve_back(front + back).expect("successful allocation");

                                            _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                            debug_assert_eq!(actual.initialized, 0);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.shrink(front + back - additional).expect("successful reallocation");

                                            assert_eq!(actual.initialized, 0);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_requested_many_elements_can_be_appended_without_reallocating_memory() {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        for additional in 1..usize::min(front, back) {
                                            let mut actual = Dynamic::<usize>::default();

                                            _ = actual.reserve_back(front + back).expect("successful allocation");

                                            _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                            debug_assert_eq!(actual.initialized, 0);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.shrink(front + back - additional).expect("successful reallocation");

                                            let allocation = actual.buffer;

                                            for element in 0..(front + back - additional) {
                                                _ = actual.append(element).expect("uses capacity");
                                            }

                                            assert_eq!(actual.buffer, allocation);
                                        }
                                    }
                                }
                            }
                        }

                        mod when_not_empty {
                            use super::*;

                            #[test]
                            fn then_decreases_front_capacity_to_zero() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            for additional in 1..usize::min(front, back) {
                                                let mut actual: Dynamic<_> = (0..elements).collect();

                                                _ = actual.reserve_front(front).expect("successful allocation");
                                                _ = actual.reserve_back(back).expect("successful allocation");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front);
                                                debug_assert_eq!(actual.back_capacity, back);

                                                _ = actual.shrink(front + back - additional).expect("successful reallocation");

                                                assert_eq!(actual.front_capacity, 0);
                                            }
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_increases_back_capacity_to_exactly_requested() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            for additional in 1..usize::min(front, back) {
                                                let mut actual: Dynamic<_> = (0..elements).collect();

                                                _ = actual.reserve_front(front).expect("successful allocation");
                                                _ = actual.reserve_back(back).expect("successful allocation");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front);
                                                debug_assert_eq!(actual.back_capacity, back);

                                                _ = actual.shrink(front + back - additional).expect("successful reallocation");

                                                assert_eq!(actual.back_capacity, front + back - additional);
                                            }
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_modify_initialized_elements() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            for additional in 1..usize::min(front, back) {
                                                let expected = 0..elements;

                                                let mut actual: Dynamic<_> = expected.clone().collect();

                                                _ = actual.reserve_front(front).expect("successful allocation");
                                                _ = actual.reserve_back(back).expect("successful allocation");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front);
                                                debug_assert_eq!(actual.back_capacity, back);

                                                _ = actual.shrink(front + back - additional).expect("successful reallocation");

                                                assert!(actual.eq(expected));
                                            }
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_requested_many_elements_can_be_appended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            for additional in 1..usize::min(front, back) {
                                                let expected = 0..elements;

                                                let mut actual: Dynamic<_> = expected.clone().collect();

                                                _ = actual.reserve_front(front).expect("successful allocation");
                                                _ = actual.reserve_back(back).expect("successful allocation");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front);
                                                debug_assert_eq!(actual.back_capacity, back);

                                                _ = actual.shrink(front + back - additional).expect("successful reallocation");

                                                let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                                for _ in 0..(front + back - additional) {
                                                    // NOTE: this is distinct from the expected values.
                                                    _ = actual.append(usize::MAX).expect("uses capacity");
                                                }

                                                assert!(pointers.iter().copied().eq(expected));
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                mod when_front_is_exactly_requested {
                    use super::*;

                    mod when_back_is_less_than_requested {
                        use super::*;

                        mod when_empty {
                            use super::*;

                            #[test]
                            fn then_decreases_capacity_to_exactly_requested() {
                                for front in 1..32 {
                                    for back in 1..front {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(front + back).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.shrink(front).expect("successful reallocation");

                                        assert_eq!(actual.capacity(), front);
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_initialize_elements() {
                                for front in 1..32 {
                                    for back in 1..front {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(front + back).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.shrink(front).expect("successful reallocation");

                                        assert_eq!(actual.initialized, 0);
                                    }
                                }
                            }

                            #[test]
                            fn then_requested_many_elements_can_be_appended_without_reallocating_memory() {
                                for front in 1..32 {
                                    for back in 1..front {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(front + back).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.shrink(front).expect("successful reallocation");

                                        let allocation = actual.buffer;

                                        for element in 0..front {
                                            _ = actual.append(element).expect("uses capacity");
                                        }

                                        assert_eq!(actual.buffer, allocation);
                                    }
                                }
                            }
                        }

                        mod when_not_empty {
                            use super::*;

                            #[test]
                            fn then_decreases_front_capacity_to_zero() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..front {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.shrink(front).expect("successful reallocation");

                                            assert_eq!(actual.front_capacity, 0);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_increases_back_capacity_to_exactly_requested() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..front {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.shrink(front).expect("successful reallocation");

                                            assert_eq!(actual.back_capacity, front);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_modify_initialized_elements() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..front {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.shrink(front).expect("successful reallocation");

                                            assert!(actual.eq(expected));
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_requested_many_elements_can_be_appended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..front {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.shrink(front).expect("successful reallocation");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..front {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.append(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }
                        }
                    }

                    mod when_back_is_more_than_requested {
                        use super::*;

                        mod when_empty {
                            use super::*;

                            #[test]
                            fn then_decreases_capacity_to_exactly_requested() {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(capacity + capacity + additional).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(capacity).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, capacity);
                                        debug_assert_eq!(actual.back_capacity, capacity + additional);

                                        _ = actual.shrink(capacity).expect("successful reallocation");

                                        assert_eq!(actual.capacity(), capacity);
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_initialize_elements() {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(capacity + capacity + additional).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(capacity).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, capacity);
                                        debug_assert_eq!(actual.back_capacity, capacity + additional);

                                        _ = actual.shrink(capacity).expect("successful reallocation");

                                        assert_eq!(actual.initialized, 0);
                                    }
                                }
                            }

                            #[test]
                            fn then_requested_many_elements_can_be_appended_without_reallocating_memory() {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(capacity + capacity + additional).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(capacity).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, capacity);
                                        debug_assert_eq!(actual.back_capacity, capacity + additional);

                                        _ = actual.shrink(capacity).expect("successful reallocation");

                                        let allocation = actual.buffer;

                                        for element in 0..capacity {
                                            _ = actual.append(element).expect("uses capacity");
                                        }

                                        assert_eq!(actual.buffer, allocation);
                                    }
                                }
                            }
                        }

                        mod when_not_empty {
                            use super::*;

                            #[test]
                            fn then_decreases_front_capacity_to_zero() {
                                for elements in 1..32 {
                                    for capacity in 1..32 {
                                        for additional in 1..32 {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_back(capacity + capacity + additional).expect("successful allocation");

                                            _ = actual.shift(isize::try_from(capacity).expect("too small to wrap")).expect("enough back capacity to shift into");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, capacity);
                                            debug_assert_eq!(actual.back_capacity, capacity + additional);

                                            _ = actual.shrink(capacity).expect("successful reallocation");

                                            assert_eq!(actual.front_capacity, 0);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_decreases_back_capacity_to_exactly_requested() {
                                for elements in 1..32 {
                                    for capacity in 1..32 {
                                        for additional in 1..32 {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_back(capacity + capacity + additional).expect("successful allocation");

                                            _ = actual.shift(isize::try_from(capacity).expect("too small to wrap")).expect("enough back capacity to shift into");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, capacity);
                                            debug_assert_eq!(actual.back_capacity, capacity + additional);

                                            _ = actual.shrink(capacity).expect("successful reallocation");

                                            assert_eq!(actual.back_capacity, capacity);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_modify_initialized_elements() {
                                for elements in 1..32 {
                                    for capacity in 1..32 {
                                        for additional in 1..32 {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_back(capacity + capacity + additional).expect("successful allocation");

                                            _ = actual.shift(isize::try_from(capacity).expect("too small to wrap")).expect("enough back capacity to shift into");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, capacity);
                                            debug_assert_eq!(actual.back_capacity, capacity + additional);

                                            _ = actual.shrink(capacity).expect("successful reallocation");

                                            assert!(actual.eq(expected));
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_requested_many_elements_can_be_appended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for capacity in 1..32 {
                                        for additional in 1..32 {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_back(capacity + capacity + additional).expect("successful allocation");

                                            _ = actual.shift(isize::try_from(capacity).expect("too small to wrap")).expect("enough back capacity to shift into");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, capacity);
                                            debug_assert_eq!(actual.back_capacity, capacity + additional);

                                            _ = actual.shrink(capacity).expect("successful reallocation");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..capacity {
                                                // NOTE: this is distinct from the expected values;
                                                _ = actual.append(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                mod when_back_is_exactly_requested {
                    use super::*;

                    mod when_front_is_less_than_requested {
                        use super::*;

                        mod when_empty {
                            use super::*;

                            #[test]
                            fn then_decreases_capacity_to_exactly_requested() {
                                for back in 1..32 {
                                    for front in 1..back {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(front + back).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.shrink(back).expect("successful reallocation");

                                        assert_eq!(actual.capacity(), back);
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_initialize_elements() {
                                for back in 1..32 {
                                    for front in 1..back {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(front + back).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.shrink(back).expect("successful reallocation");

                                        assert_eq!(actual.initialized, 0);
                                    }
                                }
                            }

                            #[test]
                            fn then_requested_many_elements_can_be_appended_without_reallocating_memory() {
                                for back in 1..32 {
                                    for front in 1..back {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(front + back).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.shrink(back).expect("successful reallocation");

                                        let allocation = actual.buffer;

                                        for element in 0..back {
                                            _ = actual.append(element).expect("uses capacity");
                                        }

                                        assert_eq!(actual.buffer, allocation);
                                    }
                                }
                            }
                        }

                        mod when_not_empty {
                            use super::*;

                            #[test]
                            fn then_decreases_front_capacity_to_zero() {
                                for elements in 1..32 {
                                    for back in 1..32 {
                                        for front in 1..back {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.shrink(back).expect("successful reallocation");

                                            assert_eq!(actual.front_capacity, 0);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_modify_back_capacity() {
                                for elements in 1..32 {
                                    for back in 1..32 {
                                        for front in 1..back {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.shrink(back).expect("successful reallocation");

                                            assert_eq!(actual.back_capacity, back);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_modify_initialized_elements() {
                                for elements in 1..32 {
                                    for back in 1..32 {
                                        for front in 1..back {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.shrink(back).expect("successful reallocation");

                                            assert!(actual.eq(expected));
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_requested_many_elements_can_be_appended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for back in 1..32 {
                                        for front in 1..back {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.shrink(back).expect("successful reallocation");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..back {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.append(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }
                        }
                    }

                    mod when_front_is_more_than_requested {
                        use super::*;

                        mod when_empty {
                            use super::*;

                            #[test]
                            fn then_decreases_capacity_to_exactly_requested() {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(capacity + additional + capacity).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(capacity + additional).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, capacity + additional);
                                        debug_assert_eq!(actual.back_capacity, capacity);

                                        _ = actual.shrink(capacity).expect("successful reallocation");

                                        assert_eq!(actual.capacity(), capacity);
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_initialize_elements() {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(capacity + additional + capacity).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(capacity + additional).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, capacity + additional);
                                        debug_assert_eq!(actual.back_capacity, capacity);

                                        _ = actual.shrink(capacity).expect("successful reallocation");

                                        assert_eq!(actual.initialized, 0);
                                    }
                                }
                            }

                            #[test]
                            fn then_requested_many_elements_can_be_appended_without_reallocating_memory() {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(capacity + additional + capacity).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(capacity + additional).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, capacity + additional);
                                        debug_assert_eq!(actual.back_capacity, capacity);

                                        _ = actual.shrink(capacity).expect("successful reallocation");

                                        let allocation = actual.buffer;

                                        for element in 0..capacity {
                                            _ = actual.append(element).expect("uses capacity");
                                        }

                                        assert_eq!(actual.buffer, allocation);
                                    }
                                }
                            }
                        }

                        mod when_not_empty {
                            use super::*;

                            #[test]
                            fn then_decreases_front_capacity_to_zero() {
                                for elements in 1..32 {
                                    for capacity in 1..32 {
                                        for additional in 1..32 {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(capacity + additional).expect("successful allocation");
                                            _ = actual.reserve_back(capacity).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, capacity + additional);
                                            debug_assert_eq!(actual.back_capacity, capacity);

                                            _ = actual.shrink(capacity).expect("successful reallocation");

                                            assert_eq!(actual.front_capacity, 0);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_modify_back_capacity() {
                                for elements in 1..32 {
                                    for capacity in 1..32 {
                                        for additional in 1..32 {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(capacity + additional).expect("successful allocation");
                                            _ = actual.reserve_back(capacity).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, capacity + additional);
                                            debug_assert_eq!(actual.back_capacity, capacity);

                                            _ = actual.shrink(capacity).expect("successful reallocation");

                                            assert_eq!(actual.back_capacity, capacity);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_modify_initialized_elements() {
                                for elements in 1..32 {
                                    for capacity in 1..32 {
                                        for additional in 1..32 {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(capacity + additional).expect("successful allocation");
                                            _ = actual.reserve_back(capacity).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, capacity + additional);
                                            debug_assert_eq!(actual.back_capacity, capacity);

                                            _ = actual.shrink(capacity).expect("successful reallocation");

                                            assert!(actual.eq(expected));
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_requested_many_elements_can_be_appended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for capacity in 1..32 {
                                        for additional in 1..32 {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(capacity + additional).expect("successful allocation");
                                            _ = actual.reserve_back(capacity).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, capacity + additional);
                                            debug_assert_eq!(actual.back_capacity, capacity);

                                            _ = actual.shrink(capacity).expect("successful reallocation");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..capacity {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.append(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                mod when_both_exactly_requested {
                    use super::*;

                    mod when_empty {
                        use super::*;

                        #[test]
                        fn then_decreases_capacity_to_exactly_requested() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_back(capacity + capacity).expect("successful allocation");

                                _ = actual.shift(isize::try_from(capacity).expect("too small to wrap")).expect("enough back capacity to shift into");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, capacity);
                                debug_assert_eq!(actual.back_capacity, capacity);

                                _ = actual.shrink(capacity).expect("successful reallocation");

                                assert_eq!(actual.capacity(), capacity);
                            }
                        }

                        #[test]
                        fn then_does_not_initialize_elements() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_back(capacity + capacity).expect("successful allocation");

                                _ = actual.shift(isize::try_from(capacity).expect("too small to wrap")).expect("enough back capacity to shift into");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, capacity);
                                debug_assert_eq!(actual.back_capacity, capacity);

                                _ = actual.shrink(capacity).expect("successful reallocation");

                                assert_eq!(actual.initialized, 0);
                            }
                        }

                        #[test]
                        fn then_requested_many_elements_can_be_appended_without_reallocating_memory() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_back(capacity + capacity).expect("successful allocation");

                                _ = actual.shift(isize::try_from(capacity).expect("too small to wrap")).expect("enough back capacity to shift into");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, capacity);
                                debug_assert_eq!(actual.back_capacity, capacity);

                                _ = actual.shrink(capacity).expect("successful reallocation");

                                let allocation = actual.buffer;

                                for element in 0..capacity {
                                    _ = actual.append(element).expect("uses capacity");
                                }

                                assert_eq!(actual.buffer, allocation);
                            }
                        }
                    }

                    mod when_not_empty {
                        use super::*;

                        #[test]
                        fn then_decreases_front_capacity_to_zero() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let mut actual: Dynamic<_> = (0..elements).collect();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");
                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    _ = actual.shrink(capacity).expect("successful reallocation");

                                    assert_eq!(actual.front_capacity, 0);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_back_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let mut actual: Dynamic<_> = (0..elements).collect();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");
                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    _ = actual.shrink(capacity).expect("successful reallocation");

                                    assert_eq!(actual.back_capacity, capacity);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_initialized_elements() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let expected = 0..elements;

                                    let mut actual: Dynamic<_> = expected.clone().collect();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");
                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    _ = actual.shrink(capacity).expect("successful reallocation");

                                    assert!(actual.eq(expected));
                                }
                            }
                        }

                        #[test]
                        fn then_requested_many_elements_can_be_appended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let expected = 0..elements;

                                    let mut actual: Dynamic<_> = expected.clone().collect();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");
                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    _ = actual.shrink(capacity).expect("successful reallocation");

                                    let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                    for _ in 0..capacity {
                                        // NOTE: this is distinct from the expected values.
                                        _ = actual.append(usize::MAX).expect("uses capacity");
                                    }

                                    assert!(pointers.iter().copied().eq(expected));
                                }
                            }
                        }
                    }
                }

                mod when_front_is_more_than_requested_and_back_is_less_than_requested {
                    use super::*;

                    mod when_empty {
                        use super::*;

                        #[test]
                        fn then_decreases_capacity_to_exactly_requested() {
                            for capacity in 1..32 {
                                for more in capacity..(capacity + 32) {
                                    for less in 1..capacity {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(more + less).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(more).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, more);
                                        debug_assert_eq!(actual.back_capacity, less);

                                        _ = actual.shrink(capacity).expect("successful reallocation");

                                        assert_eq!(actual.capacity(), capacity);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_initialize_elements() {
                            for capacity in 1..32 {
                                for more in capacity..(capacity + 32) {
                                    for less in 1..capacity {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(more + less).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(more).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, more);
                                        debug_assert_eq!(actual.back_capacity, less);

                                        _ = actual.shrink(capacity).expect("successful reallocation");

                                        assert_eq!(actual.initialized, 0);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_requested_many_elements_can_be_appended_without_reallocating_memory() {
                            for capacity in 1..32 {
                                for more in capacity..(capacity + 32) {
                                    for less in 1..capacity {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(more + less).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(more).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, more);
                                        debug_assert_eq!(actual.back_capacity, less);

                                        _ = actual.shrink(capacity).expect("successful reallocation");

                                        let allocation = actual.buffer;

                                        for element in 0..capacity {
                                            _ = actual.append(element).expect("uses capacity");
                                        }

                                        assert_eq!(actual.buffer, allocation);
                                    }
                                }
                            }
                        }
                    }

                    mod when_not_empty {
                        use super::*;

                        #[test]
                        fn then_decreases_front_capacity_to_zero() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for more in capacity..(capacity + 32) {
                                        for less in 1..capacity {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(more).expect("successful allocation");
                                            _ = actual.reserve_back(less).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, more);
                                            debug_assert_eq!(actual.back_capacity, less);

                                            _ = actual.shrink(capacity).expect("successful reallocation");

                                            assert_eq!(actual.front_capacity, 0);
                                        }
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_increases_back_capacity_to_exactly_requested() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for more in capacity..(capacity + 32) {
                                        for less in 1..capacity {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(more).expect("successful allocation");
                                            _ = actual.reserve_back(less).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, more);
                                            debug_assert_eq!(actual.back_capacity, less);

                                            _ = actual.shrink(capacity).expect("successful reallocation");

                                            assert_eq!(actual.back_capacity, capacity);
                                        }
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_initialized_elements() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for more in capacity..(capacity + 32) {
                                        for less in 1..capacity {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(more).expect("successful allocation");
                                            _ = actual.reserve_back(less).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, more);
                                            debug_assert_eq!(actual.back_capacity, less);

                                            _ = actual.shrink(capacity).expect("successful reallocation");

                                            assert!(actual.eq(expected));
                                        }
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_requested_many_elements_can_be_appended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for more in capacity..(capacity + 32) {
                                        for less in 1..capacity {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(more).expect("successful allocation");
                                            _ = actual.reserve_back(less).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, more);
                                            debug_assert_eq!(actual.back_capacity, less);

                                            _ = actual.shrink(capacity).expect("successful reallocation");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..capacity {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.append(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                mod when_front_is_less_than_requested_and_back_is_more_than_requested {
                    use super::*;

                    mod when_empty {
                        use super::*;

                        #[test]
                        fn then_decreases_capacity_to_exactly_requested() {
                            for capacity in 1..32 {
                                for more in capacity..(capacity + 32) {
                                    for less in 1..capacity {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(less + more).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(less).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, less);
                                        debug_assert_eq!(actual.back_capacity, more);

                                        _ = actual.shrink(capacity).expect("successful reallocation");

                                        assert_eq!(actual.capacity(), capacity);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_initialize_elements() {
                            for capacity in 1..32 {
                                for more in capacity..(capacity + 32) {
                                    for less in 1..capacity {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(less + more).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(less).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, less);
                                        debug_assert_eq!(actual.back_capacity, more);

                                        _ = actual.shrink(capacity).expect("successful reallocation");

                                        assert_eq!(actual.initialized, 0);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_requested_many_elements_can_be_appended_without_reallocating_memory() {
                            for capacity in 1..32 {
                                for more in capacity..(capacity + 32) {
                                    for less in 1..capacity {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(less + more).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(less).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, less);
                                        debug_assert_eq!(actual.back_capacity, more);

                                        _ = actual.shrink(capacity).expect("successful reallocation");

                                        let allocation = actual.buffer;

                                        for element in 0..capacity {
                                            _ = actual.append(element).expect("uses capacity");
                                        }

                                        assert_eq!(actual.buffer, allocation);
                                    }
                                }
                            }
                        }
                    }

                    mod when_not_empty {
                        use super::*;

                        #[test]
                        fn then_decreases_front_capacity_to_zero() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for more in capacity..(capacity + 32) {
                                        for less in 1..capacity {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(less).expect("successful allocation");
                                            _ = actual.reserve_back(more).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, less);
                                            debug_assert_eq!(actual.back_capacity, more);

                                            _ = actual.shrink(capacity).expect("successful reallocation");

                                            assert_eq!(actual.front_capacity, 0);
                                        }
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_decreases_back_capacity_to_exactly_requested() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for more in capacity..(capacity + 32) {
                                        for less in 1..capacity {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(less).expect("successful allocation");
                                            _ = actual.reserve_back(more).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, less);
                                            debug_assert_eq!(actual.back_capacity, more);

                                            _ = actual.shrink(capacity).expect("successful reallocation");

                                            assert_eq!(actual.back_capacity, capacity);
                                        }
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_initialized_elements() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for more in capacity..(capacity + 32) {
                                        for less in 1..capacity {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(less).expect("successful allocation");
                                            _ = actual.reserve_back(more).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, less);
                                            debug_assert_eq!(actual.back_capacity, more);

                                            _ = actual.shrink(capacity).expect("successful reallocation");

                                            assert!(actual.eq(expected));
                                        }
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_requested_many_elements_can_be_appended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for more in capacity..(capacity + 32) {
                                        for less in 1..capacity {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(less).expect("successful allocation");
                                            _ = actual.reserve_back(more).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, less);
                                            debug_assert_eq!(actual.back_capacity, more);

                                            _ = actual.shrink(capacity).expect("successful reallocation");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..capacity {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.append(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                mod when_both_more_than_requested {
                    use super::*;

                    mod when_empty {
                        use super::*;

                        #[test]
                        fn then_decreases_capacity_to_exactly_requested() {
                            for capacity in 1..32 {
                                for additional_front in 1..32 {
                                    for additional_back in 1..32 {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(capacity + additional_front + capacity + additional_back).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(capacity + additional_front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, capacity + additional_front);
                                        debug_assert_eq!(actual.back_capacity, capacity + additional_back);

                                        _ = actual.shrink(capacity).expect("successful reallocation");

                                        assert_eq!(actual.capacity(), capacity);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_initialize_elements() {
                            for capacity in 1..32 {
                                for additional_front in 1..32 {
                                    for additional_back in 1..32 {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(capacity + additional_front + capacity + additional_back).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(capacity + additional_front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, capacity + additional_front);
                                        debug_assert_eq!(actual.back_capacity, capacity + additional_back);

                                        _ = actual.shrink(capacity).expect("successful reallocation");

                                        assert_eq!(actual.initialized, 0);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_requested_many_elements_can_be_appended_without_reallocating_memory() {
                            for capacity in 1..32 {
                                for additional_front in 1..32 {
                                    for additional_back in 1..32 {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(capacity + additional_front + capacity + additional_back).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(capacity + additional_front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, capacity + additional_front);
                                        debug_assert_eq!(actual.back_capacity, capacity + additional_back);

                                        _ = actual.shrink(capacity).expect("successful reallocation");

                                        let allocation = actual.buffer;

                                        for element in 0..capacity {
                                            _ = actual.append(element).expect("uses capacity");
                                        }

                                        assert_eq!(actual.buffer, allocation);
                                    }
                                }
                            }
                        }
                    }

                    mod when_not_empty {
                        use super::*;

                        #[test]
                        fn then_decreases_front_capacity_to_zero() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional_front in 1..32 {
                                        for additional_back in 1..32 {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(capacity + additional_front).expect("successful allocation");
                                            _ = actual.reserve_back(capacity + additional_back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, capacity + additional_front);
                                            debug_assert_eq!(actual.back_capacity, capacity + additional_back);

                                            _ = actual.shrink(capacity).expect("successful reallocation");

                                            assert_eq!(actual.front_capacity, 0);
                                        }
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_decreases_back_capacity_to_exactly_requested() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional_front in 1..32 {
                                        for additional_back in 1..32 {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(capacity + additional_front).expect("successful allocation");
                                            _ = actual.reserve_back(capacity + additional_back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, capacity + additional_front);
                                            debug_assert_eq!(actual.back_capacity, capacity + additional_back);

                                            _ = actual.shrink(capacity).expect("successful reallocation");

                                            assert_eq!(actual.back_capacity, capacity);
                                        }
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_initialized_elements() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional_front in 1..32 {
                                        for additional_back in 1..32 {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(capacity + additional_front).expect("successful allocation");
                                            _ = actual.reserve_back(capacity + additional_back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, capacity + additional_front);
                                            debug_assert_eq!(actual.back_capacity, capacity + additional_back);

                                            _ = actual.shrink(capacity).expect("successful reallocation");

                                            assert!(actual.eq(expected));
                                        }
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_requested_many_elements_can_be_appended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional_front in 1..32 {
                                        for additional_back in 1..32 {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(capacity + additional_front).expect("successful allocation");
                                            _ = actual.reserve_back(capacity + additional_back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, capacity + additional_front);
                                            debug_assert_eq!(actual.back_capacity, capacity + additional_back);

                                            _ = actual.shrink(capacity).expect("successful reallocation");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..capacity {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.append(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        mod shrink_front {
            use super::*;

            mod when_no_capacity {
                use super::*;

                mod when_zero_requested {
                    use super::*;

                    mod when_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_capacity() {
                            let mut actual = Dynamic::<usize>::default();

                            debug_assert_eq!(actual.initialized, 0);
                            debug_assert_eq!(actual.front_capacity, 0);
                            debug_assert_eq!(actual.back_capacity, 0);

                            _ = actual.shrink_front(0).expect("already no allocation");

                            assert_eq!(actual.capacity(), 0);
                        }

                        #[test]
                        fn then_does_not_initialize_elements() {
                            let mut actual = Dynamic::<usize>::default();

                            debug_assert_eq!(actual.initialized, 0);
                            debug_assert_eq!(actual.front_capacity, 0);
                            debug_assert_eq!(actual.back_capacity, 0);

                            _ = actual.shrink_front(0).expect("already no allocation");

                            assert_eq!(actual.initialized, 0);
                        }
                    }

                    mod when_not_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_front_capacity() {
                            for elements in 1..32 {
                                let mut actual: Dynamic<_> = (0..elements).collect();

                                debug_assert_eq!(actual.initialized, elements);
                                debug_assert_eq!(actual.front_capacity, 0);
                                debug_assert_eq!(actual.back_capacity, 0);

                                _ = actual.shrink_front(0).expect("already no capacity");

                                assert_eq!(actual.front_capacity, 0);
                            }
                        }

                        #[test]
                        fn then_does_not_modify_back_capacity() {
                            for elements in 1..32 {
                                let mut actual: Dynamic<_> = (0..elements).collect();

                                debug_assert_eq!(actual.initialized, elements);
                                debug_assert_eq!(actual.front_capacity, 0);
                                debug_assert_eq!(actual.back_capacity, 0);

                                _ = actual.shrink_front(0).expect("already no capacity");

                                assert_eq!(actual.back_capacity, 0);
                            }
                        }

                        #[test]
                        fn then_does_not_modify_initialized_elements() {
                            for elements in 1..32 {
                                let expected = 0..elements;

                                let mut actual: Dynamic<_> = expected.clone().collect();

                                debug_assert_eq!(actual.initialized, elements);
                                debug_assert_eq!(actual.front_capacity, 0);
                                debug_assert_eq!(actual.back_capacity, 0);

                                _ = actual.shrink_front(0).expect("already no capacity");

                                assert!(actual.eq(expected));
                            }
                        }

                        #[test]
                        fn then_does_not_reallocate_memory() {
                            for elements in 1..32 {
                                let mut actual: Dynamic<_> = (0..elements).collect();

                                debug_assert_eq!(actual.initialized, elements);
                                debug_assert_eq!(actual.front_capacity, 0);
                                debug_assert_eq!(actual.back_capacity, 0);

                                let allocation = actual.buffer;

                                _ = actual.shrink_front(0).expect("already no capacity");

                                assert_eq!(actual.buffer, allocation);
                            }
                        }
                    }
                }

                mod when_more_than_zero_requested {
                    use super::*;

                    mod when_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_capacity() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, 0);
                                debug_assert_eq!(actual.back_capacity, 0);

                                _ = actual.shrink_front(capacity).expect_err("already less allocation");

                                assert_eq!(actual.capacity(), 0);
                            }
                        }

                        #[test]
                        fn then_does_not_initialize_elements() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, 0);
                                debug_assert_eq!(actual.back_capacity, 0);

                                _ = actual.shrink_front(capacity).expect_err("already less allocation");

                                assert_eq!(actual.initialized, 0);
                            }
                        }
                    }

                    mod when_not_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_front_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let mut actual: Dynamic<_> = (0..elements).collect();

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.shrink_front(capacity).expect_err("already less allocation");

                                    assert_eq!(actual.front_capacity, 0);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_back_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let mut actual: Dynamic<_> = (0..elements).collect();

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.shrink_front(capacity).expect_err("already less allocation");

                                    assert_eq!(actual.back_capacity, 0);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_initialized_elements() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let expected = 0..elements;

                                    let mut actual: Dynamic<_> = expected.clone().collect();

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.shrink_front(capacity).expect_err("already less allocation");

                                    assert!(actual.eq(expected));
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_reallocate_memory() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let mut actual: Dynamic<_> = (0..elements).collect();

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    let allocation = actual.buffer;

                                    _ = actual.shrink_front(capacity).expect_err("already less allocation");

                                    assert_eq!(actual.buffer, allocation);
                                }
                            }
                        }
                    }
                }
            }

            mod when_only_front_capacity {
                use super::*;

                mod when_zero_requested {
                    use super::*;

                    mod when_empty {
                        use super::*;

                        #[test]
                        fn then_decreases_capacity_to_zero() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_front(capacity).expect("successful allocation");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, capacity);
                                debug_assert_eq!(actual.back_capacity, 0);

                                _ = actual.shrink_front(0).expect("successful deallocation");

                                assert_eq!(actual.capacity(), 0);
                            }
                        }

                        #[test]
                        fn then_does_not_initialize_elements() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_front(capacity).expect("successful allocation");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, capacity);
                                debug_assert_eq!(actual.back_capacity, 0);

                                _ = actual.shrink_front(0).expect("successful deallocation");

                                assert_eq!(actual.initialized, 0);
                            }
                        }
                    }

                    mod when_not_empty {
                        use super::*;

                        #[test]
                        fn then_decreases_front_capacity_to_zero() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let mut actual: Dynamic<_> = (0..elements).collect();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.shrink_front(0).expect("successful reallocation");

                                    assert_eq!(actual.front_capacity, 0);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_back_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let mut actual: Dynamic<_> = (0..elements).collect();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.shrink_front(0).expect("successful reallocation");

                                    assert_eq!(actual.back_capacity, 0);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_initialized_elements() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let expected = 0..elements;

                                    let mut actual: Dynamic<_> = expected.clone().collect();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.shrink_front(0).expect("successful reallocation");

                                    assert!(actual.eq(expected));
                                }
                            }
                        }
                    }
                }

                mod when_less_than_requested {
                    use super::*;

                    mod when_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_capacity() {
                            for capacity in 1..32 {
                                for additional in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_front(capacity).expect("sucessful allocation");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.shrink_front(capacity + additional).expect_err("less capacity");

                                    assert_eq!(actual.capacity(), capacity);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_initialize_elements() {
                            for capacity in 1..32 {
                                for additional in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_front(capacity).expect("sucessful allocation");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.shrink_front(capacity + additional).expect_err("less capacity");

                                    assert_eq!(actual.initialized, 0);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_reallocate_memory() {
                            for capacity in 1..32 {
                                for additional in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_front(capacity).expect("sucessful allocation");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    let allocation = actual.buffer;

                                    _ = actual.shrink_front(capacity + additional).expect_err("less capacity");

                                    assert_eq!(actual.buffer, allocation);
                                }
                            }
                        }

                        #[test]
                        fn then_capacity_many_elements_can_be_prepended_without_reallocating_memory() {
                            for capacity in 1..32 {
                                for additional in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_front(capacity).expect("sucessful allocation");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.shrink_front(capacity + additional).expect_err("less capacity");

                                    let allocation = actual.buffer;

                                    for element in 0..capacity {
                                        _ = actual.prepend(element).expect("uses capacity");
                                    }

                                    assert_eq!(actual.buffer, allocation);
                                }
                            }
                        }
                    }

                    mod when_not_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_front_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let mut actual: Dynamic<_> = (0..elements).collect();

                                        _ = actual.reserve_front(capacity).expect("sucessful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, capacity);
                                        debug_assert_eq!(actual.back_capacity, 0);

                                        _ = actual.shrink_front(capacity + additional).expect_err("less capacity");

                                        assert_eq!(actual.front_capacity, capacity);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_back_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let mut actual: Dynamic<_> = (0..elements).collect();

                                        _ = actual.reserve_front(capacity).expect("sucessful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, capacity);
                                        debug_assert_eq!(actual.back_capacity, 0);

                                        _ = actual.shrink_front(capacity + additional).expect_err("less capacity");

                                        assert_eq!(actual.back_capacity, 0);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_initialized_elements() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let expected = 0..elements;

                                        let mut actual: Dynamic<_> = expected.clone().collect();

                                        _ = actual.reserve_front(capacity).expect("sucessful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, capacity);
                                        debug_assert_eq!(actual.back_capacity, 0);

                                        _ = actual.shrink_front(capacity + additional).expect_err("less capacity");

                                        assert!(actual.eq(expected));
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_reallocate_memory() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let mut actual: Dynamic<_> = (0..elements).collect();

                                        _ = actual.reserve_front(capacity).expect("sucessful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, capacity);
                                        debug_assert_eq!(actual.back_capacity, 0);

                                        let allocation = actual.buffer;

                                        _ = actual.shrink_front(capacity + additional).expect_err("less capacity");

                                        assert_eq!(actual.buffer, allocation);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_capacity_many_elements_can_be_prepended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let expected = 0..elements;

                                        let mut actual: Dynamic<_> = expected.clone().collect();

                                        _ = actual.reserve_front(capacity).expect("sucessful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, capacity);
                                        debug_assert_eq!(actual.back_capacity, 0);

                                        _ = actual.shrink_front(capacity + additional).expect_err("less capacity");

                                        let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                        for _ in 0..capacity {
                                            // NOTE: this is distinct from the expected values.
                                            _ = actual.prepend(usize::MAX).expect("uses capacity");
                                        }

                                        assert!(pointers.iter().copied().eq(expected));
                                    }
                                }
                            }
                        }
                    }
                }

                mod when_exactly_requested {
                    use super::*;

                    mod when_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_capacity() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_front(capacity).expect("successful allocation");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, capacity);
                                debug_assert_eq!(actual.back_capacity, 0);

                                _ = actual.shrink_front(capacity).expect("already exact capacity");

                                assert_eq!(actual.capacity(), capacity);
                            }
                        }

                        #[test]
                        fn then_does_not_initialize_elements() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_front(capacity).expect("successful allocation");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, capacity);
                                debug_assert_eq!(actual.back_capacity, 0);

                                _ = actual.shrink_front(capacity).expect("already exact capacity");

                                assert_eq!(actual.initialized, 0);
                            }
                        }

                        #[test]
                        fn then_does_not_reallocate_memory() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_front(capacity).expect("successful allocation");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, capacity);
                                debug_assert_eq!(actual.back_capacity, 0);

                                let allocation = actual.buffer;

                                _ = actual.shrink_front(capacity).expect("already exact capacity");

                                assert_eq!(actual.buffer, allocation);
                            }
                        }

                        #[test]
                        fn then_requested_many_elements_can_be_prepended_without_reallocating_memory() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_front(capacity).expect("successful allocation");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, capacity);
                                debug_assert_eq!(actual.back_capacity, 0);

                                _ = actual.shrink_front(capacity).expect("already exact capacity");

                                let allocation = actual.buffer;

                                for element in 0..capacity {
                                    _ = actual.prepend(element).expect("uses capacity");
                                }

                                assert_eq!(actual.buffer, allocation);
                            }
                        }
                    }

                    mod when_not_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_front_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let mut actual: Dynamic<_> = (0..elements).collect();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.shrink_front(capacity).expect("already exact capacity");

                                    assert_eq!(actual.front_capacity, capacity);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_back_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let mut actual: Dynamic<_> = (0..elements).collect();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.shrink_front(capacity).expect("already exact capacity");

                                    assert_eq!(actual.back_capacity, 0);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_initialized_elements() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let expected = 0..elements;

                                    let mut actual: Dynamic<_> = expected.clone().collect();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.shrink_front(capacity).expect("already exact capacity");

                                    assert!(actual.eq(expected));
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_reallocate_memory() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let mut actual: Dynamic<_> = (0..elements).collect();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    let allocation = actual.buffer;

                                    _ = actual.shrink_front(capacity).expect("already exact capacity");

                                    assert_eq!(actual.buffer, allocation);
                                }
                            }
                        }

                        #[test]
                        fn then_requested_many_elements_can_be_prepended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let expected = 0..elements;

                                    let mut actual: Dynamic<_> = expected.clone().collect();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                    _ = actual.shrink_front(capacity).expect("already exact capacity");

                                    assert!(pointers.iter().copied().eq(expected));
                                }
                            }
                        }
                    }
                }

                mod when_more_than_requested {
                    use super::*;

                    mod when_empty {
                        use super::*;

                        #[test]
                        fn then_decreases_capacity_to_exactly_requested() {
                            for capacity in 1..32 {
                                for additional in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_front(capacity + additional).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, capacity + additional);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.shrink_front(capacity).expect("successful reallocation");

                                    assert_eq!(actual.capacity(), capacity);
                                }
                            }
                        }

                        #[test]
                        fn then_requested_many_elements_can_be_prepended_without_reallocating_memory() {
                            for capacity in 1..32 {
                                for additional in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_front(capacity + additional).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, capacity + additional);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.shrink_front(capacity).expect("successful reallocation");

                                    let allocation = actual.buffer;

                                    for element in 0..capacity {
                                        _ = actual.prepend(element).expect("uses capacity");
                                    }

                                    assert_eq!(actual.buffer, allocation);
                                }
                            }
                        }
                    }

                    mod when_not_empty {
                        use super::*;

                        #[test]
                        fn then_decreases_front_capacity_to_exactly_requested() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let mut actual: Dynamic<_> = (0..elements).collect();

                                        _ = actual.reserve_front(capacity + additional).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, capacity + additional);
                                        debug_assert_eq!(actual.back_capacity, 0);

                                        _ = actual.shrink_front(capacity).expect("successful reallocation");

                                        assert_eq!(actual.front_capacity, capacity);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_back_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let mut actual: Dynamic<_> = (0..elements).collect();

                                        _ = actual.reserve_front(capacity + additional).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, capacity + additional);
                                        debug_assert_eq!(actual.back_capacity, 0);

                                        _ = actual.shrink_front(capacity).expect("successful reallocation");

                                        assert_eq!(actual.back_capacity, 0);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_initialized_elements() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let expected = 0..elements;

                                        let mut actual: Dynamic<_> = expected.clone().collect();

                                        _ = actual.reserve_front(capacity + additional).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, capacity + additional);
                                        debug_assert_eq!(actual.back_capacity, 0);

                                        _ = actual.shrink_front(capacity).expect("successful reallocation");

                                        assert!(actual.eq(expected));
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_requested_many_elements_can_be_prepended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let expected = 0..elements;

                                        let mut actual: Dynamic<_> = expected.clone().collect();

                                        _ = actual.reserve_front(capacity + additional).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, capacity + additional);
                                        debug_assert_eq!(actual.back_capacity, 0);

                                        _ = actual.shrink_front(capacity).expect("successful reallocation");

                                        let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                        for _ in 0..capacity {
                                            // NOTE: this is distinct from the expected values.
                                            _ = actual.prepend(usize::MAX).expect("uses capacity");
                                        }

                                        assert!(pointers.iter().copied().eq(expected));
                                    }
                                }
                            }
                        }
                    }
                }
            }

            mod when_only_back_capacity {
                use super::*;

                mod when_zero_requested {
                    use super::*;

                    mod when_empty {
                        use super::*;

                        #[test]
                        fn then_decreases_capacity_to_zero() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_back(capacity).expect("successful allocation");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, 0);
                                debug_assert_eq!(actual.back_capacity, capacity);

                                _ = actual.shrink_front(0).expect("successful deallocation");

                                assert_eq!(actual.capacity(), 0);
                            }
                        }

                        #[test]
                        fn then_does_not_initialize_elements() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_back(capacity).expect("successful allocation");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, 0);
                                debug_assert_eq!(actual.back_capacity, capacity);

                                _ = actual.shrink_front(0).expect("successful deallocation");

                                assert_eq!(actual.initialized, 0);
                            }
                        }
                    }

                    mod when_not_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_front_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let mut actual: Dynamic<_> = (0..elements).collect();

                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    _ = actual.shrink_front(0).expect("successful deallocation");

                                    assert_eq!(actual.front_capacity, 0);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_back_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let mut actual: Dynamic<_> = (0..elements).collect();

                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    _ = actual.shrink_front(0).expect("successful deallocation");

                                    assert_eq!(actual.back_capacity, capacity);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_initialized_elements() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let expected = 0..elements;

                                    let mut actual: Dynamic<_> = expected.clone().collect();

                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    _ = actual.shrink_front(0).expect("successful deallocation");

                                    assert!(actual.eq(expected));
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_reallocate_memory() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let mut actual: Dynamic<_> = (0..elements).collect();

                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    let allocation = actual.buffer;

                                    _ = actual.shrink_front(0).expect("successful deallocation");

                                    assert_eq!(actual.buffer, allocation);
                                }
                            }
                        }

                        #[test]
                        fn then_capacity_many_elements_can_be_appended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let expected = 0..elements;

                                    let mut actual: Dynamic<_> = expected.clone().collect();

                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    _ = actual.shrink_front(0).expect("successful deallocation");

                                    let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                    for _ in 0..capacity {
                                        // NOTE: this is distinct from the expected values.
                                        _ = actual.append(usize::MAX).expect("uses capacity");
                                    }

                                    assert!(pointers.iter().copied().eq(expected));
                                }
                            }
                        }
                    }
                }

                mod when_less_than_requested {
                    use super::*;

                    mod when_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_capacity() {
                            for capacity in 1..32 {
                                for additional in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    _ = actual.shrink_front(capacity + additional).expect_err("already less capacity");

                                    assert_eq!(actual.capacity(), capacity);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_initialize_elements() {
                            for capacity in 1..32 {
                                for additional in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    _ = actual.shrink_front(capacity + additional).expect_err("already less capacity");

                                    assert_eq!(actual.initialized, 0);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_reallocate_memory() {
                            for capacity in 1..32 {
                                for additional in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    let allocation = actual.buffer;

                                    _ = actual.shrink_front(capacity + additional).expect_err("already less capacity");

                                    assert_eq!(actual.buffer, allocation);
                                }
                            }
                        }

                        #[test]
                        fn then_capacity_many_elements_can_be_appended_without_reallocating_memory() {
                            for capacity in 1..32 {
                                for additional in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    _ = actual.shrink_front(capacity + additional).expect_err("already less capacity");

                                    let allocation = actual.buffer;

                                    for element in 1..capacity {
                                        _ = actual.append(element).expect("uses capacity");
                                    }

                                    assert_eq!(actual.buffer, allocation);
                                }
                            }
                        }
                    }

                    mod when_not_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_front_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let mut actual: Dynamic<_> = (0..elements).collect();

                                        _ = actual.reserve_back(capacity).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, 0);
                                        debug_assert_eq!(actual.back_capacity, capacity);

                                        _ = actual.shrink_front(capacity + additional).expect_err("already less capacity");

                                        assert_eq!(actual.front_capacity, 0);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_back_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let mut actual: Dynamic<_> = (0..elements).collect();

                                        _ = actual.reserve_back(capacity).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, 0);
                                        debug_assert_eq!(actual.back_capacity, capacity);

                                        _ = actual.shrink_front(capacity + additional).expect_err("already less capacity");

                                        assert_eq!(actual.back_capacity, capacity);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_initialized_elements() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let expected = 0..elements;

                                        let mut actual: Dynamic<_> = expected.clone().collect();

                                        _ = actual.reserve_back(capacity).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, 0);
                                        debug_assert_eq!(actual.back_capacity, capacity);

                                        _ = actual.shrink_front(capacity + additional).expect_err("already less capacity");

                                        assert!(actual.eq(expected));
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_reallocate_memory() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let mut actual: Dynamic<_> = (0..elements).collect();

                                        _ = actual.reserve_back(capacity).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, 0);
                                        debug_assert_eq!(actual.back_capacity, capacity);

                                        let allocation = actual.buffer;

                                        _ = actual.shrink_front(capacity + additional).expect_err("already less capacity");

                                        assert_eq!(actual.buffer, allocation);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_capacity_many_elements_can_be_appended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let expected = 0..elements;

                                        let mut actual: Dynamic<_> = expected.clone().collect();

                                        _ = actual.reserve_back(capacity).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, 0);
                                        debug_assert_eq!(actual.back_capacity, capacity);

                                        _ = actual.shrink_front(capacity + additional).expect_err("already less capacity");

                                        let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                        for _ in 0..capacity {
                                            // NOTE: this is distinct from the expected values.
                                            _ = actual.append(usize::MAX).expect("uses capacity");
                                        }

                                        assert!(pointers.iter().copied().eq(expected));
                                    }
                                }
                            }
                        }
                    }
                }

                mod when_exactly_requested {
                    use super::*;

                    mod when_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_capacity() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_back(capacity).expect("successful allocation");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, 0);
                                debug_assert_eq!(actual.back_capacity, capacity);

                                _ = actual.shrink_front(capacity).expect("already exact capacity");

                                assert_eq!(actual.capacity(), capacity);
                            }
                        }

                        #[test]
                        fn then_does_not_initialize_elements() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_back(capacity).expect("successful allocation");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, 0);
                                debug_assert_eq!(actual.back_capacity, capacity);

                                _ = actual.shrink_front(capacity).expect("already exact capacity");

                                assert_eq!(actual.initialized, 0);
                            }
                        }

                        #[test]
                        fn then_does_not_reallocate_memory() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_back(capacity).expect("successful allocation");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, 0);
                                debug_assert_eq!(actual.back_capacity, capacity);

                                let allocation = actual.buffer;

                                _ = actual.shrink_front(capacity).expect("already exact capacity");

                                assert_eq!(actual.buffer, allocation);
                            }
                        }

                        #[test]
                        fn then_capacity_many_elements_can_be_prepended_without_reallocating_memory() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_back(capacity).expect("successful allocation");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, 0);
                                debug_assert_eq!(actual.back_capacity, capacity);

                                _ = actual.shrink_front(capacity).expect("already exact capacity");

                                let allocation = actual.buffer;

                                for element in 0..capacity {
                                    _ = actual.prepend(element).expect("uses capacity");
                                }

                                assert_eq!(actual.buffer, allocation);
                            }
                        }
                    }

                    mod when_not_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_front_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let mut actual: Dynamic<_> = (0..elements).collect();

                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    _ = actual.shrink_front(capacity).expect_err("less capacity");

                                    assert_eq!(actual.front_capacity, 0);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_back_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let mut actual: Dynamic<_> = (0..elements).collect();

                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    _ = actual.shrink_front(capacity).expect_err("less capacity");

                                    assert_eq!(actual.back_capacity, capacity);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_initialized_elements() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let expected = 0..elements;

                                    let mut actual: Dynamic<_> = expected.clone().collect();

                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    _ = actual.shrink_front(capacity).expect_err("less capacity");

                                    assert!(actual.eq(expected));
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_reallocate_memory() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let mut actual: Dynamic<_> = (0..elements).collect();

                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    let allocation = actual.buffer;

                                    _ = actual.shrink_front(capacity).expect_err("less capacity");

                                    assert_eq!(actual.buffer, allocation);
                                }
                            }
                        }

                        #[test]
                        fn then_capacity_many_elements_can_be_appended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let expected = 0..elements;

                                    let mut actual: Dynamic<_> = expected.clone().collect();

                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    _ = actual.shrink_front(capacity).expect_err("less capacity");

                                    let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                    assert!(pointers.iter().copied().eq(expected));
                                }
                            }
                        }
                    }
                }

                mod when_more_than_requested {
                    use super::*;

                    mod when_empty {
                        use super::*;

                        #[test]
                        fn then_decreases_capacity_to_exactly_requested() {
                            for capacity in 1..32 {
                                for additional in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_back(capacity + additional).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, capacity + additional);

                                    _ = actual.shrink_front(capacity).expect("successful reallocation");

                                    assert_eq!(actual.capacity(), capacity);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_initialize_elements() {
                            for capacity in 1..32 {
                                for additional in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_back(capacity + additional).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, capacity + additional);

                                    _ = actual.shrink_front(capacity).expect("successful reallocation");

                                    assert_eq!(actual.initialized, 0);
                                }
                            }
                        }

                        #[test]
                        fn then_requested_many_elements_can_be_prepended_without_reallocating_memory() {
                            for capacity in 1..32 {
                                for additional in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_back(capacity + additional).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, capacity + additional);

                                    _ = actual.shrink_front(capacity).expect("successful reallocation");

                                    let allocation = actual.buffer;

                                    for element in 0..capacity {
                                        _ = actual.prepend(element).expect("uses capacity");
                                    }

                                    assert_eq!(actual.buffer, allocation);
                                }
                            }
                        }
                    }

                    mod when_not_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_front_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let mut actual: Dynamic<_> = (0..elements).collect();

                                        _ = actual.reserve_back(capacity + additional).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, 0);
                                        debug_assert_eq!(actual.back_capacity, capacity + additional);

                                        _ = actual.shrink_front(capacity).expect_err("less capacity");

                                        assert_eq!(actual.front_capacity, 0);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_back_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let mut actual: Dynamic<_> = (0..elements).collect();

                                        _ = actual.reserve_back(capacity + additional).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, 0);
                                        debug_assert_eq!(actual.back_capacity, capacity + additional);

                                        _ = actual.shrink_front(capacity).expect_err("less capacity");

                                        assert_eq!(actual.back_capacity, capacity + additional);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_initialized_elements() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let expected = 0..elements;

                                        let mut actual: Dynamic<_> = expected.clone().collect();

                                        _ = actual.reserve_back(capacity + additional).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, 0);
                                        debug_assert_eq!(actual.back_capacity, capacity + additional);

                                        _ = actual.shrink_front(capacity).expect_err("less capacity");

                                        assert!(actual.eq(expected));
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_reallocate_memory() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let mut actual: Dynamic<_> = (0..elements).collect();

                                        _ = actual.reserve_back(capacity + additional).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, 0);
                                        debug_assert_eq!(actual.back_capacity, capacity + additional);

                                        let allocation = actual.buffer;

                                        _ = actual.shrink_front(capacity).expect_err("less capacity");

                                        assert_eq!(actual.buffer, allocation);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_capacity_many_elements_can_be_appended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let expected = 0..elements;

                                        let mut actual: Dynamic<_> = expected.clone().collect();

                                        _ = actual.reserve_back(capacity + additional).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, 0);
                                        debug_assert_eq!(actual.back_capacity, capacity + additional);

                                        _ = actual.shrink_front(capacity).expect_err("less capacity");

                                        let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                        for _ in 0..capacity {
                                            // NOTE: this is distinct from the expected values.
                                            _ = actual.append(usize::MAX).expect("uses capacity");
                                        }

                                        assert!(pointers.iter().copied().eq(expected));
                                    }
                                }
                            }
                        }
                    }
                }
            }

            mod when_both_front_and_back_capacity {
                use super::*;

                mod when_zero_requested {
                    use super::*;

                    mod when_empty {
                        use super::*;

                        #[test]
                        fn then_decreases_capacity_to_zero() {
                            for front in 1..32 {
                                for back in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_back(front + back).expect("successful allocation");

                                    _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, front);
                                    debug_assert_eq!(actual.back_capacity, back);

                                    _ = actual.shrink_front(0).expect("successful deallocation");

                                    assert_eq!(actual.capacity(), 0);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_initialize_elements() {
                            for front in 1..32 {
                                for back in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_back(front + back).expect("successful allocation");

                                    _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, front);
                                    debug_assert_eq!(actual.back_capacity, back);

                                    _ = actual.shrink_front(0).expect("successful deallocation");

                                    assert_eq!(actual.initialized, 0);
                                }
                            }
                        }
                    }

                    mod when_not_empty {
                        use super::*;

                        #[test]
                        fn then_decreases_front_capacity_to_zero() {
                            for elements in 1..32 {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        let mut actual: Dynamic<_> = (0..elements).collect();

                                        _ = actual.reserve_front(front).expect("successful allocation");
                                        _ = actual.reserve_back(back).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.shrink_front(0).expect("successful deallocation");

                                        assert_eq!(actual.front_capacity, 0);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_back_capacity() {
                            for elements in 1..32 {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        let mut actual: Dynamic<_> = (0..elements).collect();

                                        _ = actual.reserve_front(front).expect("successful allocation");
                                        _ = actual.reserve_back(back).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.shrink_front(0).expect("successful deallocation");

                                        assert_eq!(actual.back_capacity, back);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_initialized_elements() {
                            for elements in 1..32 {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        let expected = 0..elements;

                                        let mut actual: Dynamic<_> = expected.clone().collect();

                                        _ = actual.reserve_front(front).expect("successful allocation");
                                        _ = actual.reserve_back(back).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.shrink_front(0).expect("successful deallocation");

                                        assert!(actual.eq(expected));
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_capacity_many_elements_can_be_appended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        let expected = 0..elements;

                                        let mut actual: Dynamic<_> = expected.clone().collect();

                                        _ = actual.reserve_front(front).expect("successful allocation");
                                        _ = actual.reserve_back(back).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.shrink_front(0).expect("successful deallocation");

                                        let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                        for _ in 0..back {
                                            // NOTE: this is distinct from the expected values.
                                            _ = actual.append(usize::MAX).expect("uses capacity");
                                        }

                                        assert!(pointers.iter().copied().eq(expected));
                                    }
                                }
                            }
                        }
                    }
                }

                mod when_both_less_than_requested {
                    use super::*;

                    mod when_sum_is_less_than_requested {
                        use super::*;

                        mod when_empty {
                            use super::*;

                            #[test]
                            fn then_does_not_modify_capacity() {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        for additional in 1..32 {
                                            let mut actual = Dynamic::<usize>::default();

                                            _ = actual.reserve_back(front + back).expect("successful allocation");

                                            _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                            debug_assert_eq!(actual.initialized, 0);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.shrink_front(front + back + additional).expect_err("already less capacity");

                                            assert_eq!(actual.capacity(), front + back);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_initialize_elements() {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        for additional in 1..32 {
                                            let mut actual = Dynamic::<usize>::default();

                                            _ = actual.reserve_back(front + back).expect("successful allocation");

                                            _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                            debug_assert_eq!(actual.initialized, 0);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.shrink_front(front + back + additional).expect_err("already less capacity");

                                            assert_eq!(actual.initialized, 0);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_reallocate_memory() {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        for additional in 1..32 {
                                            let mut actual = Dynamic::<usize>::default();

                                            _ = actual.reserve_back(front + back).expect("successful allocation");

                                            _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                            debug_assert_eq!(actual.initialized, 0);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            let allocation = actual.buffer;

                                            _ = actual.shrink_front(front + back + additional).expect_err("already less capacity");

                                            assert_eq!(actual.buffer, allocation);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_capacity_many_elements_can_be_prepended_without_reallocating_memory() {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        for additional in 1..32 {
                                            let mut actual = Dynamic::<usize>::default();

                                            _ = actual.reserve_back(front + back).expect("successful allocation");

                                            _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                            debug_assert_eq!(actual.initialized, 0);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.shrink_front(front + back + additional).expect_err("already less capacity");

                                            let allocation = actual.buffer;

                                            for element in 0..(front + back) {
                                                _ = actual.prepend(element).expect("uses capacity");
                                            }

                                            assert_eq!(actual.buffer, allocation);
                                        }
                                    }
                                }
                            }
                        }

                        mod when_not_empty {
                            use super::*;

                            #[test]
                            fn then_does_not_modify_front_capacity() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            for additional in 1..32 {
                                                let mut actual: Dynamic<_> = (0..elements).collect();

                                                _ = actual.reserve_front(front).expect("successful allocation");
                                                _ = actual.reserve_back(back).expect("successful allocation");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front);
                                                debug_assert_eq!(actual.back_capacity, back);

                                                _ = actual.shrink_front(front + back + additional).expect_err("already less capacity");

                                                assert_eq!(actual.front_capacity, front);
                                            }
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_modify_back_capacity() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            for additional in 1..32 {
                                                let mut actual: Dynamic<_> = (0..elements).collect();

                                                _ = actual.reserve_front(front).expect("successful allocation");
                                                _ = actual.reserve_back(back).expect("successful allocation");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front);
                                                debug_assert_eq!(actual.back_capacity, back);

                                                _ = actual.shrink_front(front + back + additional).expect_err("already less capacity");

                                                assert_eq!(actual.back_capacity, back);
                                            }
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_modify_initialized_elements() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            for additional in 1..32 {
                                                let expected = 0..elements;

                                                let mut actual: Dynamic<_> = expected.clone().collect();

                                                _ = actual.reserve_front(front).expect("successful allocation");
                                                _ = actual.reserve_back(back).expect("successful allocation");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front);
                                                debug_assert_eq!(actual.back_capacity, back);

                                                _ = actual.shrink_front(front + back + additional).expect_err("already less capacity");

                                                assert!(actual.eq(expected));
                                            }
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_front_many_elements_can_be_prepended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            for additional in 1..32 {
                                                let expected = 0..elements;

                                                let mut actual: Dynamic<_> = expected.clone().collect();

                                                _ = actual.reserve_front(front).expect("successful allocation");
                                                _ = actual.reserve_back(back).expect("successful allocation");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front);
                                                debug_assert_eq!(actual.back_capacity, back);

                                                _ = actual.shrink_front(front + back + additional).expect_err("already less capacity");

                                                let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                                for _ in 0..front {
                                                    // NOTE: this is distinct from the expected values.
                                                    _ = actual.prepend(usize::MAX).expect("uses capacity");
                                                }

                                                assert!(pointers.iter().copied().eq(expected));
                                            }
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_back_many_elements_can_be_appended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            for additional in 1..32 {
                                                let expected = 0..elements;

                                                let mut actual: Dynamic<_> = expected.clone().collect();

                                                _ = actual.reserve_front(front).expect("successful allocation");
                                                _ = actual.reserve_back(back).expect("successful allocation");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front);
                                                debug_assert_eq!(actual.back_capacity, back);

                                                _ = actual.shrink_front(front + back + additional).expect_err("already less capacity");

                                                let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                                for _ in 0..back {
                                                    // NOTE: this is distinct from the expected values.
                                                    _ = actual.append(usize::MAX).expect("uses capacity");
                                                }

                                                assert!(pointers.iter().copied().eq(expected));
                                            }
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_both_front_many_elements_can_be_prepended_and_back_many_elements_can_be_appended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            for additional in 1..32 {
                                                let expected = 0..elements;

                                                let mut actual: Dynamic<_> = expected.clone().collect();

                                                _ = actual.reserve_front(front).expect("successful allocation");
                                                _ = actual.reserve_back(back).expect("successful allocation");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front);
                                                debug_assert_eq!(actual.back_capacity, back);

                                                _ = actual.shrink_front(front + back + additional).expect_err("already less capacity");

                                                let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                                for _ in 0..front {
                                                    // NOTE: this is distinct from the expected values.
                                                    _ = actual.prepend(usize::MAX).expect("uses capacity");
                                                }

                                                for _ in 0..back {
                                                    // NOTE: this is distinct from the expected values.
                                                    _ = actual.append(usize::MAX).expect("uses capacity");
                                                }

                                                assert!(pointers.iter().copied().eq(expected));
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }

                    mod when_sum_is_exactly_requested {
                        use super::*;

                        mod when_empty {
                            use super::*;

                            #[test]
                            fn then_does_not_modify_capacity() {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(front + back).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.shrink_front(front + back).expect("already exact capacity");

                                        assert_eq!(actual.capacity(), front + back);
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_initialize_elements() {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(front + back).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.shrink_front(front + back).expect("already exact capacity");

                                        assert_eq!(actual.initialized, 0);
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_reallocate_memory() {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(front + back).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        let allocation = actual.buffer;

                                        _ = actual.shrink_front(front + back).expect("already exact capacity");

                                        assert_eq!(actual.buffer, allocation);
                                    }
                                }
                            }

                            #[test]
                            fn then_requested_many_elements_can_be_prepended_without_reallocating_memory() {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(front + back).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.shrink_front(front + back).expect("already exact capacity");

                                        let allocation = actual.buffer;

                                        for element in 0..(front + back) {
                                            _ = actual.prepend(element).expect("uses capacity");
                                        }

                                        assert_eq!(actual.buffer, allocation);
                                    }
                                }
                            }
                        }

                        mod when_not_empty {
                            use super::*;

                            #[test]
                            fn then_does_not_modify_front_capacity() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.shrink_front(front + back).expect_err("less capacity");

                                            assert_eq!(actual.front_capacity, front);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_modify_back_capacity() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.shrink_front(front + back).expect_err("less capacity");

                                            assert_eq!(actual.back_capacity, back);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_modify_initialized_elements() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.shrink_front(front + back).expect_err("less capacity");

                                            assert!(actual.eq(expected));
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_reallocate_memory() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            let allocation = actual.buffer;

                                            _ = actual.shrink_front(front + back).expect_err("less capacity");

                                            assert_eq!(actual.buffer, allocation);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_front_many_elements_can_be_prepended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.shrink_front(front + back).expect_err("less capacity");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..front {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.prepend(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_back_many_elements_can_be_appended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.shrink_front(front + back).expect_err("less capacity");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..back {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.append(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_both_front_many_elements_can_be_prepended_and_back_many_elements_can_be_appended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.shrink_front(front + back).expect_err("less capacity");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..front {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.prepend(usize::MAX).expect("uses capacity");
                                            }

                                            for _ in 0..back {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.append(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }
                        }
                    }

                    mod when_sum_is_more_than_requested {
                        use super::*;

                        mod when_empty {
                            use super::*;

                            #[test]
                            fn then_decreases_capacity_to_exactly_requested() {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        for additional in 1..usize::min(front, back) {
                                            let mut actual = Dynamic::<usize>::default();

                                            _ = actual.reserve_back(front + back).expect("successful allocation");

                                            _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                            debug_assert_eq!(actual.initialized, 0);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.shrink_front(front + back - additional).expect("successful reallocation");

                                            assert_eq!(actual.capacity(), front + back - additional);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_initialize_elements() {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        for additional in 1..usize::min(front, back) {
                                            let mut actual = Dynamic::<usize>::default();

                                            _ = actual.reserve_back(front + back).expect("successful allocation");

                                            _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                            debug_assert_eq!(actual.initialized, 0);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.shrink_front(front + back - additional).expect("successful reallocation");

                                            assert_eq!(actual.initialized, 0);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_requested_many_elements_can_be_prepended_without_reallocating_memory() {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        for additional in 1..usize::min(front, back) {
                                            let mut actual = Dynamic::<usize>::default();

                                            _ = actual.reserve_back(front + back).expect("successful allocation");

                                            _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                            debug_assert_eq!(actual.initialized, 0);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.shrink_front(front + back - additional).expect("successful reallocation");

                                            let allocation = actual.buffer;

                                            for element in 0..(front + back - additional) {
                                                _ = actual.prepend(element).expect("uses capacity");
                                            }

                                            assert_eq!(actual.buffer, allocation);
                                        }
                                    }
                                }
                            }
                        }

                        mod when_not_empty {
                            use super::*;

                            #[test]
                            fn then_does_not_modify_front_capacity() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            for additional in 1..usize::min(front, back) {
                                                let mut actual: Dynamic<_> = (0..elements).collect();

                                                _ = actual.reserve_front(front).expect("successful allocation");
                                                _ = actual.reserve_back(back).expect("successful allocation");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front);
                                                debug_assert_eq!(actual.back_capacity, back);

                                                _ = actual.shrink_front(front + back - additional).expect_err("less capacity");

                                                assert_eq!(actual.front_capacity, front);
                                            }
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_modify_back_capacity() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            for additional in 1..usize::min(front, back) {
                                                let mut actual: Dynamic<_> = (0..elements).collect();

                                                _ = actual.reserve_front(front).expect("successful allocation");
                                                _ = actual.reserve_back(back).expect("successful allocation");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front);
                                                debug_assert_eq!(actual.back_capacity, back);

                                                _ = actual.shrink_front(front + back - additional).expect_err("less capacity");

                                                assert_eq!(actual.back_capacity, back);
                                            }
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_modify_initialized_elements() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            for additional in 1..usize::min(front, back) {
                                                let expected = 0..elements;

                                                let mut actual: Dynamic<_> = expected.clone().collect();

                                                _ = actual.reserve_front(front).expect("successful allocation");
                                                _ = actual.reserve_back(back).expect("successful allocation");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front);
                                                debug_assert_eq!(actual.back_capacity, back);

                                                _ = actual.shrink_front(front + back - additional).expect_err("less capacity");

                                                assert!(actual.eq(expected));
                                            }
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_front_many_elements_can_be_prepended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            for additional in 1..usize::min(front, back) {
                                                let expected = 0..elements;

                                                let mut actual: Dynamic<_> = expected.clone().collect();

                                                _ = actual.reserve_front(front).expect("successful allocation");
                                                _ = actual.reserve_back(back).expect("successful allocation");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front);
                                                debug_assert_eq!(actual.back_capacity, back);

                                                _ = actual.shrink_front(front + back - additional).expect_err("less capacity");

                                                let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                                for _ in 0..front {
                                                    // NOTE: this is distinct from the expected values.
                                                    _ = actual.prepend(usize::MAX).expect("uses capacity");
                                                }

                                                assert!(pointers.iter().copied().eq(expected));
                                            }
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_back_many_elements_can_be_appended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            for additional in 1..usize::min(front, back) {
                                                let expected = 0..elements;

                                                let mut actual: Dynamic<_> = expected.clone().collect();

                                                _ = actual.reserve_front(front).expect("successful allocation");
                                                _ = actual.reserve_back(back).expect("successful allocation");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front);
                                                debug_assert_eq!(actual.back_capacity, back);

                                                _ = actual.shrink_front(front + back - additional).expect_err("less capacity");

                                                let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                                for _ in 0..back {
                                                    // NOTE: this is distinct from the expected values.
                                                    _ = actual.append(usize::MAX).expect("uses capacity");
                                                }

                                                assert!(pointers.iter().copied().eq(expected));
                                            }
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_both_front_many_elements_can_be_prepended_and_back_many_elements_can_be_appended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            for additional in 1..usize::min(front, back) {
                                                let expected = 0..elements;

                                                let mut actual: Dynamic<_> = expected.clone().collect();

                                                _ = actual.reserve_front(front).expect("successful allocation");
                                                _ = actual.reserve_back(back).expect("successful allocation");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front);
                                                debug_assert_eq!(actual.back_capacity, back);

                                                _ = actual.shrink_front(front + back - additional).expect_err("less capacity");

                                                let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                                for _ in 0..front {
                                                    // NOTE: this is distinct from the expected values.
                                                    _ = actual.prepend(usize::MAX).expect("uses capacity");
                                                }

                                                for _ in 0..back {
                                                    // NOTE: this is distinct from the expected values.
                                                    _ = actual.append(usize::MAX).expect("uses capacity");
                                                }

                                                assert!(pointers.iter().copied().eq(expected));
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                mod when_front_is_exactly_requested {
                    use super::*;

                    mod when_back_is_less_than_requested {
                        use super::*;

                        mod when_empty {
                            use super::*;

                            #[test]
                            fn then_decreases_capacity_to_exactly_requested() {
                                for front in 1..32 {
                                    for back in 1..front {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(front + back).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.shrink_front(front).expect("successful reallocation");

                                        assert_eq!(actual.capacity(), front);
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_initialize_elements() {
                                for front in 1..32 {
                                    for back in 1..front {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(front + back).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.shrink_front(front).expect("successful reallocation");

                                        assert_eq!(actual.initialized, 0);
                                    }
                                }
                            }

                            #[test]
                            fn then_requested_many_elements_can_be_prepended_without_reallocating_memory() {
                                for front in 1..32 {
                                    for back in 1..front {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(front + back).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.shrink_front(front).expect("successful reallocation");

                                        let allocation = actual.buffer;

                                        for element in 0..front {
                                            _ = actual.prepend(element).expect("uses capacity");
                                        }

                                        assert_eq!(actual.buffer, allocation);
                                    }
                                }
                            }
                        }

                        mod when_not_empty {
                            use super::*;

                            #[test]
                            fn then_does_not_modify_front_capacity() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..front {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.shrink_front(front).expect("successful reallocation");

                                            assert_eq!(actual.front_capacity, front);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_modify_back_capacity() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..front {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.shrink_front(front).expect("successful reallocation");

                                            assert_eq!(actual.back_capacity, back);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_modify_initialized_elements() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..front {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.shrink_front(front).expect("successful reallocation");

                                            assert!(actual.eq(expected));
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_reallocate_memory() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..front {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            let allocation = actual.buffer;

                                            _ = actual.shrink_front(front).expect("successful reallocation");

                                            assert_eq!(actual.buffer, allocation);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_front_many_elements_can_be_prepended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..front {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.shrink_front(front).expect("successful reallocation");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..front {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.prepend(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_back_many_elements_can_be_appended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..front {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.shrink_front(front).expect("successful reallocation");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..back {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.append(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_both_front_many_elements_can_be_prepended_and_back_many_elements_can_be_appended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..front {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.shrink_front(front).expect("successful reallocation");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..front {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.prepend(usize::MAX).expect("uses capacity");
                                            }

                                            for _ in 0..back {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.append(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }
                        }
                    }

                    mod when_back_is_more_than_requested {
                        use super::*;

                        mod when_empty {
                            use super::*;

                            #[test]
                            fn then_decreases_capacity_to_exactly_requested() {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(capacity + capacity + additional).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(capacity).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, capacity);
                                        debug_assert_eq!(actual.back_capacity, capacity + additional);

                                        _ = actual.shrink_front(capacity).expect("successful reallocation");

                                        assert_eq!(actual.capacity(), capacity);
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_initialize_elements() {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(capacity + capacity + additional).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(capacity).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, capacity);
                                        debug_assert_eq!(actual.back_capacity, capacity + additional);

                                        _ = actual.shrink_front(capacity).expect("successful reallocation");

                                        assert_eq!(actual.initialized, 0);
                                    }
                                }
                            }

                            #[test]
                            fn then_requested_many_elements_can_be_prepended_without_reallocating_memory() {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(capacity + capacity + additional).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(capacity).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, capacity);
                                        debug_assert_eq!(actual.back_capacity, capacity + additional);

                                        _ = actual.shrink_front(capacity).expect("successful reallocation");

                                        let allocation = actual.buffer;

                                        for element in 0..capacity {
                                            _ = actual.prepend(element).expect("uses capacity");
                                        }

                                        assert_eq!(actual.buffer, allocation);
                                    }
                                }
                            }
                        }

                        mod when_not_empty {
                            use super::*;

                            #[test]
                            fn then_does_not_modify_front_capacity() {
                                for elements in 1..32 {
                                    for capacity in 1..32 {
                                        for additional in 1..32 {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(capacity).expect("successful allocation");
                                            _ = actual.reserve_back(capacity + additional).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, capacity);
                                            debug_assert_eq!(actual.back_capacity, capacity + additional);

                                            _ = actual.shrink_front(capacity).expect("successful reallocation");

                                            assert_eq!(actual.front_capacity, capacity);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_modify_back_capacity() {
                                for elements in 1..32 {
                                    for capacity in 1..32 {
                                        for additional in 1..32 {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(capacity).expect("successful allocation");
                                            _ = actual.reserve_back(capacity + additional).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, capacity);
                                            debug_assert_eq!(actual.back_capacity, capacity + additional);

                                            _ = actual.shrink_front(capacity).expect("successful reallocation");

                                            assert_eq!(actual.back_capacity, capacity + additional);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_modify_initialized_elements() {
                                for elements in 1..32 {
                                    for capacity in 1..32 {
                                        for additional in 1..32 {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(capacity).expect("successful allocation");
                                            _ = actual.reserve_back(capacity + additional).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, capacity);
                                            debug_assert_eq!(actual.back_capacity, capacity + additional);

                                            _ = actual.shrink_front(capacity).expect("successful reallocation");

                                            assert!(actual.eq(expected));
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_reallocate_memory() {
                                for elements in 1..32 {
                                    for capacity in 1..32 {
                                        for additional in 1..32 {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(capacity).expect("successful allocation");
                                            _ = actual.reserve_back(capacity + additional).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, capacity);
                                            debug_assert_eq!(actual.back_capacity, capacity + additional);

                                            let allocation = actual.buffer;

                                            _ = actual.shrink_front(capacity).expect("successful reallocation");

                                            assert_eq!(actual.buffer, allocation);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_front_many_elements_can_be_prepended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for capacity in 1..32 {
                                        for additional in 1..32 {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(capacity).expect("successful allocation");
                                            _ = actual.reserve_back(capacity + additional).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, capacity);
                                            debug_assert_eq!(actual.back_capacity, capacity + additional);

                                            _ = actual.shrink_front(capacity).expect("successful reallocation");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..capacity {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.prepend(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_back_many_elements_can_be_appended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for capacity in 1..32 {
                                        for additional in 1..32 {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(capacity).expect("successful allocation");
                                            _ = actual.reserve_back(capacity + additional).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, capacity);
                                            debug_assert_eq!(actual.back_capacity, capacity + additional);

                                            _ = actual.shrink_front(capacity).expect("successful reallocation");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..(capacity + additional) {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.append(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_both_front_many_elements_can_be_prepended_and_back_many_elements_can_be_appended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for capacity in 1..32 {
                                        for additional in 1..32 {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(capacity).expect("successful allocation");
                                            _ = actual.reserve_back(capacity + additional).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, capacity);
                                            debug_assert_eq!(actual.back_capacity, capacity + additional);

                                            _ = actual.shrink_front(capacity).expect("successful reallocation");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..capacity {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.prepend(usize::MAX).expect("uses capacity");
                                            }

                                            for _ in 0..(capacity + additional) {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.append(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                mod when_back_is_exactly_requested {
                    use super::*;

                    mod when_front_is_less_than_requested {
                        use super::*;

                        mod when_empty {
                            use super::*;

                            #[test]
                            fn then_decreases_capacity_to_exactly_requested() {
                                for back in 1..32 {
                                    for front in 1..back {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(front + back).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.shrink_front(back).expect("successful reallocation");

                                        assert_eq!(actual.capacity(), back);
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_initialize_elements() {
                                for back in 1..32 {
                                    for front in 1..back {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(front + back).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.shrink_front(back).expect("successful reallocation");

                                        assert_eq!(actual.initialized, 0);
                                    }
                                }
                            }

                            #[test]
                            fn then_requested_many_elements_can_be_prepended_without_reallocating_memory() {
                                for back in 1..32 {
                                    for front in 1..back {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(front + back).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.shrink_front(back).expect("successful reallocation");

                                        let allocation = actual.buffer;

                                        for element in 0..back {
                                            _ = actual.prepend(element).expect("uses capacity");
                                        }

                                        assert_eq!(actual.buffer, allocation);
                                    }
                                }
                            }
                        }

                        mod when_not_empty {
                            use super::*;

                            #[test]
                            fn then_does_not_modify_front_capacity() {
                                for elements in 1..32 {
                                    for back in 1..32 {
                                        for front in 1..back {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.shrink_front(back).expect_err("less capacity");

                                            assert_eq!(actual.front_capacity, front);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_modify_back_capacity() {
                                for elements in 1..32 {
                                    for back in 1..32 {
                                        for front in 1..back {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.shrink_front(back).expect_err("less capacity");

                                            assert_eq!(actual.back_capacity, back);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_modify_initialized_elements() {
                                for elements in 1..32 {
                                    for back in 1..32 {
                                        for front in 1..back {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.shrink_front(back).expect_err("less capacity");

                                            assert!(actual.eq(expected));
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_reallocate_memory() {
                                for elements in 1..32 {
                                    for back in 1..32 {
                                        for front in 1..back {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            let allocation = actual.buffer;

                                            _ = actual.shrink_front(back).expect_err("less capacity");

                                            assert_eq!(actual.buffer, allocation);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_front_many_elements_can_be_prepended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for back in 1..32 {
                                        for front in 1..back {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.shrink_front(back).expect_err("less capacity");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..front {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.prepend(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_back_many_elements_can_be_appended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for back in 1..32 {
                                        for front in 1..back {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.shrink_front(back).expect_err("less capacity");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..back {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.append(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_both_front_many_elements_can_be_prepended_and_back_many_elements_can_be_appended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for back in 1..32 {
                                        for front in 1..back {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.shrink_front(back).expect_err("less capacity");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..front {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.prepend(usize::MAX).expect("uses capacity");
                                            }

                                            for _ in 0..back {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.append(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }
                        }
                    }

                    mod when_front_is_more_than_requested {
                        use super::*;

                        mod when_empty {
                            use super::*;

                            #[test]
                            fn then_decreases_capacity_to_exactly_requested() {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(capacity + additional + capacity).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(capacity + additional).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, capacity + additional);
                                        debug_assert_eq!(actual.back_capacity, capacity);

                                        _ = actual.shrink_front(capacity).expect("successful reallocation");

                                        assert_eq!(actual.capacity(), capacity);
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_initialize_elements() {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(capacity + additional + capacity).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(capacity + additional).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, capacity + additional);
                                        debug_assert_eq!(actual.back_capacity, capacity);

                                        _ = actual.shrink_front(capacity).expect("successful reallocation");

                                        assert_eq!(actual.initialized, 0);
                                    }
                                }
                            }

                            #[test]
                            fn then_requested_many_elements_can_be_prepended_without_reallocating_memory() {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(capacity + additional + capacity).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(capacity + additional).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, capacity + additional);
                                        debug_assert_eq!(actual.back_capacity, capacity);

                                        _ = actual.shrink_front(capacity).expect("successful reallocation");

                                        let allocation = actual.buffer;

                                        for element in 0..capacity {
                                            _ = actual.prepend(element).expect("uses capacity");
                                        }

                                        assert_eq!(actual.buffer, allocation);
                                    }
                                }
                            }
                        }

                        mod when_not_empty {
                            use super::*;

                            #[test]
                            fn then_decreases_front_to_exactly_requested() {
                                for elements in 1..32 {
                                    for capacity in 1..32 {
                                        for additional in 1..32 {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(capacity + additional).expect("successful allocation");
                                            _ = actual.reserve_back(capacity).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, capacity + additional);
                                            debug_assert_eq!(actual.back_capacity, capacity);

                                            _ = actual.shrink_front(capacity).expect("successful reallocation");

                                            assert_eq!(actual.front_capacity, capacity);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_modify_back_capacity() {
                                for elements in 1..32 {
                                    for capacity in 1..32 {
                                        for additional in 1..32 {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(capacity + additional).expect("successful allocation");
                                            _ = actual.reserve_back(capacity).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, capacity + additional);
                                            debug_assert_eq!(actual.back_capacity, capacity);

                                            _ = actual.shrink_front(capacity).expect("successful reallocation");

                                            assert_eq!(actual.back_capacity, capacity);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_modify_initialized_elements() {
                                for elements in 1..32 {
                                    for capacity in 1..32 {
                                        for additional in 1..32 {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(capacity + additional).expect("successful allocation");
                                            _ = actual.reserve_back(capacity).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, capacity + additional);
                                            debug_assert_eq!(actual.back_capacity, capacity);

                                            _ = actual.shrink_front(capacity).expect("successful reallocation");

                                            assert!(actual.eq(expected));
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_front_many_elements_can_be_prepended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for capacity in 1..32 {
                                        for additional in 1..32 {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(capacity + additional).expect("successful allocation");
                                            _ = actual.reserve_back(capacity).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, capacity + additional);
                                            debug_assert_eq!(actual.back_capacity, capacity);

                                            _ = actual.shrink_front(capacity).expect("successful reallocation");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..capacity {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.prepend(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_back_many_elements_can_be_appended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for capacity in 1..32 {
                                        for additional in 1..32 {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(capacity + additional).expect("successful allocation");
                                            _ = actual.reserve_back(capacity).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, capacity + additional);
                                            debug_assert_eq!(actual.back_capacity, capacity);

                                            _ = actual.shrink_front(capacity).expect("successful reallocation");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..capacity {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.append(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_both_front_many_elements_can_be_prepended_and_back_many_elements_can_be_appended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for capacity in 1..32 {
                                        for additional in 1..32 {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(capacity + additional).expect("successful allocation");
                                            _ = actual.reserve_back(capacity).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, capacity + additional);
                                            debug_assert_eq!(actual.back_capacity, capacity);

                                            _ = actual.shrink_front(capacity).expect("successful reallocation");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..capacity {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.prepend(usize::MAX).expect("uses capacity");
                                            }

                                            for _ in 0..capacity {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.append(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                mod when_both_exactly_requested {
                    use super::*;

                    mod when_empty {
                        use super::*;

                        #[test]
                        fn then_decreases_capacity_to_exactly_requested() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_back(capacity + capacity).expect("successful allocation");

                                _ = actual.shift(isize::try_from(capacity).expect("too small to wrap")).expect("enough back capacity to shift into");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, capacity);
                                debug_assert_eq!(actual.back_capacity, capacity);

                                _ = actual.shrink_front(capacity).expect("successful reallocation");

                                assert_eq!(actual.capacity(), capacity);
                            }
                        }

                        #[test]
                        fn then_does_not_initialize_elements() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_back(capacity + capacity).expect("successful allocation");

                                _ = actual.shift(isize::try_from(capacity).expect("too small to wrap")).expect("enough back capacity to shift into");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, capacity);
                                debug_assert_eq!(actual.back_capacity, capacity);

                                _ = actual.shrink_front(capacity).expect("successful reallocation");

                                assert_eq!(actual.initialized, 0);
                            }
                        }

                        #[test]
                        fn then_requested_many_elements_can_be_prepended_without_reallocating_memory() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_back(capacity + capacity).expect("successful allocation");

                                _ = actual.shift(isize::try_from(capacity).expect("too small to wrap")).expect("enough back capacity to shift into");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, capacity);
                                debug_assert_eq!(actual.back_capacity, capacity);

                                _ = actual.shrink_front(capacity).expect("successful reallocation");

                                let allocation = actual.buffer;

                                for element in 0..capacity {
                                    _ = actual.prepend(element).expect("uses capacity");
                                }

                                assert_eq!(actual.buffer, allocation);
                            }
                        }
                    }

                    mod when_not_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_front_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let mut actual: Dynamic<_> = (0..elements).collect();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");
                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    _ = actual.shrink_front(capacity).expect("exactly enough capacity");

                                    assert_eq!(actual.front_capacity, capacity);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_back_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let mut actual: Dynamic<_> = (0..elements).collect();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");
                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    _ = actual.shrink_front(capacity).expect("exactly enough capacity");

                                    assert_eq!(actual.back_capacity, capacity);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_initialized_elements() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let expected = 0..elements;

                                    let mut actual: Dynamic<_> = expected.clone().collect();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");
                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    _ = actual.shrink_front(capacity).expect("exactly enough capacity");

                                    assert!(actual.eq(expected));
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_reallocate_memory() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let mut actual: Dynamic<_> = (0..elements).collect();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");
                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    let allocation = actual.buffer;

                                    _ = actual.shrink_front(capacity).expect("exactly enough capacity");

                                    assert_eq!(actual.buffer, allocation);
                                }
                            }
                        }

                        #[test]
                        fn then_front_many_elements_can_be_prepended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let expected = 0..elements;

                                    let mut actual: Dynamic<_> = expected.clone().collect();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");
                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    _ = actual.shrink_front(capacity).expect("exactly enough capacity");

                                    let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                    for _ in 0..capacity {
                                        // NOTE: this is distinct from the expected values.
                                        _ = actual.prepend(usize::MAX).expect("uses capacity");
                                    }

                                    assert!(pointers.iter().copied().eq(expected));
                                }
                            }
                        }

                        #[test]
                        fn then_back_many_elements_can_be_appended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let expected = 0..elements;

                                    let mut actual: Dynamic<_> = expected.clone().collect();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");
                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    _ = actual.shrink_front(capacity).expect("exactly enough capacity");

                                    let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                    for _ in 0..capacity {
                                        // NOTE: this is distinct from the expected values.
                                        _ = actual.append(usize::MAX).expect("uses capacity");
                                    }

                                    assert!(pointers.iter().copied().eq(expected));
                                }
                            }
                        }

                        #[test]
                        fn then_both_front_many_elements_can_be_prepended_and_back_many_elements_can_be_appended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let expected = 0..elements;

                                    let mut actual: Dynamic<_> = expected.clone().collect();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");
                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    _ = actual.shrink_front(capacity).expect("exactly enough capacity");

                                    let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                    for _ in 0..capacity {
                                        // NOTE: this is distinct from the expected values.
                                        _ = actual.prepend(usize::MAX).expect("uses capacity");
                                    }

                                    for _ in 0..capacity {
                                        // NOTE: this is distinct from the expected values.
                                        _ = actual.append(usize::MAX).expect("uses capacity");
                                    }

                                    assert!(pointers.iter().copied().eq(expected));
                                }
                            }
                        }
                    }
                }

                mod when_front_is_more_than_requested_and_back_is_less_than_requested {
                    use super::*;

                    mod when_empty {
                        use super::*;

                        #[test]
                        fn then_decreases_capacity_to_exactly_requested() {
                            for capacity in 1..32 {
                                for more in capacity..(capacity + 32) {
                                    for less in 1..capacity {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(more + less).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(more).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, more);
                                        debug_assert_eq!(actual.back_capacity, less);

                                        _ = actual.shrink_front(capacity).expect("successful reallocation");

                                        assert_eq!(actual.capacity(), capacity);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_initialize_elements() {
                            for capacity in 1..32 {
                                for more in capacity..(capacity + 32) {
                                    for less in 1..capacity {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(more + less).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(more).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, more);
                                        debug_assert_eq!(actual.back_capacity, less);

                                        _ = actual.shrink_front(capacity).expect("successful reallocation");

                                        assert_eq!(actual.initialized, 0);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_requested_many_elements_can_be_prepended_without_reallocating_memory() {
                            for capacity in 1..32 {
                                for more in capacity..(capacity + 32) {
                                    for less in 1..capacity {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(more + less).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(more).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, more);
                                        debug_assert_eq!(actual.back_capacity, less);

                                        _ = actual.shrink_front(capacity).expect("successful reallocation");

                                        let allocation = actual.buffer;

                                        for element in 0..capacity {
                                            _ = actual.prepend(element).expect("uses capacity");
                                        }

                                        assert_eq!(actual.buffer, allocation);
                                    }
                                }
                            }
                        }
                    }

                    mod when_not_empty {
                        use super::*;

                        #[test]
                        fn then_decreases_front_capacity_to_exactly_requested() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for more in capacity..(capacity + 32) {
                                        for less in 1..capacity {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(more).expect("successful allocation");
                                            _ = actual.reserve_back(less).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, more);
                                            debug_assert_eq!(actual.back_capacity, less);

                                            _ = actual.shrink_front(capacity).expect("successful reallocation");

                                            assert_eq!(actual.front_capacity, capacity);
                                        }
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_back_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for more in capacity..(capacity + 32) {
                                        for less in 1..capacity {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(more).expect("successful allocation");
                                            _ = actual.reserve_back(less).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, more);
                                            debug_assert_eq!(actual.back_capacity, less);

                                            _ = actual.shrink_front(capacity).expect("successful reallocation");

                                            assert_eq!(actual.back_capacity, less);
                                        }
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_initialized_elements() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for more in capacity..(capacity + 32) {
                                        for less in 1..capacity {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(more).expect("successful allocation");
                                            _ = actual.reserve_back(less).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, more);
                                            debug_assert_eq!(actual.back_capacity, less);

                                            _ = actual.shrink_front(capacity).expect("successful reallocation");

                                            assert!(actual.eq(expected));
                                        }
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_front_many_elements_can_be_prepended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for more in capacity..(capacity + 32) {
                                        for less in 1..capacity {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(more).expect("successful allocation");
                                            _ = actual.reserve_back(less).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, more);
                                            debug_assert_eq!(actual.back_capacity, less);

                                            _ = actual.shrink_front(capacity).expect("successful reallocation");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..capacity {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.prepend(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_back_many_elements_can_be_appended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for more in capacity..(capacity + 32) {
                                        for less in 1..capacity {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(more).expect("successful allocation");
                                            _ = actual.reserve_back(less).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, more);
                                            debug_assert_eq!(actual.back_capacity, less);

                                            _ = actual.shrink_front(capacity).expect("successful reallocation");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..less {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.append(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_both_front_many_elements_can_be_prepended_and_back_many_elements_can_be_appended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for more in capacity..(capacity + 32) {
                                        for less in 1..capacity {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(more).expect("successful allocation");
                                            _ = actual.reserve_back(less).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, more);
                                            debug_assert_eq!(actual.back_capacity, less);

                                            _ = actual.shrink_front(capacity).expect("successful reallocation");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..capacity {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.prepend(usize::MAX).expect("uses capacity");
                                            }

                                            for _ in 0..less {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.append(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                mod when_front_is_less_than_requested_and_back_is_more_than_requested {
                    use super::*;

                    mod when_empty {
                        use super::*;

                        #[test]
                        fn then_decreases_capacity_to_exactly_requested() {
                            for capacity in 1..32 {
                                for more in capacity..(capacity + 32) {
                                    for less in 1..capacity {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(less + more).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(less).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, less);
                                        debug_assert_eq!(actual.back_capacity, more);

                                        _ = actual.shrink_front(capacity).expect("successful reallocation");

                                        assert_eq!(actual.capacity(), capacity);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_initialize_elements() {
                            for capacity in 1..32 {
                                for more in capacity..(capacity + 32) {
                                    for less in 1..capacity {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(less + more).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(less).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, less);
                                        debug_assert_eq!(actual.back_capacity, more);

                                        _ = actual.shrink_front(capacity).expect("successful reallocation");

                                        assert_eq!(actual.initialized, 0);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_requested_many_elements_can_be_prepended_without_reallocating_memory() {
                            for capacity in 1..32 {
                                for more in capacity..(capacity + 32) {
                                    for less in 1..capacity {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(less + more).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(less).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, less);
                                        debug_assert_eq!(actual.back_capacity, more);

                                        _ = actual.shrink_front(capacity).expect("successful reallocation");

                                        let allocation = actual.buffer;

                                        for element in 0..capacity {
                                            _ = actual.prepend(element).expect("uses capacity");
                                        }

                                        assert_eq!(actual.buffer, allocation);
                                    }
                                }
                            }
                        }
                    }

                    mod when_not_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_front_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for more in capacity..(capacity + 32) {
                                        for less in 1..capacity {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(less).expect("successful allocation");
                                            _ = actual.reserve_back(more).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, less);
                                            debug_assert_eq!(actual.back_capacity, more);

                                            _ = actual.shrink_front(capacity).expect_err("less capacity");

                                            assert_eq!(actual.front_capacity, less);
                                        }
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_back_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for more in capacity..(capacity + 32) {
                                        for less in 1..capacity {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(less).expect("successful allocation");
                                            _ = actual.reserve_back(more).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, less);
                                            debug_assert_eq!(actual.back_capacity, more);

                                            _ = actual.shrink_front(capacity).expect_err("less capacity");

                                            assert_eq!(actual.back_capacity, more);
                                        }
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_initialized_elements() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for more in capacity..(capacity + 32) {
                                        for less in 1..capacity {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(less).expect("successful allocation");
                                            _ = actual.reserve_back(more).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, less);
                                            debug_assert_eq!(actual.back_capacity, more);

                                            _ = actual.shrink_front(capacity).expect_err("less capacity");

                                            assert!(actual.eq(expected));
                                        }
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_reallocate_memory() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for more in capacity..(capacity + 32) {
                                        for less in 1..capacity {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(less).expect("successful allocation");
                                            _ = actual.reserve_back(more).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, less);
                                            debug_assert_eq!(actual.back_capacity, more);

                                            let allocation = actual.buffer;

                                            _ = actual.shrink_front(capacity).expect_err("less capacity");

                                            assert_eq!(actual.buffer, allocation);
                                        }
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_front_many_elements_can_be_prepended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for more in capacity..(capacity + 32) {
                                        for less in 1..capacity {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(less).expect("successful allocation");
                                            _ = actual.reserve_back(more).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, less);
                                            debug_assert_eq!(actual.back_capacity, more);

                                            _ = actual.shrink_front(capacity).expect_err("less capacity");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..less {
                                                _ = actual.prepend(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_back_many_elements_can_be_appended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for more in capacity..(capacity + 32) {
                                        for less in 1..capacity {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(less).expect("successful allocation");
                                            _ = actual.reserve_back(more).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, less);
                                            debug_assert_eq!(actual.back_capacity, more);

                                            _ = actual.shrink_front(capacity).expect_err("less capacity");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..more {
                                                _ = actual.append(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_both_front_many_elements_can_be_prepended_and_back_many_elements_can_be_appended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for more in capacity..(capacity + 32) {
                                        for less in 1..capacity {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(less).expect("successful allocation");
                                            _ = actual.reserve_back(more).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, less);
                                            debug_assert_eq!(actual.back_capacity, more);

                                            _ = actual.shrink_front(capacity).expect_err("less capacity");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..less {
                                                _ = actual.prepend(usize::MAX).expect("uses capacity");
                                            }

                                            for _ in 0..more {
                                                _ = actual.append(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                mod when_both_more_than_requested {
                    use super::*;

                    mod when_empty {
                        use super::*;

                        #[test]
                        fn then_decreases_capacity_to_exactly_requested() {
                            for capacity in 1..32 {
                                for additional_front in 1..32 {
                                    for additional_back in 1..32 {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(capacity + additional_front + capacity + additional_back).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(capacity + additional_front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, capacity + additional_front);
                                        debug_assert_eq!(actual.back_capacity, capacity + additional_back);

                                        _ = actual.shrink_front(capacity).expect("successful reallocation");

                                        assert_eq!(actual.capacity(), capacity);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_initialize_elements() {
                            for capacity in 1..32 {
                                for additional_front in 1..32 {
                                    for additional_back in 1..32 {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(capacity + additional_front + capacity + additional_back).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(capacity + additional_front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, capacity + additional_front);
                                        debug_assert_eq!(actual.back_capacity, capacity + additional_back);

                                        _ = actual.shrink_front(capacity).expect("successful reallocation");

                                        assert_eq!(actual.initialized, 0);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_requested_many_elements_can_be_prepended_without_reallocating_memory() {
                            for capacity in 1..32 {
                                for additional_front in 1..32 {
                                    for additional_back in 1..32 {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(capacity + additional_front + capacity + additional_back).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(capacity + additional_front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, capacity + additional_front);
                                        debug_assert_eq!(actual.back_capacity, capacity + additional_back);

                                        _ = actual.shrink_front(capacity).expect("successful reallocation");

                                        let allocation = actual.buffer;

                                        for element in 0..capacity {
                                            _ = actual.prepend(element).expect("uses capacity");
                                        }

                                        assert_eq!(actual.buffer, allocation);
                                    }
                                }
                            }
                        }
                    }

                    mod when_not_empty {
                        use super::*;

                        #[test]
                        fn then_decreases_front_capacity_to_exactly_requested() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional_front in 1..32 {
                                        for additional_back in 1..32 {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(capacity + additional_front).expect("successful allocation");
                                            _ = actual.reserve_back(capacity + additional_back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, capacity + additional_front);
                                            debug_assert_eq!(actual.back_capacity, capacity + additional_back);

                                            _ = actual.shrink_front(capacity).expect("successful reallocation");

                                            assert_eq!(actual.front_capacity, capacity);
                                        }
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_back_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional_front in 1..32 {
                                        for additional_back in 1..32 {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(capacity + additional_front).expect("successful allocation");
                                            _ = actual.reserve_back(capacity + additional_back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, capacity + additional_front);
                                            debug_assert_eq!(actual.back_capacity, capacity + additional_back);

                                            _ = actual.shrink_front(capacity).expect("successful reallocation");

                                            assert_eq!(actual.back_capacity, capacity + additional_back);
                                        }
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_initialized_elements() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional_front in 1..32 {
                                        for additional_back in 1..32 {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(capacity + additional_front).expect("successful allocation");
                                            _ = actual.reserve_back(capacity + additional_back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, capacity + additional_front);
                                            debug_assert_eq!(actual.back_capacity, capacity + additional_back);

                                            _ = actual.shrink_front(capacity).expect("successful reallocation");

                                            assert!(actual.eq(expected));
                                        }
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_front_many_elements_can_be_prepended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional_front in 1..32 {
                                        for additional_back in 1..32 {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(capacity + additional_front).expect("successful allocation");
                                            _ = actual.reserve_back(capacity + additional_back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, capacity + additional_front);
                                            debug_assert_eq!(actual.back_capacity, capacity + additional_back);

                                            _ = actual.shrink_front(capacity).expect("successful reallocation");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..capacity {
                                                // NOTE: this value is distinct from the expected values.
                                                _ = actual.prepend(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_back_many_elements_can_be_appended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional_front in 1..32 {
                                        for additional_back in 1..32 {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(capacity + additional_front).expect("successful allocation");
                                            _ = actual.reserve_back(capacity + additional_back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, capacity + additional_front);
                                            debug_assert_eq!(actual.back_capacity, capacity + additional_back);

                                            _ = actual.shrink_front(capacity).expect("successful reallocation");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..(capacity + additional_back) {
                                                // NOTE: this value is distinct from the expected values.
                                                _ = actual.append(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_both_front_many_elements_can_be_prepended_and_back_many_elements_can_be_appended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional_front in 1..32 {
                                        for additional_back in 1..32 {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(capacity + additional_front).expect("successful allocation");
                                            _ = actual.reserve_back(capacity + additional_back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, capacity + additional_front);
                                            debug_assert_eq!(actual.back_capacity, capacity + additional_back);

                                            _ = actual.shrink_front(capacity).expect("successful reallocation");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..capacity {
                                                // NOTE: this value is distinct from the expected values.
                                                _ = actual.prepend(usize::MAX).expect("uses capacity");
                                            }

                                            for _ in 0..(capacity + additional_back) {
                                                // NOTE: this value is distinct from the expected values.
                                                _ = actual.append(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        mod shrink_back {
            use super::*;

            mod when_no_capacity {
                use super::*;

                mod when_zero_requested {
                    use super::*;

                    mod when_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_capacity() {
                            let mut actual = Dynamic::<usize>::default();

                            debug_assert_eq!(actual.initialized, 0);
                            debug_assert_eq!(actual.front_capacity, 0);
                            debug_assert_eq!(actual.back_capacity, 0);

                            _ = actual.shrink_back(0).expect("already no capacity");

                            assert_eq!(actual.capacity(), 0);
                        }

                        #[test]
                        fn then_does_not_initialize_elements() {
                            let mut actual = Dynamic::<usize>::default();

                            debug_assert_eq!(actual.initialized, 0);
                            debug_assert_eq!(actual.front_capacity, 0);
                            debug_assert_eq!(actual.back_capacity, 0);

                            _ = actual.shrink_back(0).expect("already no capacity");

                            assert_eq!(actual.initialized, 0);
                        }
                    }

                    mod when_not_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_front_capacity() {
                            for elements in 1..32 {
                                let mut actual: Dynamic<_> = (0..elements).collect();

                                debug_assert_eq!(actual.initialized, elements);
                                debug_assert_eq!(actual.front_capacity, 0);
                                debug_assert_eq!(actual.back_capacity, 0);

                                _ = actual.shrink_back(0).expect("already no capacity");

                                assert_eq!(actual.front_capacity, 0);
                            }
                        }

                        #[test]
                        fn then_does_not_modify_back_capacity() {
                            for elements in 1..32 {
                                let mut actual: Dynamic<_> = (0..elements).collect();

                                debug_assert_eq!(actual.initialized, elements);
                                debug_assert_eq!(actual.front_capacity, 0);
                                debug_assert_eq!(actual.back_capacity, 0);

                                _ = actual.shrink_back(0).expect("already no capacity");

                                assert_eq!(actual.back_capacity, 0);
                            }
                        }

                        #[test]
                        fn then_does_not_modify_initialized_elements() {
                            for elements in 1..32 {
                                let expected = 0..elements;

                                let mut actual: Dynamic<_> = expected.clone().collect();

                                debug_assert_eq!(actual.initialized, elements);
                                debug_assert_eq!(actual.front_capacity, 0);
                                debug_assert_eq!(actual.back_capacity, 0);

                                _ = actual.shrink_back(0).expect("already no capacity");

                                assert!(actual.eq(expected));
                            }
                        }

                        #[test]
                        fn then_does_not_reallocate_memory() {
                            for elements in 1..32 {
                                let mut actual: Dynamic<_> = (0..elements).collect();

                                debug_assert_eq!(actual.initialized, elements);
                                debug_assert_eq!(actual.front_capacity, 0);
                                debug_assert_eq!(actual.back_capacity, 0);

                                let allocation = actual.buffer;

                                _ = actual.shrink_back(0).expect("already no capacity");

                                assert_eq!(actual.buffer, allocation);
                            }
                        }
                    }
                }

                mod when_more_than_zero_requested {
                    use super::*;

                    mod when_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_capacity() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, 0);
                                debug_assert_eq!(actual.back_capacity, 0);

                                _ = actual.shrink_back(capacity).expect_err("less");

                                assert_eq!(actual.capacity(), 0);
                            }
                        }

                        #[test]
                        fn then_does_not_initialize_elements() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, 0);
                                debug_assert_eq!(actual.back_capacity, 0);

                                _ = actual.shrink_back(capacity).expect_err("less");

                                assert_eq!(actual.initialized, 0);
                            }
                        }
                    }

                    mod when_not_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_front_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let mut actual: Dynamic<_> = (0..elements).collect();

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.shrink_back(capacity).expect_err("less");

                                    assert_eq!(actual.front_capacity, 0);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_back_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let mut actual: Dynamic<_> = (0..elements).collect();

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.shrink_back(capacity).expect_err("less");

                                    assert_eq!(actual.back_capacity, 0);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_initialized_elements() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let expected = 0..elements;

                                    let mut actual: Dynamic<_> = expected.clone().collect();

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.shrink_back(capacity).expect_err("less");

                                    assert!(actual.eq(expected));
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_reallocate_memory() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let mut actual: Dynamic<_> = (0..elements).collect();

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    let allocation = actual.buffer;

                                    _ = actual.shrink_back(capacity).expect_err("less");

                                    assert_eq!(actual.buffer, allocation);
                                }
                            }
                        }
                    }
                }
            }

            mod when_only_front_capacity {
                use super::*;

                mod when_zero_requested {
                    use super::*;

                    mod when_empty {
                        use super::*;

                        #[test]
                        fn then_decreases_capacity_to_zero() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_front(capacity).expect("successful allocation");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, capacity);
                                debug_assert_eq!(actual.back_capacity, 0);

                                _ = actual.shrink_back(0).expect("successful deallocation");

                                assert_eq!(actual.capacity(), 0);
                            }
                        }

                        #[test]
                        fn then_does_not_initialize_elements() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_front(capacity).expect("successful allocation");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, capacity);
                                debug_assert_eq!(actual.back_capacity, 0);

                                _ = actual.shrink_back(0).expect("successful deallocation");

                                assert_eq!(actual.initialized, 0);
                            }
                        }
                    }

                    mod when_not_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_front_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let mut actual: Dynamic<_> = (0..elements).collect();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.shrink_back(0).expect("already no capacity");

                                    assert_eq!(actual.front_capacity, capacity);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_back_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let mut actual: Dynamic<_> = (0..elements).collect();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.shrink_back(0).expect("already no capacity");

                                    assert_eq!(actual.back_capacity, 0);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_initialized_elements() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let expected = 0..elements;

                                    let mut actual: Dynamic<_> = expected.clone().collect();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.shrink_back(0).expect("already no capacity");

                                    assert!(actual.eq(expected));
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_reallocate_memory() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let mut actual: Dynamic<_> = (0..elements).collect();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    let allocation = actual.buffer;

                                    _ = actual.shrink_back(0).expect("already no capacity");

                                    assert_eq!(actual.buffer, allocation);
                                }
                            }
                        }

                        #[test]
                        fn then_capacity_many_elements_can_be_prepended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let expected = 0..elements;

                                    let mut actual: Dynamic<_> = expected.clone().collect();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.shrink_back(0).expect("already no capacity");

                                    let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                    for _ in 0..capacity {
                                        // NOTE: this is distinct from the expected values.
                                        _ = actual.prepend(usize::MAX).expect("uses capacity");
                                    }

                                    assert!(pointers.iter().copied().eq(expected));
                                }
                            }
                        }
                    }
                }

                mod when_less_than_requested {
                    use super::*;

                    mod when_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_capacity() {
                            for capacity in 1..32 {
                                for additional in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.shrink_back(capacity + additional).expect_err("less capacity");

                                    assert_eq!(actual.capacity(), capacity);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_initialize_elements() {
                            for capacity in 1..32 {
                                for additional in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.shrink_back(capacity + additional).expect_err("less capacity");

                                    assert_eq!(actual.initialized, 0);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_reallocate_memory() {
                            for capacity in 1..32 {
                                for additional in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    let allocation = actual.buffer;

                                    _ = actual.shrink_back(capacity + additional).expect_err("less capacity");

                                    assert_eq!(actual.buffer, allocation);
                                }
                            }
                        }

                        #[test]
                        fn then_capacity_many_elements_can_be_appended_without_reallocating_memory() {
                            for capacity in 1..32 {
                                for additional in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.shrink_back(capacity + additional).expect_err("less capacity");

                                    let allocation = actual.buffer;

                                    for element in 0..capacity {
                                        _ = actual.append(element).expect("uses capacity");
                                    }

                                    assert_eq!(actual.buffer, allocation);
                                }
                            }
                        }
                    }

                    mod when_not_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_front_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let mut actual: Dynamic<_> = (0..elements).collect();

                                        _ = actual.reserve_front(capacity).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, capacity);
                                        debug_assert_eq!(actual.back_capacity, 0);

                                        _ = actual.shrink_back(capacity + additional).expect_err("less capacity");

                                        assert_eq!(actual.front_capacity, capacity);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_back_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let mut actual: Dynamic<_> = (0..elements).collect();

                                        _ = actual.reserve_front(capacity).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, capacity);
                                        debug_assert_eq!(actual.back_capacity, 0);

                                        _ = actual.shrink_back(capacity + additional).expect_err("less capacity");

                                        assert_eq!(actual.back_capacity, 0);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_initialized_elements() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let expected = 0..elements;

                                        let mut actual: Dynamic<_> = expected.clone().collect();

                                        _ = actual.reserve_front(capacity).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, capacity);
                                        debug_assert_eq!(actual.back_capacity, 0);

                                        _ = actual.shrink_back(capacity + additional).expect_err("less capacity");

                                        assert!(actual.eq(expected));
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_reallocate_memory() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let mut actual: Dynamic<_> = (0..elements).collect();

                                        _ = actual.reserve_front(capacity).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, capacity);
                                        debug_assert_eq!(actual.back_capacity, 0);

                                        let allocation = actual.buffer;

                                        _ = actual.shrink_back(capacity + additional).expect_err("less capacity");

                                        assert_eq!(actual.buffer, allocation);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_capacity_many_elements_can_be_prepended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let expected = 0..elements;

                                        let mut actual: Dynamic<_> = expected.clone().collect();

                                        _ = actual.reserve_front(capacity).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, capacity);
                                        debug_assert_eq!(actual.back_capacity, 0);

                                        _ = actual.shrink_back(capacity + additional).expect_err("less capacity");

                                        let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                        for _ in 0..capacity {
                                            // NOTE: this is distinct from the expected values.
                                            _ = actual.prepend(usize::MAX).expect("uses capacity");
                                        }

                                        assert!(pointers.iter().copied().eq(expected));
                                    }
                                }
                            }
                        }
                    }
                }

                mod when_exactly_requested {
                    use super::*;

                    mod when_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_capacity() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_front(capacity).expect("successful allocation");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, capacity);
                                debug_assert_eq!(actual.back_capacity, 0);

                                _ = actual.shrink_back(capacity).expect("already exact capacity");

                                assert_eq!(actual.capacity(), capacity);
                            }
                        }

                        #[test]
                        fn then_does_not_initialize_elements() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_front(capacity).expect("successful allocation");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, capacity);
                                debug_assert_eq!(actual.back_capacity, 0);

                                _ = actual.shrink_back(capacity).expect("already exact capacity");

                                assert_eq!(actual.initialized, 0);
                            }
                        }

                        #[test]
                        fn then_does_not_reallocate_memory() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_front(capacity).expect("successful allocation");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, capacity);
                                debug_assert_eq!(actual.back_capacity, 0);

                                let allocation = actual.buffer;

                                _ = actual.shrink_back(capacity).expect("already exact capacity");

                                assert_eq!(actual.buffer, allocation);
                            }
                        }

                        #[test]
                        fn then_requested_many_elements_can_be_appended_without_reallocating_memory() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_front(capacity).expect("successful allocation");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, capacity);
                                debug_assert_eq!(actual.back_capacity, 0);

                                _ = actual.shrink_back(capacity).expect("already exact capacity");

                                let allocation = actual.buffer;

                                for element in 1..capacity {
                                    _ = actual.append(element).expect("uses capacity");
                                }

                                assert_eq!(actual.buffer, allocation);
                            }
                        }
                    }

                    mod when_not_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_front_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let mut actual: Dynamic<_> = (0..elements).collect();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.shrink_back(capacity).expect_err("less capacity");

                                    assert_eq!(actual.front_capacity, capacity);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_back_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let mut actual: Dynamic<_> = (0..elements).collect();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.shrink_back(capacity).expect_err("less capacity");

                                    assert_eq!(actual.back_capacity, 0);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_initialized_elements() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let expected = 0..elements;

                                    let mut actual: Dynamic<_> = expected.clone().collect();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.shrink_back(capacity).expect_err("less capacity");

                                    assert!(actual.eq(expected));
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_reallocate_memory() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let mut actual: Dynamic<_> = (0..elements).collect();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    let allocation = actual.buffer;

                                    _ = actual.shrink_back(capacity).expect_err("less capacity");

                                    assert_eq!(actual.buffer, allocation);
                                }
                            }
                        }

                        #[test]
                        fn then_capacity_many_elements_can_be_prepended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let expected = 0..elements;

                                    let mut actual: Dynamic<_> = expected.clone().collect();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.shrink_back(capacity).expect_err("less capacity");

                                    let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                    for _ in 0..capacity {
                                        // NOTE: this is distinct from the expected values.
                                        _ = actual.prepend(usize::MAX).expect("uses capacity");
                                    }

                                    assert!(pointers.iter().copied().eq(expected));
                                }
                            }
                        }
                    }
                }

                mod when_more_than_requested {
                    use super::*;

                    mod when_empty {
                        use super::*;

                        #[test]
                        fn then_decreases_capacity_to_exactly_requested() {
                            for capacity in 1..32 {
                                for additional in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_front(capacity + additional).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, capacity + additional);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.shrink_back(capacity).expect("successful reallocation");

                                    assert_eq!(actual.capacity(), capacity);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_initialize_elements() {
                            for capacity in 1..32 {
                                for additional in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_front(capacity + additional).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, capacity + additional);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.shrink_back(capacity).expect("successful reallocation");

                                    assert_eq!(actual.initialized, 0);
                                }
                            }
                        }

                        #[test]
                        fn then_requested_many_elements_can_be_appended_without_reallocating_memory() {
                            for capacity in 1..32 {
                                for additional in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_front(capacity + additional).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, capacity + additional);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.shrink_back(capacity).expect("successful reallocation");

                                    let allocation = actual.buffer;

                                    for element in 0..capacity {
                                        _ = actual.append(element).expect("uses capacity");
                                    }

                                    assert_eq!(actual.buffer, allocation);
                                }
                            }
                        }
                    }

                    mod when_not_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_front_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let mut actual: Dynamic<_> = (0..elements).collect();

                                        _ = actual.reserve_front(capacity + additional).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, capacity + additional);
                                        debug_assert_eq!(actual.back_capacity, 0);

                                        _ = actual.shrink_back(capacity).expect_err("less capacity");

                                        assert_eq!(actual.front_capacity, capacity + additional);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_back_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let mut actual: Dynamic<_> = (0..elements).collect();

                                        _ = actual.reserve_front(capacity + additional).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, capacity + additional);
                                        debug_assert_eq!(actual.back_capacity, 0);

                                        _ = actual.shrink_back(capacity).expect_err("less capacity");

                                        assert_eq!(actual.back_capacity, 0);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_initialized_elements() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let expected = 0..elements;

                                        let mut actual: Dynamic<_> = expected.clone().collect();

                                        _ = actual.reserve_front(capacity + additional).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, capacity + additional);
                                        debug_assert_eq!(actual.back_capacity, 0);

                                        _ = actual.shrink_back(capacity).expect_err("less capacity");

                                        assert!(actual.eq(expected));
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_reallocate_memory() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let mut actual: Dynamic<_> = (0..elements).collect();

                                        _ = actual.reserve_front(capacity + additional).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, capacity + additional);
                                        debug_assert_eq!(actual.back_capacity, 0);

                                        let allocation = actual.buffer;

                                        _ = actual.shrink_back(capacity).expect_err("less capacity");

                                        assert_eq!(actual.buffer, allocation);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_capacity_many_elements_can_be_prepended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let expected = 0..elements;

                                        let mut actual: Dynamic<_> = expected.clone().collect();

                                        _ = actual.reserve_front(capacity + additional).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, capacity + additional);
                                        debug_assert_eq!(actual.back_capacity, 0);

                                        _ = actual.shrink_back(capacity).expect_err("less capacity");

                                        let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                        for _ in 0..(capacity + additional) {
                                            // NOTE: this ios distinct from the expected values.
                                            _ = actual.prepend(usize::MAX).expect("uses capacity");
                                        }

                                        assert!(pointers.iter().copied().eq(expected));
                                    }
                                }
                            }
                        }
                    }
                }
            }

            mod when_only_back_capacity {
                use super::*;

                mod when_zero_requested {
                    use super::*;

                    mod when_empty {
                        use super::*;

                        #[test]
                        fn then_decreases_capacity_to_zero() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_back(capacity).expect("successful allocation");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, 0);
                                debug_assert_eq!(actual.back_capacity, capacity);

                                _ = actual.shrink_back(0).expect("already no capacity");

                                assert_eq!(actual.capacity(), 0);
                            }
                        }

                        #[test]
                        fn then_does_not_initialize_elements() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_back(capacity).expect("successful allocation");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, 0);
                                debug_assert_eq!(actual.back_capacity, capacity);

                                _ = actual.shrink_back(0).expect("already no capacity");

                                assert_eq!(actual.initialized, 0);
                            }
                        }
                    }

                    mod when_not_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_front_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let mut actual: Dynamic<_> = (0..elements).collect();

                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    _ = actual.shrink_back(0).expect("already no capacity");

                                    assert_eq!(actual.front_capacity, 0);
                                }
                            }
                        }

                        #[test]
                        fn then_decreases_back_capacity_to_zero() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let mut actual: Dynamic<_> = (0..elements).collect();

                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    _ = actual.shrink_back(0).expect("already no capacity");

                                    assert_eq!(actual.back_capacity, 0);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_initialized_elements() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let expected = 0..elements;

                                    let mut actual: Dynamic<_> = expected.clone().collect();

                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    _ = actual.shrink_back(0).expect("already no capacity");

                                    assert!(actual.eq(expected));
                                }
                            }
                        }
                    }
                }

                mod when_less_than_requested {
                    use super::*;

                    mod when_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_capacity() {
                            for capacity in 1..32 {
                                for additional in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    _ = actual.shrink_back(capacity + additional).expect_err("less capacity");

                                    assert_eq!(actual.capacity(), capacity);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_initialize_elements() {
                            for capacity in 1..32 {
                                for additional in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    _ = actual.shrink_back(capacity + additional).expect_err("less capacity");

                                    assert_eq!(actual.initialized, 0);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_reallocate_memory() {
                            for capacity in 1..32 {
                                for additional in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    let allocation = actual.buffer;

                                    _ = actual.shrink_back(capacity + additional).expect_err("less capacity");

                                    assert_eq!(actual.buffer, allocation);
                                }
                            }
                        }

                        #[test]
                        fn then_capacity_many_elements_can_be_appended_without_reallocating_memory() {
                            for capacity in 1..32 {
                                for additional in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    _ = actual.shrink_back(capacity + additional).expect_err("less capacity");

                                    let allocation = actual.buffer;

                                    for element in 0..capacity {
                                        _ = actual.append(element).expect("uses capacity");
                                    }

                                    assert_eq!(actual.buffer, allocation);
                                }
                            }
                        }
                    }

                    mod when_not_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_front_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let mut actual: Dynamic<_> = (0..elements).collect();

                                        _ = actual.reserve_back(capacity).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, 0);
                                        debug_assert_eq!(actual.back_capacity, capacity);

                                        _ = actual.shrink_back(capacity + additional).expect_err("less capacity");

                                        assert_eq!(actual.front_capacity, 0);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_back_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let mut actual: Dynamic<_> = (0..elements).collect();

                                        _ = actual.reserve_back(capacity).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, 0);
                                        debug_assert_eq!(actual.back_capacity, capacity);

                                        _ = actual.shrink_back(capacity + additional).expect_err("less capacity");

                                        assert_eq!(actual.back_capacity, capacity);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_initialized_elements() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let expected = 0..elements;

                                        let mut actual: Dynamic<_> = expected.clone().collect();

                                        _ = actual.reserve_back(capacity).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, 0);
                                        debug_assert_eq!(actual.back_capacity, capacity);

                                        _ = actual.shrink_back(capacity + additional).expect_err("less capacity");

                                        assert!(actual.eq(expected));
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_reallocate_memory() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let mut actual: Dynamic<_> = (0..elements).collect();

                                        _ = actual.reserve_back(capacity).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, 0);
                                        debug_assert_eq!(actual.back_capacity, capacity);

                                        let allocation = actual.buffer;

                                        _ = actual.shrink_back(capacity + additional).expect_err("less capacity");

                                        assert_eq!(actual.buffer, allocation);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_capacity_many_elements_can_be_appended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let expected = 0..elements;

                                        let mut actual: Dynamic<_> = expected.clone().collect();

                                        _ = actual.reserve_back(capacity).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, 0);
                                        debug_assert_eq!(actual.back_capacity, capacity);

                                        _ = actual.shrink_back(capacity + additional).expect_err("less capacity");

                                        let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                        for _ in 0..capacity {
                                            // NOTE: this is distinct from the expected values.
                                            _ = actual.append(usize::MAX).expect("uses capacity");
                                        }

                                        assert!(pointers.iter().copied().eq(expected));
                                    }
                                }
                            }
                        }
                    }
                }

                mod when_exactly_requested {
                    use super::*;

                    mod when_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_capacity() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_back(capacity).expect("successful allocation");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, 0);
                                debug_assert_eq!(actual.back_capacity, capacity);

                                _ = actual.shrink_back(capacity).expect("already exact capacity");

                                assert_eq!(actual.capacity(), capacity);
                            }
                        }

                        #[test]
                        fn then_does_not_initialize_elements() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_back(capacity).expect("successful allocation");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, 0);
                                debug_assert_eq!(actual.back_capacity, capacity);

                                _ = actual.shrink_back(capacity).expect("already exact capacity");

                                assert_eq!(actual.initialized, 0);
                            }
                        }

                        #[test]
                        fn then_does_not_reallocate_memory() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_back(capacity).expect("successful allocation");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, 0);
                                debug_assert_eq!(actual.back_capacity, capacity);

                                let allocation = actual.buffer;

                                _ = actual.shrink_back(capacity).expect("already exact capacity");

                                assert_eq!(actual.buffer, allocation);
                            }
                        }

                        #[test]
                        fn then_requested_many_elements_can_be_appended_without_reallocating_memory() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_back(capacity).expect("successful allocation");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, 0);
                                debug_assert_eq!(actual.back_capacity, capacity);

                                _ = actual.shrink_back(capacity).expect("already exact capacity");

                                let allocation = actual.buffer;

                                for element in 0..capacity {
                                    _ = actual.append(element).expect("uses capacity");
                                }

                                assert_eq!(actual.buffer, allocation);
                            }
                        }
                    }

                    mod when_not_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_front_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let mut actual: Dynamic<_> = (0..elements).collect();

                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    _ = actual.shrink_back(capacity).expect("already exact capacity");

                                    assert_eq!(actual.front_capacity, 0);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_back_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let mut actual: Dynamic<_> = (0..elements).collect();

                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    _ = actual.shrink_back(capacity).expect("already exact capacity");

                                    assert_eq!(actual.back_capacity, capacity);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_initialized_elements() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let expected = 0..elements;

                                    let mut actual: Dynamic<_> = expected.clone().collect();

                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    _ = actual.shrink_back(capacity).expect("already exact capacity");

                                    assert!(actual.eq(expected));
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_reallocate_memory() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let mut actual: Dynamic<_> = (0..elements).collect();

                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    let allocation = actual.buffer;

                                    _ = actual.shrink_back(capacity).expect("already exact capacity");

                                    assert_eq!(actual.buffer, allocation);
                                }
                            }
                        }

                        #[test]
                        fn then_requested_many_elements_can_be_appended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let expected = 0..elements;

                                    let mut actual: Dynamic<_> = expected.clone().collect();

                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    _ = actual.shrink_back(capacity).expect("already exact capacity");

                                    let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                    for _ in 0..capacity {
                                        // NOTE: this is distinct from the expected values.
                                        _ = actual.append(usize::MAX).expect("uses capacity");
                                    }

                                    assert!(pointers.iter().copied().eq(expected));
                                }
                            }
                        }
                    }
                }

                mod when_more_than_requested {
                    use super::*;

                    mod when_empty {
                        use super::*;

                        #[test]
                        fn then_decreases_capacity_to_exactly_requested() {
                            for capacity in 1..32 {
                                for additional in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_back(capacity + additional).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, capacity + additional);

                                    _ = actual.shrink_back(capacity).expect("successful reallocation");

                                    assert_eq!(actual.capacity(), capacity);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_initialize_elements() {
                            for capacity in 1..32 {
                                for additional in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_back(capacity + additional).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, capacity + additional);

                                    _ = actual.shrink_back(capacity).expect("successful reallocation");

                                    assert_eq!(actual.initialized, 0);
                                }
                            }
                        }

                        #[test]
                        fn then_requested_many_elements_can_be_appended_without_reallocating_memory() {
                            for capacity in 1..32 {
                                for additional in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_back(capacity + additional).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, capacity + additional);

                                    _ = actual.shrink_back(capacity).expect("successful reallocation");

                                    let allocation = actual.buffer;

                                    for element in 0..capacity {
                                        _ = actual.append(element).expect("uses capacity");
                                    }

                                    assert_eq!(actual.buffer, allocation);
                                }
                            }
                        }
                    }

                    mod when_not_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_front_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let mut actual: Dynamic<_> = (0..elements).collect();

                                        _ = actual.reserve_back(capacity + additional).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, 0);
                                        debug_assert_eq!(actual.back_capacity, capacity + additional);

                                        _ = actual.shrink_back(capacity).expect("successful reallocation");

                                        assert_eq!(actual.front_capacity, 0);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_decreases_back_capacity_to_exactly_requested() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let mut actual: Dynamic<_> = (0..elements).collect();

                                        _ = actual.reserve_back(capacity + additional).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, 0);
                                        debug_assert_eq!(actual.back_capacity, capacity + additional);

                                        _ = actual.shrink_back(capacity).expect("successful reallocation");

                                        assert_eq!(actual.back_capacity, capacity);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_initialized_elements() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let expected = 0..elements;

                                        let mut actual: Dynamic<_> = expected.clone().collect();

                                        _ = actual.reserve_back(capacity + additional).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, 0);
                                        debug_assert_eq!(actual.back_capacity, capacity + additional);

                                        _ = actual.shrink_back(capacity).expect("successful reallocation");

                                        assert!(actual.eq(expected));
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_requested_many_elements_can_be_appended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let expected = 0..elements;

                                        let mut actual: Dynamic<_> = expected.clone().collect();

                                        _ = actual.reserve_back(capacity + additional).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, 0);
                                        debug_assert_eq!(actual.back_capacity, capacity + additional);

                                        _ = actual.shrink_back(capacity).expect("successful reallocation");

                                        let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                        for _ in 0..capacity {
                                            // NOTE: this is distinct from the expected values.
                                            _ = actual.append(usize::MAX).expect("uses capacity");
                                        }

                                        assert!(pointers.iter().copied().eq(expected));
                                    }
                                }
                            }
                        }
                    }
                }
            }

            mod when_both_front_and_back_capacity {
                use super::*;

                mod when_zero_requested {
                    use super::*;

                    mod when_empty {
                        use super::*;

                        #[test]
                        fn then_decreases_capacity_to_zero() {
                            for front in 1..32 {
                                for back in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_back(front + back).expect("successful allocation");

                                    _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, front);
                                    debug_assert_eq!(actual.back_capacity, back);

                                    _ = actual.shrink_back(0).expect("already no capacity");

                                    assert_eq!(actual.capacity(), 0);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_initialize_elements() {
                            for front in 1..32 {
                                for back in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_back(front + back).expect("successful allocation");

                                    _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, front);
                                    debug_assert_eq!(actual.back_capacity, back);

                                    _ = actual.shrink_back(0).expect("already no capacity");

                                    assert_eq!(actual.initialized, 0);
                                }
                            }
                        }
                    }

                    mod when_not_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_front_capacity() {
                            for elements in 1..32 {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        let mut actual: Dynamic<_> = (0..elements).collect();

                                        _ = actual.reserve_front(front).expect("successful allocation");
                                        _ = actual.reserve_back(back).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.shrink_back(0).expect("already no capacity");

                                        assert_eq!(actual.front_capacity, front);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_decreases_back_capacity_to_zero() {
                            for elements in 1..32 {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        let mut actual: Dynamic<_> = (0..elements).collect();

                                        _ = actual.reserve_front(front).expect("successful allocation");
                                        _ = actual.reserve_back(back).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.shrink_back(0).expect("already no capacity");

                                        assert_eq!(actual.back_capacity, 0);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_initialized_elements() {
                            for elements in 1..32 {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        let expected = 0..elements;

                                        let mut actual: Dynamic<_> = expected.clone().collect();

                                        _ = actual.reserve_front(front).expect("successful allocation");
                                        _ = actual.reserve_back(back).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.shrink_back(0).expect("already no capacity");

                                        assert!(actual.eq(expected));
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_front_many_elements_can_be_prepended_without_reallocating_memory() {
                            for elements in 1..32 {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        let mut actual: Dynamic<_> = (0..elements).collect();

                                        _ = actual.reserve_front(front).expect("successful allocation");
                                        _ = actual.reserve_back(back).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.shrink_back(0).expect("already no capacity");

                                        let allocation = actual.buffer;

                                        for element in 0..front {
                                            _ = actual.prepend(element).expect("uses capacity");
                                        }

                                        assert_eq!(actual.buffer, allocation);
                                    }
                                }
                            }
                        }
                    }
                }

                mod when_both_less_than_requested {
                    use super::*;

                    mod when_sum_is_less_than_requested {
                        use super::*;

                        mod when_empty {
                            use super::*;

                            #[test]
                            fn then_does_not_modify_capacity() {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        for additional in 1..32 {
                                            let mut actual = Dynamic::<usize>::default();

                                            _ = actual.reserve_back(front + back).expect("successful allocation");

                                            _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                            debug_assert_eq!(actual.initialized, 0);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.shrink_back(front + back + additional).expect_err("already less capacity");

                                            assert_eq!(actual.capacity(), front + back);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_initialize_elements() {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        for additional in 1..32 {
                                            let mut actual = Dynamic::<usize>::default();

                                            _ = actual.reserve_back(front + back).expect("successful allocation");

                                            _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                            debug_assert_eq!(actual.initialized, 0);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.shrink_back(front + back + additional).expect_err("already less capacity");

                                            assert_eq!(actual.initialized, 0);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_reallocate_memory() {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        for additional in 1..32 {
                                            let mut actual = Dynamic::<usize>::default();

                                            _ = actual.reserve_back(front + back).expect("successful allocation");

                                            _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                            debug_assert_eq!(actual.initialized, 0);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            let allocation = actual.buffer;

                                            _ = actual.shrink_back(front + back + additional).expect_err("already less capacity");

                                            assert_eq!(actual.buffer, allocation);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_capacity_many_elements_can_be_appended_without_reallocating_memory() {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        for additional in 1..32 {
                                            let mut actual = Dynamic::<usize>::default();

                                            _ = actual.reserve_back(front + back).expect("successful allocation");

                                            _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                            debug_assert_eq!(actual.initialized, 0);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.shrink_back(front + back + additional).expect_err("already less capacity");

                                            let allocation = actual.buffer;

                                            for element in 0..(front + back) {
                                                _ = actual.append(element).expect("uses capacity");
                                            }

                                            assert_eq!(actual.buffer, allocation);
                                        }
                                    }
                                }
                            }
                        }

                        mod when_not_empty {
                            use super::*;

                            #[test]
                            fn then_does_not_modify_front_capacity() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            for additional in 1..32 {
                                                let mut actual: Dynamic<_> = (0..elements).collect();

                                                _ = actual.reserve_back(front + back).expect("successful allocation");

                                                _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front);
                                                debug_assert_eq!(actual.back_capacity, back);

                                                _ = actual.shrink_back(front + back + additional).expect_err("already less capacity");

                                                assert_eq!(actual.front_capacity, front);
                                            }
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_modify_back_capacity() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            for additional in 1..32 {
                                                let mut actual: Dynamic<_> = (0..elements).collect();

                                                _ = actual.reserve_back(front + back).expect("successful allocation");

                                                _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front);
                                                debug_assert_eq!(actual.back_capacity, back);

                                                _ = actual.shrink_back(front + back + additional).expect_err("already less capacity");

                                                assert_eq!(actual.back_capacity, back);
                                            }
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_modify_initialized_elements() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            for additional in 1..32 {
                                                let expected = 0..elements;

                                                let mut actual: Dynamic<_> = expected.clone().collect();

                                                _ = actual.reserve_back(front + back).expect("successful allocation");

                                                _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front);
                                                debug_assert_eq!(actual.back_capacity, back);

                                                _ = actual.shrink_back(front + back + additional).expect_err("already less capacity");

                                                assert!(actual.eq(expected));
                                            }
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_front_many_elements_can_be_prepended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            for additional in 1..32 {
                                                let expected = 0..elements;

                                                let mut actual: Dynamic<_> = expected.clone().collect();

                                                _ = actual.reserve_back(front + back).expect("successful allocation");

                                                _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front);
                                                debug_assert_eq!(actual.back_capacity, back);

                                                _ = actual.shrink_back(front + back + additional).expect_err("already less capacity");

                                                let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                                for _ in 0..front {
                                                    // NOTE: this is distinct from the expected values.
                                                    _ = actual.prepend(usize::MAX).expect("uses capacity");
                                                }

                                                assert!(pointers.iter().copied().eq(expected));
                                            }
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_back_many_elements_can_be_prepended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            for additional in 1..32 {
                                                let expected = 0..elements;

                                                let mut actual: Dynamic<_> = expected.clone().collect();

                                                _ = actual.reserve_back(front + back).expect("successful allocation");

                                                _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front);
                                                debug_assert_eq!(actual.back_capacity, back);

                                                _ = actual.shrink_back(front + back + additional).expect_err("already less capacity");

                                                let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                                for _ in 0..back {
                                                    // NOTE: this is distinct from the expected values.
                                                    _ = actual.append(usize::MAX).expect("uses capacity");
                                                }

                                                assert!(pointers.iter().copied().eq(expected));
                                            }
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_both_front_many_elements_can_be_prepended_and_back_many_elements_can_be_appended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            for additional in 1..32 {
                                                let expected = 0..elements;

                                                let mut actual: Dynamic<_> = expected.clone().collect();

                                                _ = actual.reserve_back(front + back).expect("successful allocation");

                                                _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front);
                                                debug_assert_eq!(actual.back_capacity, back);

                                                _ = actual.shrink_back(front + back + additional).expect_err("already less capacity");

                                                let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                                for _ in 0..front {
                                                    // NOTE: this is distinct from the expected values.
                                                    _ = actual.prepend(usize::MAX).expect("uses capacity");
                                                }

                                                for _ in 0..back {
                                                    // NOTE: this is distinct from the expected values.
                                                    _ = actual.append(usize::MAX).expect("uses capacity");
                                                }

                                                assert!(pointers.iter().copied().eq(expected));
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }

                    mod when_sum_is_exactly_requested {
                        use super::*;

                        mod when_empty {
                            use super::*;

                            #[test]
                            fn then_does_not_modify_capacity() {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(front + back).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.shrink_back(front + back).expect("already exact capacity");

                                        assert_eq!(actual.capacity(), front + back);
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_initialize_elements() {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(front + back).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.shrink_back(front + back).expect("already exact capacity");

                                        assert_eq!(actual.initialized, 0);
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_reallocate_memory() {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(front + back).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        let allocation = actual.buffer;

                                        _ = actual.shrink_back(front + back).expect("already exact capacity");

                                        assert_eq!(actual.buffer, allocation);
                                    }
                                }
                            }

                            #[test]
                            fn then_requested_many_elements_can_be_appended_without_reallocating_memory() {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(front + back).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.shrink_back(front + back).expect("already exact capacity");

                                        let allocation = actual.buffer;

                                        for element in 0..(front + back) {
                                            _ = actual.append(element).expect("uses capacity");
                                        }

                                        assert_eq!(actual.buffer, allocation);
                                    }
                                }
                            }
                        }

                        mod when_not_empty {
                            use super::*;

                            #[test]
                            fn then_does_not_modify_front_capacity() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.shrink_back(front + back).expect_err("less capacity");

                                            assert_eq!(actual.front_capacity, front);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_modify_back_capacity() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.shrink_back(front + back).expect_err("less capacity");

                                            assert_eq!(actual.back_capacity, back);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_modify_initialized_elements() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.shrink_back(front + back).expect_err("less capacity");

                                            assert!(actual.eq(expected));
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_reallocate_memory() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            let allocation = actual.buffer;

                                            _ = actual.shrink_back(front + back).expect_err("less capacity");

                                            assert_eq!(actual.buffer, allocation);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_front_many_elements_can_be_prepended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.shrink_back(front + back).expect_err("less capacity");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..front {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.prepend(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_back_many_elements_can_be_appended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.shrink_back(front + back).expect_err("less capacity");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..back {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.append(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_both_front_many_elements_can_be_prepended_and_back_many_elements_can_be_appended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.shrink_back(front + back).expect_err("less capacity");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..front {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.prepend(usize::MAX).expect("uses capacity");
                                            }

                                            for _ in 0..back {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.append(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }
                        }
                    }

                    mod when_sum_is_more_than_requested {
                        use super::*;

                        mod when_empty {
                            use super::*;

                            #[test]
                            fn then_decreases_capacity_to_exactly_requested() {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        for additional in 1..usize::min(front, back) {
                                            let mut actual = Dynamic::<usize>::default();

                                            _ = actual.reserve_back(front + back).expect("successful allocation");

                                            _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                            debug_assert_eq!(actual.initialized, 0);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.shrink_back(front + back - additional).expect("successful reallocation");

                                            assert_eq!(actual.capacity(), front + back - additional);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_initialize_elements() {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        for additional in 1..usize::min(front, back) {
                                            let mut actual = Dynamic::<usize>::default();

                                            _ = actual.reserve_back(front + back).expect("successful allocation");

                                            _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                            debug_assert_eq!(actual.initialized, 0);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.shrink_back(front + back - additional).expect("successful reallocation");

                                            assert_eq!(actual.initialized, 0);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_requested_many_elements_can_be_appended_without_reallocating_memory() {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        for additional in 1..usize::min(front, back) {
                                            let mut actual = Dynamic::<usize>::default();

                                            _ = actual.reserve_back(front + back).expect("successful allocation");

                                            _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                            debug_assert_eq!(actual.initialized, 0);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.shrink_back(front + back - additional).expect("successful reallocation");

                                            let allocation = actual.buffer;

                                            for element in 0..(front + back - additional) {
                                                _ = actual.append(element).expect("uses capacity");
                                            }

                                            assert_eq!(actual.buffer, allocation);
                                        }
                                    }
                                }
                            }
                        }

                        mod when_not_empty {
                            use super::*;

                            #[test]
                            fn then_does_not_modify_front_capacity() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            for additional in 1..usize::min(front, back) {
                                                let mut actual: Dynamic<_> = (0..elements).collect();

                                                _ = actual.reserve_front(front).expect("successful allocation");
                                                _ = actual.reserve_back(back).expect("successful allocation");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front);
                                                debug_assert_eq!(actual.back_capacity, back);

                                                _ = actual.shrink_back(front + back - additional).expect_err("less capacity");

                                                assert_eq!(actual.front_capacity, front);
                                            }
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_modify_back_capacity() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            for additional in 1..usize::min(front, back) {
                                                let mut actual: Dynamic<_> = (0..elements).collect();

                                                _ = actual.reserve_front(front).expect("successful allocation");
                                                _ = actual.reserve_back(back).expect("successful allocation");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front);
                                                debug_assert_eq!(actual.back_capacity, back);

                                                _ = actual.shrink_back(front + back - additional).expect_err("less capacity");

                                                assert_eq!(actual.back_capacity, back);
                                            }
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_modify_initialized_elements() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            for additional in 1..usize::min(front, back) {
                                                let expected = 0..elements;

                                                let mut actual: Dynamic<_> = expected.clone().collect();

                                                _ = actual.reserve_front(front).expect("successful allocation");
                                                _ = actual.reserve_back(back).expect("successful allocation");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front);
                                                debug_assert_eq!(actual.back_capacity, back);

                                                _ = actual.shrink_back(front + back - additional).expect_err("less capacity");

                                                assert!(actual.eq(expected));
                                            }
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_reallocate_memory() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            for additional in 1..usize::min(front, back) {
                                                let mut actual: Dynamic<_> = (0..elements).collect();

                                                _ = actual.reserve_front(front).expect("successful allocation");
                                                _ = actual.reserve_back(back).expect("successful allocation");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front);
                                                debug_assert_eq!(actual.back_capacity, back);

                                                let allocation = actual.buffer;

                                                _ = actual.shrink_back(front + back - additional).expect_err("less capacity");

                                                assert_eq!(actual.buffer, allocation);
                                            }
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_front_many_elements_can_be_prepended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            for additional in 1..usize::min(front, back) {
                                                let expected = 0..elements;

                                                let mut actual: Dynamic<_> = expected.clone().collect();

                                                _ = actual.reserve_front(front).expect("successful allocation");
                                                _ = actual.reserve_back(back).expect("successful allocation");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front);
                                                debug_assert_eq!(actual.back_capacity, back);

                                                _ = actual.shrink_back(front + back - additional).expect_err("less capacity");

                                                let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                                for _ in 0..front {
                                                    // NOTE: this is distinct from the expected values.
                                                    _ = actual.prepend(usize::MAX).expect("uses capacity");
                                                }

                                                assert!(pointers.iter().copied().eq(expected));
                                            }
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_back_many_elements_can_be_appended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            for additional in 1..usize::min(front, back) {
                                                let expected = 0..elements;

                                                let mut actual: Dynamic<_> = expected.clone().collect();

                                                _ = actual.reserve_front(front).expect("successful allocation");
                                                _ = actual.reserve_back(back).expect("successful allocation");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front);
                                                debug_assert_eq!(actual.back_capacity, back);

                                                _ = actual.shrink_back(front + back - additional).expect_err("less capacity");

                                                let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                                for _ in 0..back {
                                                    // NOTE: this is distinct from the expected values.
                                                    _ = actual.append(usize::MAX).expect("uses capacity");
                                                }

                                                assert!(pointers.iter().copied().eq(expected));
                                            }
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_both_front_many_elements_can_be_prepended_and_back_many_elements_can_be_appended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            for additional in 1..usize::min(front, back) {
                                                let expected = 0..elements;

                                                let mut actual: Dynamic<_> = expected.clone().collect();

                                                _ = actual.reserve_front(front).expect("successful allocation");
                                                _ = actual.reserve_back(back).expect("successful allocation");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front);
                                                debug_assert_eq!(actual.back_capacity, back);

                                                _ = actual.shrink_back(front + back - additional).expect_err("less capacity");

                                                let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                                for _ in 0..front {
                                                    // NOTE: this is distinct from the expected values.
                                                    _ = actual.prepend(usize::MAX).expect("uses capacity");
                                                }

                                                for _ in 0..back {
                                                    // NOTE: this is distinct from the expected values.
                                                    _ = actual.append(usize::MAX).expect("uses capacity");
                                                }

                                                assert!(pointers.iter().copied().eq(expected));
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                mod when_front_is_exactly_requested {
                    use super::*;

                    mod when_back_is_less_than_requested {
                        use super::*;

                        mod when_empty {
                            use super::*;

                            #[test]
                            fn then_decreases_capacity_to_exactly_requested() {
                                for front in 1..32 {
                                    for back in 1..front {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(front + back).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.shrink_back(front).expect("successful reallocation");

                                        assert_eq!(actual.capacity(), front);
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_initialize_elements() {
                                for front in 1..32 {
                                    for back in 1..front {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(front + back).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.shrink_back(front).expect("successful reallocation");

                                        assert_eq!(actual.initialized, 0);
                                    }
                                }
                            }

                            #[test]
                            fn then_requested_many_elements_can_be_appended_without_reallocating_memory() {
                                for front in 1..32 {
                                    for back in 1..front {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(front + back).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.shrink_back(front).expect("successful reallocation");

                                        let allocation = actual.buffer;

                                        for element in 0..front {
                                            _ = actual.append(element).expect("uses capacity");
                                        }

                                        assert_eq!(actual.buffer, allocation);
                                    }
                                }
                            }
                        }

                        mod when_not_empty {
                            use super::*;

                            #[test]
                            fn then_does_not_modify_front_capacity() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..front {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.shrink_back(front).expect_err("less capacity");

                                            assert_eq!(actual.front_capacity, front);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_modify_back_capacity() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..front {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.shrink_back(front).expect_err("less capacity");

                                            assert_eq!(actual.back_capacity, back);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_modify_initialized_elements() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..front {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.shrink_back(front).expect_err("less capacity");

                                            assert!(actual.eq(expected));
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_reallocate_memory() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..front {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            let allocation = actual.buffer;

                                            _ = actual.shrink_back(front).expect_err("less capacity");

                                            assert_eq!(actual.buffer, allocation);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_front_many_elements_can_be_prepended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..front {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.shrink_back(front).expect_err("less capacity");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..front {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.prepend(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_back_many_elements_can_be_appended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..front {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.shrink_back(front).expect_err("less capacity");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..back {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.append(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_both_front_many_elements_can_be_prepended_and_back_many_elements_can_be_appended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..front {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.shrink_back(front).expect_err("less capacity");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..front {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.prepend(usize::MAX).expect("uses capacity");
                                            }

                                            for _ in 0..back {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.append(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }
                        }
                    }

                    mod when_back_is_more_than_requested {
                        use super::*;

                        mod when_empty {
                            use super::*;

                            #[test]
                            fn then_decreases_capacity_to_exactly_requested() {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(capacity + capacity + additional).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(capacity).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, capacity);
                                        debug_assert_eq!(actual.back_capacity, capacity + additional);

                                        _ = actual.shrink_back(capacity).expect("successful reallocation");

                                        assert_eq!(actual.capacity(), capacity);
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_initialize_elements() {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(capacity + capacity + additional).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(capacity).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, capacity);
                                        debug_assert_eq!(actual.back_capacity, capacity + additional);

                                        _ = actual.shrink_back(capacity).expect("successful reallocation");

                                        assert_eq!(actual.initialized, 0);
                                    }
                                }
                            }

                            #[test]
                            fn then_requested_many_elements_can_be_appended_without_reallocating_memory() {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(capacity + capacity + additional).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(capacity).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, capacity);
                                        debug_assert_eq!(actual.back_capacity, capacity + additional);

                                        _ = actual.shrink_back(capacity).expect("successful reallocation");

                                        let allocation = actual.buffer;

                                        for element in 0..capacity {
                                            _ = actual.append(element).expect("uses capacity");
                                        }

                                        assert_eq!(actual.buffer, allocation);
                                    }
                                }
                            }
                        }

                        mod when_not_empty {
                            use super::*;

                            #[test]
                            fn then_does_not_modify_front_capacity() {
                                for elements in 1..32 {
                                    for capacity in 1..32 {
                                        for additional in 1..32 {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(capacity).expect("successful allocation");
                                            _ = actual.reserve_back(capacity + additional).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, capacity);
                                            debug_assert_eq!(actual.back_capacity, capacity + additional);

                                            _ = actual.shrink_back(capacity).expect("successful reallocation");

                                            assert_eq!(actual.front_capacity, capacity);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_decreases_back_capacity_to_exactly_requested() {
                                for elements in 1..32 {
                                    for capacity in 1..32 {
                                        for additional in 1..32 {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(capacity).expect("successful allocation");
                                            _ = actual.reserve_back(capacity + additional).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, capacity);
                                            debug_assert_eq!(actual.back_capacity, capacity + additional);

                                            _ = actual.shrink_back(capacity).expect("successful reallocation");

                                            assert_eq!(actual.back_capacity, capacity);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_modify_initialized_elements() {
                                for elements in 1..32 {
                                    for capacity in 1..32 {
                                        for additional in 1..32 {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(capacity).expect("successful allocation");
                                            _ = actual.reserve_back(capacity + additional).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, capacity);
                                            debug_assert_eq!(actual.back_capacity, capacity + additional);

                                            _ = actual.shrink_back(capacity).expect("successful reallocation");

                                            assert!(actual.eq(expected));
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_front_many_elements_can_be_prepended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for capacity in 1..32 {
                                        for additional in 1..32 {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(capacity).expect("successful allocation");
                                            _ = actual.reserve_back(capacity + additional).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, capacity);
                                            debug_assert_eq!(actual.back_capacity, capacity + additional);

                                            _ = actual.shrink_back(capacity).expect("successful reallocation");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..capacity {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.prepend(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_back_many_elements_can_be_appended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for capacity in 1..32 {
                                        for additional in 1..32 {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(capacity).expect("successful allocation");
                                            _ = actual.reserve_back(capacity + additional).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, capacity);
                                            debug_assert_eq!(actual.back_capacity, capacity + additional);

                                            _ = actual.shrink_back(capacity).expect("successful reallocation");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..capacity {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.append(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_both_front_many_elements_can_be_prepended_and_back_many_elements_can_be_appended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for capacity in 1..32 {
                                        for additional in 1..32 {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(capacity).expect("successful allocation");
                                            _ = actual.reserve_back(capacity + additional).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, capacity);
                                            debug_assert_eq!(actual.back_capacity, capacity + additional);

                                            _ = actual.shrink_back(capacity).expect("successful reallocation");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..capacity {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.prepend(usize::MAX).expect("uses capacity");
                                            }

                                            for _ in 0..capacity {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.append(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                mod when_back_is_exactly_requested {
                    use super::*;

                    mod when_front_is_less_than_requested {
                        use super::*;

                        mod when_empty {
                            use super::*;

                            #[test]
                            fn then_decreases_capacity_to_exactly_requested() {
                                for back in 1..32 {
                                    for front in 1..back {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(front + back).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.shrink_back(back).expect("successful reallocation");

                                        assert_eq!(actual.capacity(), back);
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_initialize_elements() {
                                for back in 1..32 {
                                    for front in 1..back {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(front + back).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.shrink_back(back).expect("successful reallocation");

                                        assert_eq!(actual.initialized, 0);
                                    }
                                }
                            }

                            #[test]
                            fn then_requested_many_elements_can_be_appended_without_reallocating_memory() {
                                for back in 1..32 {
                                    for front in 1..back {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(front + back).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.shrink_back(back).expect("successful reallocation");

                                        let allocation = actual.buffer;

                                        for element in 0..back {
                                            _ = actual.append(element).expect("uses capacity");
                                        }

                                        assert_eq!(actual.buffer, allocation);
                                    }
                                }
                            }
                        }

                        mod when_not_empty {
                            use super::*;

                            #[test]
                            fn then_does_not_modify_front_capacity() {
                                for elements in 1..32 {
                                    for back in 1..32 {
                                        for front in 1..back {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.shrink_back(back).expect("successful reallocation");

                                            assert_eq!(actual.front_capacity, front);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_modify_back_capacity() {
                                for elements in 1..32 {
                                    for back in 1..32 {
                                        for front in 1..back {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.shrink_back(back).expect("successful reallocation");

                                            assert_eq!(actual.back_capacity, back);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_modify_initialized_elements() {
                                for elements in 1..32 {
                                    for back in 1..32 {
                                        for front in 1..back {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.shrink_back(back).expect("successful reallocation");

                                            assert!(actual.eq(expected));
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_reallocate_memory() {
                                for elements in 1..32 {
                                    for back in 1..32 {
                                        for front in 1..back {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            let allocation = actual.buffer;

                                            _ = actual.shrink_back(back).expect("successful reallocation");

                                            assert_eq!(actual.buffer, allocation);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_front_many_elements_can_be_prepended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for back in 1..32 {
                                        for front in 1..back {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.shrink_back(back).expect("successful reallocation");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..front {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.prepend(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_back_many_elements_can_be_appended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for back in 1..32 {
                                        for front in 1..back {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.shrink_back(back).expect("successful reallocation");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..back {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.append(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_both_front_many_elements_can_be_prepended_and_back_many_elements_can_be_appended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for back in 1..32 {
                                        for front in 1..back {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.shrink_back(back).expect("successful reallocation");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..front {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.prepend(usize::MAX).expect("uses capacity");
                                            }

                                            for _ in 0..back {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.append(usize::MAX).expect("uses capacity");
                                            }


                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }
                        }
                    }

                    mod when_front_is_more_than_requested {
                        use super::*;

                        mod when_empty {
                            use super::*;

                            #[test]
                            fn then_decreases_capacity_to_exactly_requested() {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(capacity + additional + capacity).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(capacity + additional).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, capacity + additional);
                                        debug_assert_eq!(actual.back_capacity, capacity);

                                        _ = actual.shrink_back(capacity).expect("successful reallocation");

                                        assert_eq!(actual.capacity(), capacity);
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_initialize_elements() {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(capacity + additional + capacity).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(capacity + additional).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, capacity + additional);
                                        debug_assert_eq!(actual.back_capacity, capacity);

                                        _ = actual.shrink_back(capacity).expect("successful reallocation");

                                        assert_eq!(actual.initialized, 0);
                                    }
                                }
                            }

                            #[test]
                            fn then_requested_many_elements_can_be_appended_without_reallocating_memory() {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(capacity + additional + capacity).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(capacity + additional).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, capacity + additional);
                                        debug_assert_eq!(actual.back_capacity, capacity);

                                        _ = actual.shrink_back(capacity).expect("successful reallocation");

                                        let allocation = actual.buffer;

                                        for element in 0..capacity {
                                            _ = actual.prepend(element).expect("uses capacity");
                                        }

                                        assert_eq!(actual.buffer, allocation);
                                    }
                                }
                            }
                        }

                        mod when_not_empty {
                            use super::*;

                            #[test]
                            fn then_does_not_modify_front_capacity() {
                                for elements in 1..32 {
                                    for capacity in 1..32 {
                                        for additional in 1..32 {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(capacity + additional).expect("successful allocation");
                                            _ = actual.reserve_back(capacity).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, capacity + additional);
                                            debug_assert_eq!(actual.back_capacity, capacity);

                                            _ = actual.shrink_back(capacity).expect("successful reallocation");

                                            assert_eq!(actual.front_capacity, capacity + additional);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_modify_back_capacity() {
                                for elements in 1..32 {
                                    for capacity in 1..32 {
                                        for additional in 1..32 {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(capacity + additional).expect("successful allocation");
                                            _ = actual.reserve_back(capacity).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, capacity + additional);
                                            debug_assert_eq!(actual.back_capacity, capacity);

                                            _ = actual.shrink_back(capacity).expect("successful reallocation");

                                            assert_eq!(actual.back_capacity, capacity);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_modify_initialized_elements() {
                                for elements in 1..32 {
                                    for capacity in 1..32 {
                                        for additional in 1..32 {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(capacity + additional).expect("successful allocation");
                                            _ = actual.reserve_back(capacity).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, capacity + additional);
                                            debug_assert_eq!(actual.back_capacity, capacity);

                                            _ = actual.shrink_back(capacity).expect("successful reallocation");

                                            assert!(actual.eq(expected));
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_reallocate_memory() {
                                for elements in 1..32 {
                                    for capacity in 1..32 {
                                        for additional in 1..32 {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(capacity + additional).expect("successful allocation");
                                            _ = actual.reserve_back(capacity).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, capacity + additional);
                                            debug_assert_eq!(actual.back_capacity, capacity);

                                            let allocation = actual.buffer;

                                            _ = actual.shrink_back(capacity).expect("successful reallocation");

                                            assert_eq!(actual.buffer, allocation);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_front_many_elements_can_be_prepended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for capacity in 1..32 {
                                        for additional in 1..32 {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(capacity + additional).expect("successful allocation");
                                            _ = actual.reserve_back(capacity).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, capacity + additional);
                                            debug_assert_eq!(actual.back_capacity, capacity);

                                            _ = actual.shrink_back(capacity).expect("successful reallocation");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..(capacity + additional) {
                                                // NOTE: this is distinct from the exoected values.
                                                _ = actual.prepend(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_back_many_elements_can_be_appended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for capacity in 1..32 {
                                        for additional in 1..32 {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(capacity + additional).expect("successful allocation");
                                            _ = actual.reserve_back(capacity).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, capacity + additional);
                                            debug_assert_eq!(actual.back_capacity, capacity);

                                            _ = actual.shrink_back(capacity).expect("successful reallocation");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..capacity {
                                                // NOTE: this is distinct from the exoected values.
                                                _ = actual.append(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_both_front_many_elements_can_be_prepended_and_back_many_elements_can_be_appended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for capacity in 1..32 {
                                        for additional in 1..32 {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(capacity + additional).expect("successful allocation");
                                            _ = actual.reserve_back(capacity).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, capacity + additional);
                                            debug_assert_eq!(actual.back_capacity, capacity);

                                            _ = actual.shrink_back(capacity).expect("successful reallocation");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..(capacity + additional) {
                                                // NOTE: this is distinct from the exoected values.
                                                _ = actual.prepend(usize::MAX).expect("uses capacity");
                                            }

                                            for _ in 0..capacity {
                                                // NOTE: this is distinct from the exoected values.
                                                _ = actual.append(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                mod when_both_exactly_requested {
                    use super::*;

                    mod when_empty {
                        use super::*;

                        #[test]
                        fn then_decreases_capacity_to_exactly_requested() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_back(capacity + capacity).expect("successful allocation");

                                _ = actual.shift(isize::try_from(capacity).expect("too small to wrap")).expect("enough back capacity to shift into");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, capacity);
                                debug_assert_eq!(actual.back_capacity, capacity);

                                _ = actual.shrink_back(capacity).expect("successful reallocation");

                                assert_eq!(actual.capacity(), capacity);
                            }
                        }

                        #[test]
                        fn then_does_not_initialize_elements() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_back(capacity + capacity).expect("successful allocation");

                                _ = actual.shift(isize::try_from(capacity).expect("too small to wrap")).expect("enough back capacity to shift into");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, capacity);
                                debug_assert_eq!(actual.back_capacity, capacity);

                                _ = actual.shrink_back(capacity).expect("successful reallocation");

                                assert_eq!(actual.initialized, 0);
                            }
                        }

                        #[test]
                        fn then_requested_many_elements_can_be_appended_without_reallocating_memory() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_back(capacity + capacity).expect("successful allocation");

                                _ = actual.shift(isize::try_from(capacity).expect("too small to wrap")).expect("enough back capacity to shift into");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, capacity);
                                debug_assert_eq!(actual.back_capacity, capacity);

                                _ = actual.shrink_back(capacity).expect("successful reallocation");

                                let allocation = actual.buffer;

                                for element in 0..capacity {
                                    _ = actual.append(element).expect("uses capacity");
                                }

                                assert_eq!(actual.buffer, allocation);
                            }
                        }
                    }

                    mod when_not_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_front_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let mut actual: Dynamic<_> = (0..elements).collect();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");
                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    _ = actual.shrink_back(capacity).expect("already exact capacity");

                                    assert_eq!(actual.front_capacity, capacity);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_back_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let mut actual: Dynamic<_> = (0..elements).collect();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");
                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    _ = actual.shrink_back(capacity).expect("already exact capacity");

                                    assert_eq!(actual.back_capacity, capacity);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_initialized_elements() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let expected = 0..elements;

                                    let mut actual: Dynamic<_> = expected.clone().collect();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");
                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    _ = actual.shrink_back(capacity).expect("already exact capacity");

                                    assert!(actual.eq(expected));
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_reallocate_memory() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let mut actual: Dynamic<_> = (0..elements).collect();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");
                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    let allocation = actual.buffer;

                                    _ = actual.shrink_back(capacity).expect("already exact capacity");
                                    assert_eq!(actual.buffer, allocation);
                                }
                            }
                        }

                        #[test]
                        fn then_front_many_elements_can_be_prepended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let expected = 0..elements;

                                    let mut actual: Dynamic<_> = expected.clone().collect();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");
                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    _ = actual.shrink_back(capacity).expect("already exact capacity");

                                    let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                    for _ in 0..capacity {
                                        // NOTE: this is distinct from the expected values.
                                        _ = actual.prepend(usize::MAX).expect("uses capacity");
                                    }

                                    assert!(pointers.iter().copied().eq(expected));
                                }
                            }
                        }

                        #[test]
                        fn then_back_many_elements_can_be_appended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let expected = 0..elements;

                                    let mut actual: Dynamic<_> = expected.clone().collect();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");
                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    _ = actual.shrink_back(capacity).expect("already exact capacity");

                                    let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                    for _ in 0..capacity {
                                        // NOTE: this is distinct from the expected values.
                                        _ = actual.append(usize::MAX).expect("uses capacity");
                                    }

                                    assert!(pointers.iter().copied().eq(expected));
                                }
                            }
                        }

                        #[test]
                        fn then_both_front_many_elements_can_be_prepended_and_back_many_elements_can_be_appended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let expected = 0..elements;

                                    let mut actual: Dynamic<_> = expected.clone().collect();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");
                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    _ = actual.shrink_back(capacity).expect("already exact capacity");

                                    let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                    for _ in 0..capacity {
                                        // NOTE: this is distinct from the expected values.
                                        _ = actual.prepend(usize::MAX).expect("uses capacity");
                                    }

                                    for _ in 0..capacity {
                                        // NOTE: this is distinct from the expected values.
                                        _ = actual.append(usize::MAX).expect("uses capacity");
                                    }

                                    assert!(pointers.iter().copied().eq(expected));
                                }
                            }
                        }
                    }
                }

                mod when_front_is_more_than_requested_and_back_is_less_than_requested {
                    use super::*;

                    mod when_empty {
                        use super::*;

                        #[test]
                        fn then_decreases_capacity_to_exactly_requested() {
                            for capacity in 1..32 {
                                for more in capacity..(capacity + 32) {
                                    for less in 1..capacity {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(more + less).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(more).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, more);
                                        debug_assert_eq!(actual.back_capacity, less);

                                        _ = actual.shrink_back(capacity).expect("successful reallocation");

                                        assert_eq!(actual.capacity(), capacity);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_initialize_elements() {
                            for capacity in 1..32 {
                                for more in capacity..(capacity + 32) {
                                    for less in 1..capacity {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(more + less).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(more).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, more);
                                        debug_assert_eq!(actual.back_capacity, less);

                                        _ = actual.shrink_back(capacity).expect("successful reallocation");

                                        assert_eq!(actual.initialized, 0);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_requested_many_elements_can_be_appended_without_reallocating_memory() {
                            for capacity in 1..32 {
                                for more in capacity..(capacity + 32) {
                                    for less in 1..capacity {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(more + less).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(more).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, more);
                                        debug_assert_eq!(actual.back_capacity, less);

                                        _ = actual.shrink_back(capacity).expect("successful reallocation");

                                        let allocation = actual.buffer;

                                        for element in 0..capacity {
                                            _ = actual.append(element).expect("uses capacity");
                                        }

                                        assert_eq!(actual.buffer, allocation);
                                    }
                                }
                            }
                        }
                    }

                    mod when_not_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_front_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for more in capacity..(capacity + 32) {
                                        for less in 1..capacity {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(more).expect("successful allocation");
                                            _ = actual.reserve_back(less).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, more);
                                            debug_assert_eq!(actual.back_capacity, less);

                                            _ = actual.shrink_back(capacity).expect_err("less capacity");

                                            assert_eq!(actual.front_capacity, more);
                                        }
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_back_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for more in capacity..(capacity + 32) {
                                        for less in 1..capacity {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(more).expect("successful allocation");
                                            _ = actual.reserve_back(less).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, more);
                                            debug_assert_eq!(actual.back_capacity, less);

                                            _ = actual.shrink_back(capacity).expect_err("less capacity");

                                            assert_eq!(actual.back_capacity, less);
                                        }
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_initialized_elements() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for more in capacity..(capacity + 32) {
                                        for less in 1..capacity {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(more).expect("successful allocation");
                                            _ = actual.reserve_back(less).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, more);
                                            debug_assert_eq!(actual.back_capacity, less);

                                            _ = actual.shrink_back(capacity).expect_err("less capacity");

                                            assert!(actual.eq(expected));
                                        }
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_reallocate_memory() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for more in capacity..(capacity + 32) {
                                        for less in 1..capacity {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(more).expect("successful allocation");
                                            _ = actual.reserve_back(less).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, more);
                                            debug_assert_eq!(actual.back_capacity, less);

                                            let allocation = actual.buffer;

                                            _ = actual.shrink_back(capacity).expect_err("less capacity");

                                            assert_eq!(actual.buffer, allocation);
                                        }
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_front_many_elements_can_be_prepended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for more in capacity..(capacity + 32) {
                                        for less in 1..capacity {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(more).expect("successful allocation");
                                            _ = actual.reserve_back(less).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, more);
                                            debug_assert_eq!(actual.back_capacity, less);

                                            _ = actual.shrink_back(capacity).expect_err("less capacity");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..more {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.prepend(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_back_many_elements_can_be_appended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for more in capacity..(capacity + 32) {
                                        for less in 1..capacity {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(more).expect("successful allocation");
                                            _ = actual.reserve_back(less).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, more);
                                            debug_assert_eq!(actual.back_capacity, less);

                                            _ = actual.shrink_back(capacity).expect_err("less capacity");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..less {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.append(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_both_front_many_elements_can_be_prepended_and_back_many_elements_can_be_appended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for more in capacity..(capacity + 32) {
                                        for less in 1..capacity {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(more).expect("successful allocation");
                                            _ = actual.reserve_back(less).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, more);
                                            debug_assert_eq!(actual.back_capacity, less);

                                            _ = actual.shrink_back(capacity).expect_err("less capacity");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..more {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.prepend(usize::MAX).expect("uses capacity");
                                            }

                                            for _ in 0..less {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.append(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                mod when_front_is_less_than_requested_and_back_is_more_than_requested {
                    use super::*;

                    mod when_empty {
                        use super::*;

                        #[test]
                        fn then_decreases_capacity_to_exactly_requested() {
                            for capacity in 1..32 {
                                for more in capacity..(capacity + 32) {
                                    for less in 1..capacity {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(less + more).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(less).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, less);
                                        debug_assert_eq!(actual.back_capacity, more);

                                        _ = actual.shrink_back(capacity).expect("successful reallocation");

                                        assert_eq!(actual.capacity(), capacity);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_initialize_elements() {
                            for capacity in 1..32 {
                                for more in capacity..(capacity + 32) {
                                    for less in 1..capacity {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(less + more).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(less).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, less);
                                        debug_assert_eq!(actual.back_capacity, more);

                                        _ = actual.shrink_back(capacity).expect("successful reallocation");

                                        assert_eq!(actual.initialized, 0);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_requested_many_elements_can_be_appended_without_reallocating_memory() {
                            for capacity in 1..32 {
                                for more in capacity..(capacity + 32) {
                                    for less in 1..capacity {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(less + more).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(less).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, less);
                                        debug_assert_eq!(actual.back_capacity, more);

                                        _ = actual.shrink_back(capacity).expect("successful reallocation");

                                        let allocation = actual.buffer;

                                        for element in 0..capacity {
                                            _ = actual.append(element).expect("uses capacity");
                                        }

                                        assert_eq!(actual.buffer, allocation);
                                    }
                                }
                            }
                        }
                    }

                    mod when_not_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_front_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for more in capacity..(capacity + 32) {
                                        for less in 1..capacity {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(less).expect("successful allocation");
                                            _ = actual.reserve_back(more).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, less);
                                            debug_assert_eq!(actual.back_capacity, more);

                                            _ = actual.shrink_back(capacity).expect("successful reallocation");

                                            assert_eq!(actual.front_capacity, less);
                                        }
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_decreases_back_capacity_to_exactly_requested() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for more in capacity..(capacity + 32) {
                                        for less in 1..capacity {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(less).expect("successful allocation");
                                            _ = actual.reserve_back(more).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, less);
                                            debug_assert_eq!(actual.back_capacity, more);

                                            _ = actual.shrink_back(capacity).expect("successful reallocation");

                                            assert_eq!(actual.back_capacity, capacity);
                                        }
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_initialized_elements() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for more in capacity..(capacity + 32) {
                                        for less in 1..capacity {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(less).expect("successful allocation");
                                            _ = actual.reserve_back(more).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, less);
                                            debug_assert_eq!(actual.back_capacity, more);

                                            _ = actual.shrink_back(capacity).expect("successful reallocation");

                                            assert!(actual.eq(expected));
                                        }
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_front_many_elements_can_be_prepended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for more in capacity..(capacity + 32) {
                                        for less in 1..capacity {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(less).expect("successful allocation");
                                            _ = actual.reserve_back(more).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, less);
                                            debug_assert_eq!(actual.back_capacity, more);

                                            _ = actual.shrink_back(capacity).expect("successful reallocation");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..less {
                                                // NOTE: this is distinct form the expected values.
                                                _ = actual.prepend(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_back_many_elements_can_be_appended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for more in capacity..(capacity + 32) {
                                        for less in 1..capacity {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(less).expect("successful allocation");
                                            _ = actual.reserve_back(more).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, less);
                                            debug_assert_eq!(actual.back_capacity, more);

                                            _ = actual.shrink_back(capacity).expect("successful reallocation");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..capacity {
                                                // NOTE: this is distinct form the expected values.
                                                _ = actual.append(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_both_front_many_elements_can_be_prepended_and_back_many_elements_can_be_appended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for more in capacity..(capacity + 32) {
                                        for less in 1..capacity {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(less).expect("successful allocation");
                                            _ = actual.reserve_back(more).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, less);
                                            debug_assert_eq!(actual.back_capacity, more);

                                            _ = actual.shrink_back(capacity).expect("successful reallocation");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..less {
                                                // NOTE: this is distinct form the expected values.
                                                _ = actual.prepend(usize::MAX).expect("uses capacity");
                                            }

                                            for _ in 0..capacity {
                                                // NOTE: this is distinct form the expected values.
                                                _ = actual.append(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                mod when_both_more_than_requested {
                    use super::*;

                    mod when_empty {
                        use super::*;

                        #[test]
                        fn then_decreases_capacity_to_exactly_requested() {
                            for capacity in 1..32 {
                                for additional_front in 1..32 {
                                    for additional_back in 1..32 {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(capacity + additional_front + capacity + additional_back).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(capacity + additional_front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, capacity + additional_front);
                                        debug_assert_eq!(actual.back_capacity, capacity + additional_back);

                                        _ = actual.shrink_back(capacity).expect("successful reallocation");

                                        assert_eq!(actual.capacity(), capacity);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_initialize_elements() {
                            for capacity in 1..32 {
                                for additional_front in 1..32 {
                                    for additional_back in 1..32 {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(capacity + additional_front + capacity + additional_back).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(capacity + additional_front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, capacity + additional_front);
                                        debug_assert_eq!(actual.back_capacity, capacity + additional_back);

                                        _ = actual.shrink_back(capacity).expect("successful reallocation");

                                        assert_eq!(actual.initialized, 0);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_requested_many_elements_can_be_appended_without_reallocating_memory() {
                            for capacity in 1..32 {
                                for additional_front in 1..32 {
                                    for additional_back in 1..32 {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(capacity + additional_front + capacity + additional_back).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(capacity + additional_front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, capacity + additional_front);
                                        debug_assert_eq!(actual.back_capacity, capacity + additional_back);

                                        _ = actual.shrink_back(capacity).expect("successful reallocation");

                                        let allocation = actual.buffer;

                                        for element in 0..capacity {
                                            _ = actual.append(element).expect("uses capacity");
                                        }

                                        assert_eq!(actual.buffer, allocation);
                                    }
                                }
                            }
                        }
                    }

                    mod when_not_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_front_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional_front in 1..32 {
                                        for additional_back in 1..32 {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(capacity + additional_front).expect("successful allocation");
                                            _ = actual.reserve_back(capacity + additional_back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, capacity + additional_front);
                                            debug_assert_eq!(actual.back_capacity, capacity + additional_back);

                                            _ = actual.shrink_back(capacity).expect("successful reallocation");

                                            assert_eq!(actual.front_capacity, capacity + additional_front);
                                        }
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_decreases_back_capacity_to_exactly_requested() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional_front in 1..32 {
                                        for additional_back in 1..32 {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(capacity + additional_front).expect("successful allocation");
                                            _ = actual.reserve_back(capacity + additional_back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, capacity + additional_front);
                                            debug_assert_eq!(actual.back_capacity, capacity + additional_back);

                                            _ = actual.shrink_back(capacity).expect("successful reallocation");

                                            assert_eq!(actual.back_capacity, capacity);
                                        }
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_initialized_elements() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional_front in 1..32 {
                                        for additional_back in 1..32 {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(capacity + additional_front).expect("successful allocation");
                                            _ = actual.reserve_back(capacity + additional_back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, capacity + additional_front);
                                            debug_assert_eq!(actual.back_capacity, capacity + additional_back);

                                            _ = actual.shrink_back(capacity).expect("successful reallocation");

                                            assert!(actual.eq(expected));
                                        }
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_front_many_elements_can_be_prepended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional_front in 1..32 {
                                        for additional_back in 1..32 {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(capacity + additional_front).expect("successful allocation");
                                            _ = actual.reserve_back(capacity + additional_back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, capacity + additional_front);
                                            debug_assert_eq!(actual.back_capacity, capacity + additional_back);

                                            _ = actual.shrink_back(capacity).expect("successful reallocation");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..(capacity + additional_front) {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.prepend(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_back_many_elements_can_be_appended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional_front in 1..32 {
                                        for additional_back in 1..32 {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(capacity + additional_front).expect("successful allocation");
                                            _ = actual.reserve_back(capacity + additional_back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, capacity + additional_front);
                                            debug_assert_eq!(actual.back_capacity, capacity + additional_back);

                                            _ = actual.shrink_back(capacity).expect("successful reallocation");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..capacity {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.append(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_both_front_many_elements_can_be_prepended_and_back_many_elements_can_be_appended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional_front in 1..32 {
                                        for additional_back in 1..32 {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(capacity + additional_front).expect("successful allocation");
                                            _ = actual.reserve_back(capacity + additional_back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, capacity + additional_front);
                                            debug_assert_eq!(actual.back_capacity, capacity + additional_back);

                                            _ = actual.shrink_back(capacity).expect("successful reallocation");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..(capacity + additional_front) {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.prepend(usize::MAX).expect("uses capacity");
                                            }

                                            for _ in 0..capacity {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.append(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        mod shift {
            use super::*;

            mod when_no_capacity {
                use super::*;

                mod when_zero_requested {
                    use super::*;

                    mod when_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_front_capacity() {
                            let mut actual = Dynamic::<usize>::default();

                            debug_assert_eq!(actual.initialized, 0);
                            debug_assert_eq!(actual.front_capacity, 0);
                            debug_assert_eq!(actual.back_capacity, 0);

                            _ = actual.shift(0).expect("does nothing");

                            assert_eq!(actual.front_capacity, 0);
                        }

                        #[test]
                        fn then_does_not_modify_back_capacity() {
                            let mut actual = Dynamic::<usize>::default();

                            debug_assert_eq!(actual.initialized, 0);
                            debug_assert_eq!(actual.front_capacity, 0);
                            debug_assert_eq!(actual.back_capacity, 0);

                            _ = actual.shift(0).expect("does nothing");

                            assert_eq!(actual.back_capacity, 0);
                        }

                        #[test]
                        fn then_does_not_initialize_elements() {
                            let mut actual = Dynamic::<usize>::default();

                            debug_assert_eq!(actual.initialized, 0);
                            debug_assert_eq!(actual.front_capacity, 0);
                            debug_assert_eq!(actual.back_capacity, 0);

                            _ = actual.shift(0).expect("does nothing");

                            assert_eq!(actual.initialized, 0);
                        }
                    }

                    mod when_not_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_front_capacity() {
                            for elements in 1..32 {
                                let mut actual: Dynamic<_> = (0..elements).collect();

                                debug_assert_eq!(actual.initialized, elements);
                                debug_assert_eq!(actual.front_capacity, 0);
                                debug_assert_eq!(actual.back_capacity, 0);

                                _ = actual.shift(0).expect("does nothing");

                                assert_eq!(actual.front_capacity, 0);
                            }
                        }

                        #[test]
                        fn then_does_not_modify_back_capacity() {
                            for elements in 1..32 {
                                let mut actual: Dynamic<_> = (0..elements).collect();

                                debug_assert_eq!(actual.initialized, elements);
                                debug_assert_eq!(actual.front_capacity, 0);
                                debug_assert_eq!(actual.back_capacity, 0);

                                _ = actual.shift(0).expect("does nothing");

                                assert_eq!(actual.back_capacity, 0);
                            }
                        }

                        #[test]
                        fn then_does_not_modify_initialized_elements() {
                            for elements in 1..32 {
                                let expected = 0..elements;

                                let mut actual: Dynamic<_> = expected.clone().collect();

                                debug_assert_eq!(actual.initialized, elements);
                                debug_assert_eq!(actual.front_capacity, 0);
                                debug_assert_eq!(actual.back_capacity, 0);

                                _ = actual.shift(0).expect("does nothing");

                                assert!(actual.eq(0..elements));
                            }
                        }

                        #[test]
                        fn then_does_not_reallocate_memory() {
                            for elements in 1..32 {
                                let mut actual: Dynamic<_> = (0..elements).collect();

                                debug_assert_eq!(actual.initialized, elements);
                                debug_assert_eq!(actual.front_capacity, 0);
                                debug_assert_eq!(actual.back_capacity, 0);

                                let allocation = actual.buffer;

                                _ = actual.shift(0).expect("does nothing");

                                assert_eq!(actual.buffer, allocation);
                            }
                        }
                    }
                }

                mod when_negative_requested {
                    use super::*;

                    mod when_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_front_capacity() {
                            for requested in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, 0);
                                debug_assert_eq!(actual.back_capacity, 0);

                                _ = actual.shift(-requested).expect_err("not enough front capacity");

                                assert_eq!(actual.front_capacity, 0);
                            }
                        }

                        #[test]
                        fn then_does_not_modify_back_capacity() {
                            for requested in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, 0);
                                debug_assert_eq!(actual.back_capacity, 0);

                                _ = actual.shift(-requested).expect_err("not enough front capacity");

                                assert_eq!(actual.back_capacity, 0);
                            }
                        }

                        #[test]
                        fn then_does_not_initialize_elements() {
                            for requested in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, 0);
                                debug_assert_eq!(actual.back_capacity, 0);

                                _ = actual.shift(-requested).expect_err("not enough front capacity");

                                assert_eq!(actual.initialized, 0);
                            }
                        }

                        #[test]
                        fn then_does_not_reallocate_memory() {
                            for requested in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, 0);
                                debug_assert_eq!(actual.back_capacity, 0);

                                let allocation = actual.buffer;

                                _ = actual.shift(-requested).expect_err("not enough front capacity");

                                assert_eq!(actual.buffer, allocation);
                            }
                        }
                    }

                    mod when_not_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_front_capacity() {
                            for elements in 1..32 {
                                for requested in 1..32 {
                                    let mut actual: Dynamic<_> = (0..elements).collect();

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.shift(-requested).expect_err("not enough front capacity");

                                    assert_eq!(actual.front_capacity, 0);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_back_capacity() {
                            for elements in 1..32 {
                                for requested in 1..32 {
                                    let mut actual: Dynamic<_> = (0..elements).collect();

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.shift(-requested).expect_err("not enough front capacity");

                                    assert_eq!(actual.back_capacity, 0);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_initialized_elements() {
                            for elements in 1..32 {
                                for requested in 1..32 {
                                    let expected = 0..elements;

                                    let mut actual: Dynamic<_> = expected.clone().collect();

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.shift(-requested).expect_err("not enough front capacity");

                                    assert!(actual.eq(expected));
                                }
                            }
                        }
                    }
                }

                mod when_positive_requested {
                    use super::*;

                    mod when_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_front_capacity() {
                            for requested in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, 0);
                                debug_assert_eq!(actual.back_capacity, 0);

                                _ = actual.shift(requested).expect_err("not enough back capacity");

                                assert_eq!(actual.front_capacity, 0);
                            }
                        }

                        #[test]
                        fn then_does_not_modify_back_capacity() {
                            for requested in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, 0);
                                debug_assert_eq!(actual.back_capacity, 0);

                                _ = actual.shift(requested).expect_err("not enough back capacity");

                                assert_eq!(actual.back_capacity, 0);
                            }
                        }

                        #[test]
                        fn then_does_not_initialize_elements() {
                            for requested in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, 0);
                                debug_assert_eq!(actual.back_capacity, 0);

                                _ = actual.shift(requested).expect_err("not enough back capacity");

                                assert_eq!(actual.initialized, 0);
                            }
                        }

                        #[test]
                        fn then_does_not_reallocate_memory() {
                            for requested in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, 0);
                                debug_assert_eq!(actual.back_capacity, 0);

                                let allocation = actual.buffer;

                                _ = actual.shift(requested).expect_err("not enough back capacity");

                                assert_eq!(actual.buffer, allocation);
                            }
                        }
                    }

                    mod when_not_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_front_capacity() {
                            for elements in 1..32 {
                                for requested in 1..32 {
                                    let mut actual: Dynamic<_> = (0..elements).collect();

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.shift(requested).expect_err("not enough back capacity");

                                    assert_eq!(actual.front_capacity, 0);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_back_capacity() {
                            for elements in 1..32 {
                                for requested in 1..32 {
                                    let mut actual: Dynamic<_> = (0..elements).collect();

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.shift(requested).expect_err("not enough back capacity");

                                    assert_eq!(actual.back_capacity, 0);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_initialized_elements() {
                            for elements in 1..32 {
                                for requested in 1..32 {
                                    let expected = 0..elements;

                                    let mut actual: Dynamic<_> = expected.clone().collect();

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.shift(requested).expect_err("not enough back capacity");

                                    assert!(actual.eq(expected));
                                }
                            }
                        }
                    }
                }
            }

            mod when_only_front_capacity {
                use super::*;

                mod when_zero_requested {
                    use super::*;

                    mod when_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_front_capacity() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_front(capacity).expect("successful allocation");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, capacity);
                                debug_assert_eq!(actual.back_capacity, 0);

                                _ = actual.shift(0).expect("does nothing");

                                assert_eq!(actual.front_capacity, capacity);
                            }
                        }

                        #[test]
                        fn then_does_not_modify_back_capacity() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_front(capacity).expect("successful allocation");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, capacity);
                                debug_assert_eq!(actual.back_capacity, 0);

                                _ = actual.shift(0).expect("does nothing");

                                assert_eq!(actual.back_capacity, 0);
                            }
                        }

                        #[test]
                        fn then_does_not_reallocate_memory() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_front(capacity).expect("successful allocation");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, capacity);
                                debug_assert_eq!(actual.back_capacity, 0);

                                let allocation = actual.buffer;

                                _ = actual.shift(0).expect("does nothing");

                                assert_eq!(actual.buffer, allocation);
                            }
                        }

                        #[test]
                        fn then_front_many_elements_can_be_prepended_without_reallocating_memory() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_front(capacity).expect("successful allocation");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, capacity);
                                debug_assert_eq!(actual.back_capacity, 0);

                                let allocation = actual.buffer;

                                _ = actual.shift(0).expect("does nothing");

                                for element in 0..capacity {
                                    _ = actual.prepend(element).expect("uses capacity");
                                }

                                assert_eq!(actual.buffer, allocation);
                            }
                        }
                    }

                    mod when_not_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_front_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let mut actual: Dynamic<_> = (0..elements).collect();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.shift(0).expect("does nothing");

                                    assert_eq!(actual.front_capacity, capacity);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_back_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let mut actual: Dynamic<_> = (0..elements).collect();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.shift(0).expect("does nothing");

                                    assert_eq!(actual.back_capacity, 0);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_initialized_elements() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let expected = 0..elements;

                                    let mut actual: Dynamic<_> = expected.clone().collect();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.shift(0).expect("does nothing");

                                    assert!(actual.eq(expected));
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_reallocate_memory() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let mut actual: Dynamic<_> = (0..elements).collect();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    let allocation = actual.buffer;

                                    _ = actual.shift(0).expect("does nothing");

                                    assert_eq!(actual.buffer, allocation);
                                }
                            }
                        }

                        #[test]
                        fn then_front_many_elements_can_be_prepended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let expected = 0..elements;

                                    let mut actual: Dynamic<_> = expected.clone().collect();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.shift(0).expect("does nothing");

                                    let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                    for element in 0..capacity {
                                        _ = actual.prepend(element).expect("uses capacity");
                                    }

                                    assert!(pointers.iter().copied().eq(expected));
                                }
                            }
                        }
                    }
                }

                mod when_negative_requested {
                    use super::*;

                    mod when_less_than_requested {
                        use super::*;

                        mod when_empty {
                            use super::*;

                            #[test]
                            fn then_does_not_modify_front_capacity() {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_front(capacity).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, capacity);
                                        debug_assert_eq!(actual.back_capacity, 0);

                                        _ = actual.shift(-isize::try_from(capacity + additional).expect("too small to wrap")).expect_err("not enough front capacity");

                                        assert_eq!(actual.front_capacity, capacity);
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_modify_back_capacity() {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_front(capacity).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, capacity);
                                        debug_assert_eq!(actual.back_capacity, 0);

                                        _ = actual.shift(-isize::try_from(capacity + additional).expect("too small to wrap")).expect_err("not enough front capacity");

                                        assert_eq!(actual.back_capacity, 0);
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_initialize_elements() {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_front(capacity).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, capacity);
                                        debug_assert_eq!(actual.back_capacity, 0);

                                        _ = actual.shift(-isize::try_from(capacity + additional).expect("too small to wrap")).expect_err("not enough front capacity");

                                        assert_eq!(actual.initialized, 0);
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_reallocate_memory() {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_front(capacity).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, capacity);
                                        debug_assert_eq!(actual.back_capacity, 0);

                                        let allocation = actual.buffer;

                                        _ = actual.shift(-isize::try_from(capacity + additional).expect("too small to wrap")).expect_err("not enough front capacity");

                                        assert_eq!(actual.buffer, allocation);
                                    }
                                }
                            }

                            #[test]
                            fn then_front_many_elements_can_be_prepended_without_reallocating_memory() {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_front(capacity).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, capacity);
                                        debug_assert_eq!(actual.back_capacity, 0);

                                        _ = actual.shift(-isize::try_from(capacity + additional).expect("too small to wrap")).expect_err("not enough front capacity");

                                        let allocation = actual.buffer;

                                        for element in 0..capacity {
                                            _ = actual.prepend(element).expect("uses capacity");
                                        }

                                        assert_eq!(actual.buffer, allocation);
                                    }
                                }
                            }
                        }

                        mod when_not_empty {
                            use super::*;

                            #[test]
                            fn then_does_not_modify_front_capacity() {
                                for elements in 1..32 {
                                    for capacity in 1..32 {
                                        for additional in 1..32 {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(capacity).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, capacity);
                                            debug_assert_eq!(actual.back_capacity, 0);

                                            _ = actual.shift(-isize::try_from(capacity + additional).expect("too small to wrap")).expect_err("not enough front capacity");

                                            assert_eq!(actual.front_capacity, capacity);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_modify_back_capacity() {
                                for elements in 1..32 {
                                    for capacity in 1..32 {
                                        for additional in 1..32 {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(capacity).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, capacity);
                                            debug_assert_eq!(actual.back_capacity, 0);

                                            _ = actual.shift(-isize::try_from(capacity + additional).expect("too small to wrap")).expect_err("not enough front capacity");

                                            assert_eq!(actual.back_capacity, 0);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_modify_initialized_elements() {
                                for elements in 1..32 {
                                    for capacity in 1..32 {
                                        for additional in 1..32 {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(capacity).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, capacity);
                                            debug_assert_eq!(actual.back_capacity, 0);

                                            _ = actual.shift(-isize::try_from(capacity + additional).expect("too small to wrap")).expect_err("not enough front capacity");

                                            assert!(actual.eq(expected));
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_reallocate_memory() {
                                for elements in 1..32 {
                                    for capacity in 1..32 {
                                        for additional in 1..32 {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(capacity).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, capacity);
                                            debug_assert_eq!(actual.back_capacity, 0);

                                            let allocation = actual.buffer;

                                            _ = actual.shift(-isize::try_from(capacity + additional).expect("too small to wrap")).expect_err("not enough front capacity");

                                            assert_eq!(actual.buffer, allocation);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_front_many_elements_can_be_prepended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for capacity in 1..32 {
                                        for additional in 1..32 {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(capacity).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, capacity);
                                            debug_assert_eq!(actual.back_capacity, 0);

                                            _ = actual.shift(-isize::try_from(capacity + additional).expect("too small to wrap")).expect_err("not enough front capacity");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..capacity {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.prepend(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }
                        }
                    }

                    mod when_exactly_requested {
                        use super::*;

                        mod when_empty {
                            use super::*;

                            #[test]
                            fn then_decreases_front_capacity_to_zero() {
                                for capacity in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.shift(-isize::try_from(capacity).expect("too small to wrap")).expect("enough front capacity to shift into");

                                    assert_eq!(actual.front_capacity, 0);
                                }
                            }

                            #[test]
                            fn then_increases_back_capacity_to_front_capacity() {
                                for capacity in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.shift(-isize::try_from(capacity).expect("too small to wrap")).expect("enough front capacity to shift into");

                                    assert_eq!(actual.back_capacity, capacity);
                                }
                            }

                            #[test]
                            fn then_does_not_initialize_elements() {
                                for capacity in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.shift(-isize::try_from(capacity).expect("too small to wrap")).expect("enough front capacity to shift into");

                                    assert_eq!(actual.initialized, 0);
                                }
                            }

                            #[test]
                            fn then_does_not_reallocate_memory() {
                                for capacity in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    let allocation = actual.buffer;

                                    _ = actual.shift(-isize::try_from(capacity).expect("too small to wrap")).expect("enough front capacity to shift into");

                                    assert_eq!(actual.buffer, allocation);
                                }
                            }

                            #[test]
                            fn then_back_many_elements_can_be_appended_without_reallocating_memory() {
                                for capacity in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.shift(-isize::try_from(capacity).expect("too small to wrap")).expect("enough front capacity to shift into");

                                    let allocation = actual.buffer;

                                    for element in 0..capacity {
                                        _ = actual.append(element).expect("uses capacity");
                                    }

                                    assert_eq!(actual.buffer, allocation);
                                }
                            }
                        }

                        mod when_not_empty {
                            use super::*;

                            #[test]
                            fn then_decreases_front_capacity_to_zero() {
                                for elements in 1..32 {
                                    for capacity in 1..32 {
                                        let mut actual: Dynamic<_> = (0..elements).collect();

                                        _ = actual.reserve_front(capacity).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, capacity);
                                        debug_assert_eq!(actual.back_capacity, 0);

                                        _ = actual.shift(-isize::try_from(capacity).expect("too small to wrap")).expect("enough front capacity to shift into");

                                        assert_eq!(actual.front_capacity, 0);
                                    }
                                }
                            }

                            #[test]
                            fn then_increases_back_capacity_to_front_capacity() {
                                for elements in 1..32 {
                                    for capacity in 1..32 {
                                        let mut actual: Dynamic<_> = (0..elements).collect();

                                        _ = actual.reserve_front(capacity).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, capacity);
                                        debug_assert_eq!(actual.back_capacity, 0);

                                        _ = actual.shift(-isize::try_from(capacity).expect("too small to wrap")).expect("enough front capacity to shift into");

                                        assert_eq!(actual.back_capacity, capacity);
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_modify_initialized_elements() {
                                for elements in 1..32 {
                                    for capacity in 1..32 {
                                        let expected = 0..elements;

                                        let mut actual: Dynamic<_> = expected.clone().collect();

                                        _ = actual.reserve_front(capacity).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, capacity);
                                        debug_assert_eq!(actual.back_capacity, 0);

                                        _ = actual.shift(-isize::try_from(capacity).expect("too small to wrap")).expect("enough front capacity to shift into");

                                        assert!(actual.eq(expected));
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_reallocate_memory() {
                                for elements in 1..32 {
                                    for capacity in 1..32 {
                                        let mut actual: Dynamic<_> = (0..elements).collect();

                                        _ = actual.reserve_front(capacity).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, capacity);
                                        debug_assert_eq!(actual.back_capacity, 0);

                                        let allocation = actual.buffer;

                                        _ = actual.shift(-isize::try_from(capacity).expect("too small to wrap")).expect("enough front capacity to shift into");

                                        assert_eq!(actual.buffer, allocation);
                                    }
                                }
                            }

                            #[test]
                            fn then_back_many_elements_can_be_appended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for capacity in 1..32 {
                                        let expected = 0..elements;

                                        let mut actual: Dynamic<_> = expected.clone().collect();

                                        _ = actual.reserve_front(capacity).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, capacity);
                                        debug_assert_eq!(actual.back_capacity, 0);

                                        _ = actual.shift(-isize::try_from(capacity).expect("too small to wrap")).expect("enough front capacity to shift into");

                                        let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                        assert!(pointers.iter().copied().eq(expected));
                                    }
                                }
                            }
                        }
                    }

                    mod when_more_than_requested {
                        use super::*;

                        mod when_empty {
                            use super::*;

                            #[test]
                            fn then_decreases_front_capacity_by_requested() {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_front(capacity + additional).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, capacity + additional);
                                        debug_assert_eq!(actual.back_capacity, 0);

                                        _ = actual.shift(-isize::try_from(capacity).expect("too small to wrap")).expect("enough front capacity to shift into");

                                        assert_eq!(actual.front_capacity, additional);
                                    }
                                }
                            }

                            #[test]
                            fn then_increases_back_capacity_by_requested() {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_front(capacity + additional).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, capacity + additional);
                                        debug_assert_eq!(actual.back_capacity, 0);

                                        _ = actual.shift(-isize::try_from(capacity).expect("too small to wrap")).expect("enough front capacity to shift into");

                                        assert_eq!(actual.back_capacity, capacity);
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_initialize_elements() {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_front(capacity + additional).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, capacity + additional);
                                        debug_assert_eq!(actual.back_capacity, 0);

                                        _ = actual.shift(-isize::try_from(capacity).expect("too small to wrap")).expect("enough front capacity to shift into");

                                        assert_eq!(actual.initialized, 0);
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_reallocate_memory() {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_front(capacity + additional).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, capacity + additional);
                                        debug_assert_eq!(actual.back_capacity, 0);

                                        let allocation = actual.buffer;

                                        _ = actual.shift(-isize::try_from(capacity).expect("too small to wrap")).expect("enough front capacity to shift into");

                                        assert_eq!(actual.buffer, allocation);
                                    }
                                }
                            }

                            #[test]
                            fn then_capacity_many_elements_can_be_appended_without_reallocating_memory() {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_front(capacity + additional).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, capacity + additional);
                                        debug_assert_eq!(actual.back_capacity, 0);

                                        _ = actual.shift(-isize::try_from(capacity).expect("too small to wrap")).expect("enough front capacity to shift into");

                                        let allocation = actual.buffer;

                                        for element in 0..(capacity + additional) {
                                            _ = actual.append(element).expect("uses capacity");
                                        }

                                        assert_eq!(actual.buffer, allocation);
                                    }
                                }
                            }
                        }

                        mod when_not_empty {
                            use super::*;

                            #[test]
                            fn then_decreases_front_capacity_by_requested() {
                                for elements in 1..32 {
                                    for capacity in 1..32 {
                                        for additional in 1..32 {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(capacity + additional).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, capacity + additional);
                                            debug_assert_eq!(actual.back_capacity, 0);

                                            _ = actual.shift(-isize::try_from(capacity).expect("too small to wrap")).expect("enough front capacity to shift into");

                                            assert_eq!(actual.front_capacity, additional);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_increases_back_capacity_by_requested() {
                                for elements in 1..32 {
                                    for capacity in 1..32 {
                                        for additional in 1..32 {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(capacity + additional).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, capacity + additional);
                                            debug_assert_eq!(actual.back_capacity, 0);

                                            _ = actual.shift(-isize::try_from(capacity).expect("too small to wrap")).expect("enough front capacity to shift into");

                                            assert_eq!(actual.back_capacity, capacity);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_modify_initialized_elements() {
                                for elements in 1..32 {
                                    for capacity in 1..32 {
                                        for additional in 1..32 {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(capacity + additional).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, capacity + additional);
                                            debug_assert_eq!(actual.back_capacity, 0);

                                            _ = actual.shift(-isize::try_from(capacity).expect("too small to wrap")).expect("enough front capacity to shift into");

                                            assert!(actual.eq(expected));
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_reallocate_memory() {
                                for elements in 1..32 {
                                    for capacity in 1..32 {
                                        for additional in 1..32 {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(capacity + additional).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, capacity + additional);
                                            debug_assert_eq!(actual.back_capacity, 0);

                                            let allocation = actual.buffer;

                                            _ = actual.shift(-isize::try_from(capacity).expect("too small to wrap")).expect("enough front capacity to shift into");

                                            assert_eq!(actual.buffer, allocation);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_front_many_elements_can_be_prepended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for capacity in 1..32 {
                                        for additional in 1..32 {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(capacity + additional).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, capacity + additional);
                                            debug_assert_eq!(actual.back_capacity, 0);

                                            _ = actual.shift(-isize::try_from(capacity).expect("too small to wrap")).expect("enough front capacity to shift into");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..additional {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.prepend(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_back_many_elements_can_be_appended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for capacity in 1..32 {
                                        for additional in 1..32 {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(capacity + additional).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, capacity + additional);
                                            debug_assert_eq!(actual.back_capacity, 0);

                                            _ = actual.shift(-isize::try_from(capacity).expect("too small to wrap")).expect("enough front capacity to shift into");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..capacity {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.append(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_both_front_many_elements_can_be_prepended_and_back_many_elements_can_be_appended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for capacity in 1..32 {
                                        for additional in 1..32 {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(capacity + additional).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, capacity + additional);
                                            debug_assert_eq!(actual.back_capacity, 0);

                                            _ = actual.shift(-isize::try_from(capacity).expect("too small to wrap")).expect("enough front capacity to shift into");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..additional {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.prepend(usize::MAX).expect("uses capacity");
                                            }

                                            for _ in 0..capacity {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.append(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                mod when_positive_requested {
                    use super::*;

                    mod when_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_front_capacity() {
                            for capacity in 1..32 {
                                for requested in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.shift(requested).expect_err("not enough back capacity");

                                    assert_eq!(actual.front_capacity, capacity);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_back_capacity() {
                            for capacity in 1..32 {
                                for requested in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.shift(requested).expect_err("not enough back capacity");

                                    assert_eq!(actual.back_capacity, 0);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_initialize_elements() {
                            for capacity in 1..32 {
                                for requested in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.shift(requested).expect_err("not enough back capacity");

                                    assert_eq!(actual.initialized, 0);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_reallocate_memory() {
                            for capacity in 1..32 {
                                for requested in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    let allocation = actual.buffer;

                                    _ = actual.shift(requested).expect_err("not enough back capacity");

                                    assert_eq!(actual.buffer, allocation);
                                }
                            }
                        }

                        #[test]
                        fn then_front_many_elements_can_be_prepended_without_reallocating_memory() {
                            for capacity in 1..32 {
                                for requested in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.shift(requested).expect_err("not enough back capacity");

                                    let allocation = actual.buffer;

                                    for element in 0..capacity {
                                        _ = actual.prepend(element).expect("uses capacity");
                                    }

                                    assert_eq!(actual.buffer, allocation);
                                }
                            }
                        }
                    }

                    mod when_not_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_front_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for requested in 1..32 {
                                        let mut actual: Dynamic<_> = (0..elements).collect();

                                        _ = actual.reserve_front(capacity).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, capacity);
                                        debug_assert_eq!(actual.back_capacity, 0);

                                        _ = actual.shift(requested).expect_err("not enough back capacity");

                                        assert_eq!(actual.front_capacity, capacity);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_back_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for requested in 1..32 {
                                        let mut actual: Dynamic<_> = (0..elements).collect();

                                        _ = actual.reserve_front(capacity).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, capacity);
                                        debug_assert_eq!(actual.back_capacity, 0);

                                        _ = actual.shift(requested).expect_err("not enough back capacity");

                                        assert_eq!(actual.back_capacity, 0);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_initialized_elements() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for requested in 1..32 {
                                        let expected = 0..elements;

                                        let mut actual: Dynamic<_> = expected.clone().collect();

                                        _ = actual.reserve_front(capacity).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, capacity);
                                        debug_assert_eq!(actual.back_capacity, 0);

                                        _ = actual.shift(requested).expect_err("not enough back capacity");

                                        assert!(actual.eq(expected));
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_reallocate_memory() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for requested in 1..32 {
                                        let mut actual: Dynamic<_> = (0..elements).collect();

                                        _ = actual.reserve_front(capacity).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, capacity);
                                        debug_assert_eq!(actual.back_capacity, 0);

                                        let allocation = actual.buffer;

                                        _ = actual.shift(requested).expect_err("not enough back capacity");

                                        assert_eq!(actual.buffer, allocation);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_front_many_elements_can_be_prepended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for requested in 1..32 {
                                        let expected = 0..elements;

                                        let mut actual: Dynamic<_> = expected.clone().collect();

                                        _ = actual.reserve_front(capacity).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, capacity);
                                        debug_assert_eq!(actual.back_capacity, 0);

                                        _ = actual.shift(requested).expect_err("not enough back capacity");

                                        let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                        for _ in 0..capacity {
                                            _ = actual.prepend(usize::MAX).expect("uses capacity");
                                        }

                                        assert!(pointers.iter().copied().eq(expected));
                                    }
                                }
                            }
                        }
                    }
                }
            }

            mod when_only_back_capacity {
                use super::*;

                mod when_zero_requested {
                    use super::*;

                    mod when_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_front_capacity() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_back(capacity).expect("successful allocation");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, 0);
                                debug_assert_eq!(actual.back_capacity, capacity);

                                _ = actual.shift(0).expect("does nothing");

                                assert_eq!(actual.front_capacity, 0);
                            }
                        }

                        #[test]
                        fn then_does_not_modify_back_capacity() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_back(capacity).expect("successful allocation");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, 0);
                                debug_assert_eq!(actual.back_capacity, capacity);

                                _ = actual.shift(0).expect("does nothing");

                                assert_eq!(actual.back_capacity, capacity);
                            }
                        }

                        #[test]
                        fn then_does_not_initialize_elements() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_back(capacity).expect("successful allocation");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, 0);
                                debug_assert_eq!(actual.back_capacity, capacity);

                                _ = actual.shift(0).expect("does nothing");

                                assert_eq!(actual.initialized, 0);
                            }
                        }

                        #[test]
                        fn then_does_not_reallocate_memory() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_back(capacity).expect("successful allocation");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, 0);
                                debug_assert_eq!(actual.back_capacity, capacity);

                                let allocation = actual.buffer;

                                _ = actual.shift(0).expect("does nothing");

                                assert_eq!(actual.buffer, allocation);
                            }
                        }

                        #[test]
                        fn then_back_many_elements_can_be_appended_without_reallocating_memory() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_back(capacity).expect("successful allocation");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, 0);
                                debug_assert_eq!(actual.back_capacity, capacity);

                                _ = actual.shift(0).expect("does nothing");

                                let allocation = actual.buffer;

                                for element in 0..capacity {
                                    _ = actual.append(element).expect("uses capacity");
                                }

                                assert_eq!(actual.buffer, allocation);
                            }
                        }
                    }

                    mod when_not_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_front_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let mut actual: Dynamic<_> = (0..elements).collect();

                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    _ = actual.shift(0).expect("does nothing");

                                    assert_eq!(actual.front_capacity, 0);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_back_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let mut actual: Dynamic<_> = (0..elements).collect();

                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    _ = actual.shift(0).expect("does nothing");

                                    assert_eq!(actual.back_capacity, capacity);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_initialized_elements() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let expected = 0..elements;

                                    let mut actual: Dynamic<_> = expected.clone().collect();

                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    _ = actual.shift(0).expect("does nothing");

                                    assert!(actual.eq(expected));
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_reallocate_memory() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let mut actual: Dynamic<_> = (0..elements).collect();

                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    let allocation = actual.buffer;

                                    _ = actual.shift(0).expect("does nothing");

                                    assert_eq!(actual.buffer, allocation);
                                }
                            }
                        }

                        #[test]
                        fn then_back_many_elements_can_be_appended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let expected = 0..elements;

                                    let mut actual: Dynamic<_> = expected.clone().collect();

                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    _ = actual.shift(0).expect("does nothing");

                                    let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                    for _ in 0..capacity {
                                        // NOTE: this is distinct from the expected values.
                                        _ = actual.append(usize::MAX).expect("uses capacity");
                                    }

                                    assert!(pointers.iter().copied().eq(expected));
                                }
                            }
                        }
                    }
                }

                mod when_negative_requested {
                    use super::*;

                    mod when_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_front_capacity() {
                            for capacity in 1..32 {
                                for requested in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    _ = actual.shift(-requested).expect_err("not enough front capacity");

                                    assert_eq!(actual.front_capacity, 0);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_back_capacity() {
                            for capacity in 1..32 {
                                for requested in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    _ = actual.shift(-requested).expect_err("not enough front capacity");

                                    assert_eq!(actual.back_capacity, capacity);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_initialize_elements() {
                            for capacity in 1..32 {
                                for requested in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    _ = actual.shift(-requested).expect_err("not enough front capacity");

                                    assert_eq!(actual.initialized, 0);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_reallocate_memory() {
                            for capacity in 1..32 {
                                for requested in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    let allocation = actual.buffer;

                                    _ = actual.shift(-requested).expect_err("not enough front capacity");

                                    assert_eq!(actual.buffer, allocation);
                                }
                            }
                        }

                        #[test]
                        fn then_back_many_elements_can_be_appended_without_reallocating_memory() {
                            for capacity in 1..32 {
                                for requested in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    _ = actual.shift(-requested).expect_err("not enough front capacity");

                                    let allocation = actual.buffer;

                                    for element in 0..capacity {
                                        _ = actual.append(element).expect("uses capacity");
                                    }

                                    assert_eq!(actual.buffer, allocation);
                                }
                            }
                        }
                    }

                    mod when_not_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_front_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for requested in 1..32 {
                                        let mut actual: Dynamic<_> = (0..elements).collect();

                                        _ = actual.reserve_back(capacity).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, 0);
                                        debug_assert_eq!(actual.back_capacity, capacity);

                                        _ = actual.shift(-requested).expect_err("not enough front capacity");

                                        assert_eq!(actual.front_capacity, 0);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_back_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for requested in 1..32 {
                                        let mut actual: Dynamic<_> = (0..elements).collect();

                                        _ = actual.reserve_back(capacity).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, 0);
                                        debug_assert_eq!(actual.back_capacity, capacity);

                                        _ = actual.shift(-requested).expect_err("not enough front capacity");

                                        assert_eq!(actual.back_capacity, capacity);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_initialized_elements() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for requested in 1..32 {
                                        let expected = 0..elements;

                                        let mut actual: Dynamic<_> = expected.clone().collect();

                                        _ = actual.reserve_back(capacity).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, 0);
                                        debug_assert_eq!(actual.back_capacity, capacity);

                                        _ = actual.shift(-requested).expect_err("not enough front capacity");

                                        assert!(actual.eq(expected));
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_reallocate_memory() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for requested in 1..32 {
                                        let mut actual: Dynamic<_> = (0..elements).collect();

                                        _ = actual.reserve_back(capacity).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, 0);
                                        debug_assert_eq!(actual.back_capacity, capacity);

                                        let allocation = actual.buffer;

                                        _ = actual.shift(-requested).expect_err("not enough front capacity");

                                        assert_eq!(actual.buffer, allocation);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_back_many_elements_can_be_appended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for requested in 1..32 {
                                        let expected = 0..elements;

                                        let mut actual: Dynamic<_> = expected.clone().collect();

                                        _ = actual.reserve_back(capacity).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, 0);
                                        debug_assert_eq!(actual.back_capacity, capacity);

                                        _ = actual.shift(-requested).expect_err("not enough front capacity");

                                        let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                        for _ in 0..capacity {
                                            // NOTE: this is distinct from the expected values.
                                            _ = actual.append(usize::MAX).expect("uses capacity");
                                        }

                                        assert!(pointers.iter().copied().eq(expected));
                                    }
                                }
                            }
                        }
                    }
                }

                mod when_positive_requested {
                    use super::*;

                    mod when_less_than_requested {
                        use super::*;

                        mod when_empty {
                            use super::*;

                            #[test]
                            fn then_does_not_modify_front_capacity() {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(capacity).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, 0);
                                        debug_assert_eq!(actual.back_capacity, capacity);

                                        _ = actual.shift(isize::try_from(capacity + additional).expect("too small to wrap")).expect_err("not enough back capacity");

                                        assert_eq!(actual.front_capacity, 0);
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_modify_back_capacity() {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(capacity).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, 0);
                                        debug_assert_eq!(actual.back_capacity, capacity);

                                        _ = actual.shift(isize::try_from(capacity + additional).expect("too small to wrap")).expect_err("not enough back capacity");

                                        assert_eq!(actual.back_capacity, capacity);
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_initialize_elements() {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(capacity).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, 0);
                                        debug_assert_eq!(actual.back_capacity, capacity);

                                        _ = actual.shift(isize::try_from(capacity + additional).expect("too small to wrap")).expect_err("not enough back capacity");

                                        assert_eq!(actual.initialized, 0);
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_reallocate_memory() {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(capacity).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, 0);
                                        debug_assert_eq!(actual.back_capacity, capacity);

                                        let allocation = actual.buffer;

                                        _ = actual.shift(isize::try_from(capacity + additional).expect("too small to wrap")).expect_err("not enough back capacity");

                                        assert_eq!(actual.buffer, allocation);
                                    }
                                }
                            }

                            #[test]
                            fn then_back_many_elements_can_be_appended_without_reallocating_memory() {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(capacity).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, 0);
                                        debug_assert_eq!(actual.back_capacity, capacity);

                                        _ = actual.shift(isize::try_from(capacity + additional).expect("too small to wrap")).expect_err("not enough back capacity");

                                        let allocation = actual.buffer;

                                        for element in 0..capacity {
                                            _ = actual.append(element).expect("uses capacity");
                                        }

                                        assert_eq!(actual.buffer, allocation);
                                    }
                                }
                            }
                        }

                        mod when_not_empty {
                            use super::*;

                            #[test]
                            fn then_does_not_modify_front_capacity() {
                                for elements in 1..32 {
                                    for capacity in 1..32 {
                                        for additional in 1..32 {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_back(capacity).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, 0);
                                            debug_assert_eq!(actual.back_capacity, capacity);

                                            _ = actual.shift(isize::try_from(capacity + additional).expect("too small to wrap")).expect_err("not enough back capacity");

                                            assert_eq!(actual.front_capacity, 0);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_modify_back_capacity() {
                                for elements in 1..32 {
                                    for capacity in 1..32 {
                                        for additional in 1..32 {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_back(capacity).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, 0);
                                            debug_assert_eq!(actual.back_capacity, capacity);

                                            _ = actual.shift(isize::try_from(capacity + additional).expect("too small to wrap")).expect_err("not enough back capacity");

                                            assert_eq!(actual.back_capacity, capacity);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_modify_initialized_elements() {
                                for elements in 1..32 {
                                    for capacity in 1..32 {
                                        for additional in 1..32 {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_back(capacity).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, 0);
                                            debug_assert_eq!(actual.back_capacity, capacity);

                                            _ = actual.shift(isize::try_from(capacity + additional).expect("too small to wrap")).expect_err("not enough back capacity");

                                            assert!(actual.eq(expected));
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_reallocate_memory() {
                                for elements in 1..32 {
                                    for capacity in 1..32 {
                                        for additional in 1..32 {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_back(capacity).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, 0);
                                            debug_assert_eq!(actual.back_capacity, capacity);

                                            let allocation = actual.buffer;

                                            _ = actual.shift(isize::try_from(capacity + additional).expect("too small to wrap")).expect_err("not enough back capacity");

                                            assert_eq!(actual.buffer, allocation);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_back_many_elements_can_be_appended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for capacity in 1..32 {
                                        for additional in 1..32 {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_back(capacity).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, 0);
                                            debug_assert_eq!(actual.back_capacity, capacity);

                                            _ = actual.shift(isize::try_from(capacity + additional).expect("too small to wrap")).expect_err("not enough back capacity");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..capacity {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.append(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }
                        }
                    }

                    mod when_exactly_requested {
                        use super::*;

                        mod when_empty {
                            use super::*;

                            #[test]
                            fn then_increases_front_capacity_to_back_capacity() {
                                for capacity in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    _ = actual.shift(isize::try_from(capacity).expect("too small to wrap")).expect("enough back capacity to shift into");

                                    assert_eq!(actual.front_capacity, capacity);
                                }
                            }

                            #[test]
                            fn then_decreases_back_capacity_to_zero() {
                                for capacity in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    _ = actual.shift(isize::try_from(capacity).expect("too small to wrap")).expect("enough back capacity to shift into");

                                    assert_eq!(actual.back_capacity, 0);
                                }
                            }

                            #[test]
                            fn then_does_not_initialize_elements() {
                                for capacity in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    _ = actual.shift(isize::try_from(capacity).expect("too small to wrap")).expect("enough back capacity to shift into");

                                    assert_eq!(actual.initialized, 0);
                                }
                            }

                            #[test]
                            fn then_does_not_reallocate_memory() {
                                for capacity in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    let allocation = actual.buffer;

                                    _ = actual.shift(isize::try_from(capacity).expect("too small to wrap")).expect("enough back capacity to shift into");

                                    assert_eq!(actual.buffer, allocation);
                                }
                            }

                            #[test]
                            fn then_front_many_elements_can_be_prepended_without_reallocating_memory() {
                                for capacity in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    _ = actual.shift(isize::try_from(capacity).expect("too small to wrap")).expect("enough back capacity to shift into");

                                    let allocation = actual.buffer;

                                    for element in 0..capacity {
                                        _ = actual.append(element).expect("uses capacity");
                                    }

                                    assert_eq!(actual.buffer, allocation);
                                }
                            }
                        }

                        mod when_not_empty {
                            use super::*;

                            #[test]
                            fn then_increases_front_capacity_to_back_capacity() {
                                for elements in 1..32 {
                                    for capacity in 1..32 {
                                        let mut actual: Dynamic<_> = (0..elements).collect();

                                        _ = actual.reserve_back(capacity).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, 0);
                                        debug_assert_eq!(actual.back_capacity, capacity);

                                        _ = actual.shift(isize::try_from(capacity).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        assert_eq!(actual.front_capacity, capacity);
                                    }
                                }
                            }

                            #[test]
                            fn then_decreases_back_capacity_to_zero() {
                                for elements in 1..32 {
                                    for capacity in 1..32 {
                                        let mut actual: Dynamic<_> = (0..elements).collect();

                                        _ = actual.reserve_back(capacity).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, 0);
                                        debug_assert_eq!(actual.back_capacity, capacity);

                                        _ = actual.shift(isize::try_from(capacity).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        assert_eq!(actual.back_capacity, 0);
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_modify_initialized_elements() {
                                for elements in 1..32 {
                                    for capacity in 1..32 {
                                        let expected = 0..elements;

                                        let mut actual: Dynamic<_> = expected.clone().collect();

                                        _ = actual.reserve_back(capacity).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, 0);
                                        debug_assert_eq!(actual.back_capacity, capacity);

                                        _ = actual.shift(isize::try_from(capacity).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        assert!(actual.eq(expected));
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_reallocate_memory() {
                                for elements in 1..32 {
                                    for capacity in 1..32 {
                                        let mut actual: Dynamic<_> = (0..elements).collect();

                                        _ = actual.reserve_back(capacity).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, 0);
                                        debug_assert_eq!(actual.back_capacity, capacity);

                                        let allocation = actual.buffer;

                                        _ = actual.shift(isize::try_from(capacity).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        assert_eq!(actual.buffer, allocation);
                                    }
                                }
                            }

                            #[test]
                            fn then_front_many_elements_can_be_prepended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for capacity in 1..32 {
                                        let expected = 0..elements;

                                        let mut actual: Dynamic<_> = expected.clone().collect();

                                        _ = actual.reserve_back(capacity).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, 0);
                                        debug_assert_eq!(actual.back_capacity, capacity);

                                        _ = actual.shift(isize::try_from(capacity).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                        for _ in 0..capacity {
                                            // NOTE: this is distinct from the expected values.
                                            _ = actual.prepend(usize::MAX).expect("uses capacity");
                                        }

                                        assert!(pointers.iter().copied().eq(expected));
                                    }
                                }
                            }
                        }
                    }

                    mod when_more_than_requested {
                        use super::*;

                        mod when_empty {
                            use super::*;

                            #[test]
                            fn then_increases_front_capacity_by_requested() {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(capacity + additional).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, 0);
                                        debug_assert_eq!(actual.back_capacity, capacity + additional);

                                        _ = actual.shift(isize::try_from(capacity).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        assert_eq!(actual.front_capacity, capacity);
                                    }
                                }
                            }

                            #[test]
                            fn then_decreases_back_capacity_by_requested() {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(capacity + additional).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, 0);
                                        debug_assert_eq!(actual.back_capacity, capacity + additional);

                                        _ = actual.shift(isize::try_from(capacity).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        assert_eq!(actual.back_capacity, additional);
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_initialize_elements() {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(capacity + additional).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, 0);
                                        debug_assert_eq!(actual.back_capacity, capacity + additional);

                                        _ = actual.shift(isize::try_from(capacity).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        assert_eq!(actual.initialized, 0);
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_reallocate_memory() {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(capacity + additional).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, 0);
                                        debug_assert_eq!(actual.back_capacity, capacity + additional);

                                        let allocation = actual.buffer;

                                        _ = actual.shift(isize::try_from(capacity).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        assert_eq!(actual.buffer, allocation);
                                    }
                                }
                            }

                            #[test]
                            fn then_capacity_many_elements_can_be_prepended_without_reallocating_memory() {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(capacity + additional).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, 0);
                                        debug_assert_eq!(actual.back_capacity, capacity + additional);

                                        _ = actual.shift(isize::try_from(capacity).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        let allocation = actual.buffer;

                                        for element in 0..(capacity + additional) {
                                            _ = actual.prepend(element).expect("uses capacity");
                                        }

                                        assert_eq!(actual.buffer, allocation);
                                    }
                                }
                            }
                        }

                        mod when_not_empty {
                            use super::*;

                            #[test]
                            fn then_increases_front_capacity_by_requested() {
                                for elements in 1..32 {
                                    for capacity in 1..32 {
                                        for additional in 1..32 {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_back(capacity + additional).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, 0);
                                            debug_assert_eq!(actual.back_capacity, capacity + additional);

                                            _ = actual.shift(isize::try_from(capacity).expect("too small to wrap")).expect("enough back capacity to shift into");

                                            assert_eq!(actual.front_capacity, capacity);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_decreases_back_capacity_by_requested() {
                                for elements in 1..32 {
                                    for capacity in 1..32 {
                                        for additional in 1..32 {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_back(capacity + additional).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, 0);
                                            debug_assert_eq!(actual.back_capacity, capacity + additional);

                                            _ = actual.shift(isize::try_from(capacity).expect("too small to wrap")).expect("enough back capacity to shift into");

                                            assert_eq!(actual.back_capacity, additional);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_modify_initialized_elements() {
                                for elements in 1..32 {
                                    for capacity in 1..32 {
                                        for additional in 1..32 {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_back(capacity + additional).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, 0);
                                            debug_assert_eq!(actual.back_capacity, capacity + additional);

                                            _ = actual.shift(isize::try_from(capacity).expect("too small to wrap")).expect("enough back capacity to shift into");

                                            assert!(actual.eq(expected));
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_reallocate_memory() {
                                for elements in 1..32 {
                                    for capacity in 1..32 {
                                        for additional in 1..32 {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_back(capacity + additional).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, 0);
                                            debug_assert_eq!(actual.back_capacity, capacity + additional);

                                            let allocation = actual.buffer;

                                            _ = actual.shift(isize::try_from(capacity).expect("too small to wrap")).expect("enough back capacity to shift into");

                                            assert_eq!(actual.buffer, allocation);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_front_many_elements_can_be_prepended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for capacity in 1..32 {
                                        for additional in 1..32 {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_back(capacity + additional).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, 0);
                                            debug_assert_eq!(actual.back_capacity, capacity + additional);

                                            _ = actual.shift(isize::try_from(capacity).expect("too small to wrap")).expect("enough back capacity to shift into");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..capacity {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.prepend(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_back_many_elements_can_be_appended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for capacity in 1..32 {
                                        for additional in 1..32 {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_back(capacity + additional).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, 0);
                                            debug_assert_eq!(actual.back_capacity, capacity + additional);

                                            _ = actual.shift(isize::try_from(capacity).expect("too small to wrap")).expect("enough back capacity to shift into");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..additional {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.append(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_both_front_many_elements_can_be_prepended_and_back_many_elements_can_be_appended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for capacity in 1..32 {
                                        for additional in 1..32 {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_back(capacity + additional).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, 0);
                                            debug_assert_eq!(actual.back_capacity, capacity + additional);

                                            _ = actual.shift(isize::try_from(capacity).expect("too small to wrap")).expect("enough back capacity to shift into");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..capacity {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.prepend(usize::MAX).expect("uses capacity");
                                            }

                                            for _ in 0..additional {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.append(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }

            mod when_both_front_and_back_capacity {
                use super::*;

                mod when_zero_requested {
                    use super::*;

                    mod when_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_front_capacity() {
                            for front in 1..32 {
                                for back in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_back(front + back).expect("successful allocation");

                                    _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, front);
                                    debug_assert_eq!(actual.back_capacity, back);

                                    _ = actual.shift(0).expect("does nothing");

                                    assert_eq!(actual.front_capacity, front);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_back_capacity() {
                            for front in 1..32 {
                                for back in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_back(front + back).expect("successful allocation");

                                    _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, front);
                                    debug_assert_eq!(actual.back_capacity, back);

                                    _ = actual.shift(0).expect("does nothing");

                                    assert_eq!(actual.back_capacity, back);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_initialize_elements() {
                            for front in 1..32 {
                                for back in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_back(front + back).expect("successful allocation");

                                    _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, front);
                                    debug_assert_eq!(actual.back_capacity, back);

                                    _ = actual.shift(0).expect("does nothing");

                                    assert_eq!(actual.initialized, 0);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_reallocate_memory() {
                            for front in 1..32 {
                                for back in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_back(front + back).expect("successful allocation");

                                    _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, front);
                                    debug_assert_eq!(actual.back_capacity, back);

                                    let allocation = actual.buffer;

                                    _ = actual.shift(0).expect("does nothing");

                                    assert_eq!(actual.buffer, allocation);
                                }
                            }
                        }

                        #[test]
                        fn then_capacity_many_elements_can_be_prepended_without_reallocating_memory() {
                            for front in 1..32 {
                                for back in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_back(front + back).expect("successful allocation");

                                    _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, front);
                                    debug_assert_eq!(actual.back_capacity, back);

                                    _ = actual.shift(0).expect("does nothing");

                                    let allocation = actual.buffer;

                                    for element in 0..(front + back) {
                                        _ = actual.prepend(element).expect("uses capacity");
                                    }

                                    assert_eq!(actual.buffer, allocation);
                                }
                            }
                        }

                        #[test]
                        fn then_capacity_many_elements_can_be_appended_without_reallocating_memory() {
                            for front in 1..32 {
                                for back in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_back(front + back).expect("successful allocation");

                                    _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, front);
                                    debug_assert_eq!(actual.back_capacity, back);

                                    _ = actual.shift(0).expect("does nothing");

                                    let allocation = actual.buffer;

                                    for element in 0..(front + back) {
                                        _ = actual.append(element).expect("uses capacity");
                                    }

                                    assert_eq!(actual.buffer, allocation);
                                }
                            }
                        }
                    }

                    mod when_not_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_front_capacity() {
                            for elements in 1..32 {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        let mut actual: Dynamic<_> = (0..elements).collect();

                                        _ = actual.reserve_front(front).expect("successful allocation");
                                        _ = actual.reserve_back(back).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.shift(0).expect("does nothing");

                                        assert_eq!(actual.front_capacity, front);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_back_capacity() {
                            for elements in 1..32 {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        let mut actual: Dynamic<_> = (0..elements).collect();

                                        _ = actual.reserve_front(front).expect("successful allocation");
                                        _ = actual.reserve_back(back).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.shift(0).expect("does nothing");

                                        assert_eq!(actual.back_capacity, back);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_initialized_elements() {
                            for elements in 1..32 {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        let expected = 0..elements;

                                        let mut actual: Dynamic<_> = expected.clone().collect();

                                        _ = actual.reserve_front(front).expect("successful allocation");
                                        _ = actual.reserve_back(back).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.shift(0).expect("does nothing");

                                        assert!(actual.eq(expected));
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_reallocate_memory() {
                            for elements in 1..32 {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        let mut actual: Dynamic<_> = (0..elements).collect();

                                        _ = actual.reserve_front(front).expect("successful allocation");
                                        _ = actual.reserve_back(back).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        let allocation = actual.buffer;

                                        _ = actual.shift(0).expect("does nothing");

                                        assert_eq!(actual.buffer, allocation);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_front_many_elements_can_be_prepended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        let expected = 0..elements;

                                        let mut actual: Dynamic<_> = expected.clone().collect();

                                        _ = actual.reserve_front(front).expect("successful allocation");
                                        _ = actual.reserve_back(back).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.shift(0).expect("does nothing");

                                        let pointers= unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                        for _ in 0..front {
                                            // NOTE: this is distinct form the expected values.
                                            _ = actual.prepend(usize::MAX).expect("uses capacity");
                                        }

                                        assert!(pointers.iter().copied().eq(expected));
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_back_many_elements_can_be_appended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        let expected = 0..elements;

                                        let mut actual: Dynamic<_> = expected.clone().collect();

                                        _ = actual.reserve_front(front).expect("successful allocation");
                                        _ = actual.reserve_back(back).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.shift(0).expect("does nothing");

                                        let pointers= unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                        for _ in 0..back {
                                            // NOTE: this is distinct form the expected values.
                                            _ = actual.append(usize::MAX).expect("uses capacity");
                                        }

                                        assert!(pointers.iter().copied().eq(expected));
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_both_front_many_elements_can_be_prepended_and_back_many_elements_can_be_appended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        let expected = 0..elements;

                                        let mut actual: Dynamic<_> = expected.clone().collect();

                                        _ = actual.reserve_front(front).expect("successful allocation");
                                        _ = actual.reserve_back(back).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.shift(0).expect("does nothing");

                                        let pointers= unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                        for _ in 0..front {
                                            // NOTE: this is distinct form the expected values.
                                            _ = actual.prepend(usize::MAX).expect("uses capacity");
                                        }

                                        for _ in 0..back {
                                            // NOTE: this is distinct form the expected values.
                                            _ = actual.append(usize::MAX).expect("uses capacity");
                                        }

                                        assert!(pointers.iter().copied().eq(expected));
                                    }
                                }
                            }
                        }
                    }
                }

                mod when_negative_requested {
                    use super::*;

                    mod when_front_is_less_than_requested {
                        use super::*;

                        mod when_empty {
                            use super::*;

                            #[test]
                            fn then_does_not_modify_front_capacity() {
                                for front in 1..32 {
                                    for additional in 1..32 {
                                        for back in 1..32 {
                                            let mut actual = Dynamic::<usize>::default();

                                            _ = actual.reserve_back(front + back).expect("successful allocation");

                                            _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                            debug_assert_eq!(actual.initialized, 0);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.shift(-isize::try_from(front + additional).expect("too small to wrap")).expect_err("not enough front capacity");

                                            assert_eq!(actual.front_capacity, front);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_modify_back_capacity() {
                                for front in 1..32 {
                                    for additional in 1..32 {
                                        for back in 1..32 {
                                            let mut actual = Dynamic::<usize>::default();

                                            _ = actual.reserve_back(front + back).expect("successful allocation");

                                            _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                            debug_assert_eq!(actual.initialized, 0);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.shift(-isize::try_from(front + additional).expect("too small to wrap")).expect_err("not enough front capacity");

                                            assert_eq!(actual.back_capacity, back);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_initialize_elements() {
                                for front in 1..32 {
                                    for additional in 1..32 {
                                        for back in 1..32 {
                                            let mut actual = Dynamic::<usize>::default();

                                            _ = actual.reserve_back(front + back).expect("successful allocation");

                                            _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                            debug_assert_eq!(actual.initialized, 0);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.shift(-isize::try_from(front + additional).expect("too small to wrap")).expect_err("not enough front capacity");

                                            assert_eq!(actual.initialized, 0);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_reallocate_memory() {
                                for front in 1..32 {
                                    for additional in 1..32 {
                                        for back in 1..32 {
                                            let mut actual = Dynamic::<usize>::default();

                                            _ = actual.reserve_back(front + back).expect("successful allocation");

                                            _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                            debug_assert_eq!(actual.initialized, 0);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            let allocation = actual.buffer;

                                            _ = actual.shift(-isize::try_from(front + additional).expect("too small to wrap")).expect_err("not enough front capacity");

                                            assert_eq!(actual.buffer, allocation);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_capacity_many_elements_can_be_prepended_without_reallocating_memory() {
                                for front in 1..32 {
                                    for additional in 1..32 {
                                        for back in 1..32 {
                                            let mut actual = Dynamic::<usize>::default();

                                            _ = actual.reserve_back(front + back).expect("successful allocation");

                                            _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                            debug_assert_eq!(actual.initialized, 0);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.shift(-isize::try_from(front + additional).expect("too small to wrap")).expect_err("not enough front capacity");

                                            let allocation = actual.buffer;

                                            for element in 0..(front + back) {
                                                _ = actual.prepend(element).expect("uses capacity");
                                            }

                                            assert_eq!(actual.buffer, allocation);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_capacity_many_elements_can_be_appended_without_reallocating_memory() {
                                for front in 1..32 {
                                    for additional in 1..32 {
                                        for back in 1..32 {
                                            let mut actual = Dynamic::<usize>::default();

                                            _ = actual.reserve_back(front + back).expect("successful allocation");

                                            _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                            debug_assert_eq!(actual.initialized, 0);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.shift(-isize::try_from(front + additional).expect("too small to wrap")).expect_err("not enough front capacity");

                                            let allocation = actual.buffer;

                                            for element in 0..(front + back) {
                                                _ = actual.append(element).expect("uses capacity");
                                            }

                                            assert_eq!(actual.buffer, allocation);
                                        }
                                    }
                                }
                            }
                        }

                        mod when_not_empty {
                            use super::*;

                            #[test]
                            fn then_does_not_modify_front_capacity() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for additional in 1..32 {
                                            for back in 1..32 {
                                                let mut actual: Dynamic<_> = (0..elements).collect();

                                                _ = actual.reserve_front(front).expect("successful allocation");
                                                _ = actual.reserve_back(back).expect("successful allocation");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front);
                                                debug_assert_eq!(actual.back_capacity, back);

                                                _ = actual.shift(-isize::try_from(front + additional).expect("too small to wrap")).expect_err("not enough front capacity");

                                                assert_eq!(actual.front_capacity, front);
                                            }
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_modify_back_capacity() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for additional in 1..32 {
                                            for back in 1..32 {
                                                let mut actual: Dynamic<_> = (0..elements).collect();

                                                _ = actual.reserve_front(front).expect("successful allocation");
                                                _ = actual.reserve_back(back).expect("successful allocation");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front);
                                                debug_assert_eq!(actual.back_capacity, back);

                                                _ = actual.shift(-isize::try_from(front + additional).expect("too small to wrap")).expect_err("not enough front capacity");

                                                assert_eq!(actual.back_capacity, back);
                                            }
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_modify_initialized_elements() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for additional in 1..32 {
                                            for back in 1..32 {
                                                let expected = 0..elements;

                                                let mut actual: Dynamic<_> = expected.clone().collect();

                                                _ = actual.reserve_front(front).expect("successful allocation");
                                                _ = actual.reserve_back(back).expect("successful allocation");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front);
                                                debug_assert_eq!(actual.back_capacity, back);

                                                _ = actual.shift(-isize::try_from(front + additional).expect("too small to wrap")).expect_err("not enough front capacity");

                                                assert!(actual.eq(expected));
                                            }
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_reallocate_memory() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for additional in 1..32 {
                                            for back in 1..32 {
                                                let mut actual: Dynamic<_> = (0..elements).collect();

                                                _ = actual.reserve_front(front).expect("successful allocation");
                                                _ = actual.reserve_back(back).expect("successful allocation");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front);
                                                debug_assert_eq!(actual.back_capacity, back);

                                                let allocation = actual.buffer;

                                                _ = actual.shift(-isize::try_from(front + additional).expect("too small to wrap")).expect_err("not enough front capacity");

                                                assert_eq!(actual.buffer, allocation);
                                            }
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_front_many_elements_can_be_prepended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for additional in 1..32 {
                                            for back in 1..32 {
                                                let expected = 0..elements;

                                                let mut actual: Dynamic<_> = expected.clone().collect();

                                                _ = actual.reserve_front(front).expect("successful allocation");
                                                _ = actual.reserve_back(back).expect("successful allocation");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front);
                                                debug_assert_eq!(actual.back_capacity, back);

                                                _ = actual.shift(-isize::try_from(front + additional).expect("too small to wrap")).expect_err("not enough front capacity");

                                                let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                                for _ in 0..front {
                                                    // NOTE: this is distinct from the expected values.
                                                    _ = actual.prepend(usize::MAX).expect("uses capacity");
                                                }

                                                assert!(pointers.iter().copied().eq(expected));
                                            }
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_back_many_elements_can_be_appended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for additional in 1..32 {
                                            for back in 1..32 {
                                                let expected = 0..elements;

                                                let mut actual: Dynamic<_> = expected.clone().collect();

                                                _ = actual.reserve_front(front).expect("successful allocation");
                                                _ = actual.reserve_back(back).expect("successful allocation");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front);
                                                debug_assert_eq!(actual.back_capacity, back);

                                                _ = actual.shift(-isize::try_from(front + additional).expect("too small to wrap")).expect_err("not enough front capacity");

                                                let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                                for _ in 0..back {
                                                    // NOTE: this is distinct from the expected values.
                                                    _ = actual.append(usize::MAX).expect("uses capacity");
                                                }

                                                assert!(pointers.iter().copied().eq(expected));
                                            }
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_both_front_many_elements_can_be_prepended_and_back_many_elements_can_be_appended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for additional in 1..32 {
                                            for back in 1..32 {
                                                let expected = 0..elements;

                                                let mut actual: Dynamic<_> = expected.clone().collect();

                                                _ = actual.reserve_front(front).expect("successful allocation");
                                                _ = actual.reserve_back(back).expect("successful allocation");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front);
                                                debug_assert_eq!(actual.back_capacity, back);

                                                _ = actual.shift(-isize::try_from(front + additional).expect("too small to wrap")).expect_err("not enough front capacity");

                                                let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                                for _ in 0..front {
                                                    // NOTE: this is distinct from the expected values.
                                                    _ = actual.prepend(usize::MAX).expect("uses capacity");
                                                }

                                                for _ in 0..back {
                                                    // NOTE: this is distinct from the expected values.
                                                    _ = actual.append(usize::MAX).expect("uses capacity");
                                                }

                                                assert!(pointers.iter().copied().eq(expected));
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }

                    mod when_front_is_exactly_requested {
                        use super::*;

                        mod when_empty {
                            use super::*;

                            #[test]
                            fn then_front_capacity_is_decreased_to_zero() {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(front + back).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.shift(-isize::try_from(front).expect("too small to wrap")).expect("enough front capacity");

                                        assert_eq!(actual.front_capacity, 0);
                                    }
                                }
                            }

                            #[test]
                            fn then_back_capacity_is_increased_to_sum_with_front() {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(front + back).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.shift(-isize::try_from(front).expect("too small to wrap")).expect("enough front capacity");

                                        assert_eq!(actual.back_capacity, front + back);
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_initialize_elements() {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(front + back).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.shift(-isize::try_from(front).expect("too small to wrap")).expect("enough front capacity");

                                        assert_eq!(actual.initialized, 0);
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_reallocate_memory() {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(front + back).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        let allocation = actual.buffer;

                                        _ = actual.shift(-isize::try_from(front).expect("too small to wrap")).expect("enough front capacity");

                                        assert_eq!(actual.buffer, allocation);
                                    }
                                }
                            }

                            #[test]
                            fn then_back_many_elements_can_be_appended_without_reallocating_memory() {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(front + back).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.shift(-isize::try_from(front).expect("too small to wrap")).expect("enough front capacity");

                                        let allocation = actual.buffer;

                                        for element in 0..(front + back) {
                                            _ = actual.append(element).expect("uses capacity");
                                        }

                                        assert_eq!(actual.buffer, allocation);
                                    }
                                }
                            }
                        }

                        mod when_not_empty {
                            use super::*;

                            #[test]
                            fn then_front_capacity_is_decreased_to_zero() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.shift(-isize::try_from(front).expect("too small to wrap")).expect("enough front capacity");

                                            assert_eq!(actual.front_capacity, 0);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_back_capacity_is_increased_to_sum_with_front() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.shift(-isize::try_from(front).expect("too small to wrap")).expect("enough front capacity");

                                            assert_eq!(actual.back_capacity, front + back);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_modify_initialized_elements() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.shift(-isize::try_from(front).expect("too small to wrap")).expect("enough front capacity");

                                            assert!(actual.eq(expected));
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_reallocate_memory() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            let allocation = actual.buffer;

                                            _ = actual.shift(-isize::try_from(front).expect("too small to wrap")).expect("enough front capacity");

                                            assert_eq!(actual.buffer, allocation);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_back_many_elements_can_be_appended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.shift(-isize::try_from(front).expect("too small to wrap")).expect("enough front capacity");

                                            let allocation = actual.buffer;

                                            for _ in 0..(front + back) {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.append(usize::MAX).expect("uses capacity");
                                            }

                                            assert_eq!(actual.buffer, allocation);
                                        }
                                    }
                                }
                            }
                        }
                    }

                    mod when_front_is_more_than_reqeusted {
                        use super::*;

                        mod when_empty {
                            use super::*;

                            #[test]
                            fn then_front_capacity_is_decreased_by_requested() {
                                for front in 1..32 {
                                    for additional in 1..32 {
                                        for back in 1..32 {
                                            let mut actual = Dynamic::<usize>::default();

                                            _ = actual.reserve_back(front + additional + back).expect("successful allocation");

                                            _ = actual.shift(isize::try_from(front + additional).expect("too small to wrap")).expect("enough back capacity to shift into");

                                            debug_assert_eq!(actual.initialized, 0);
                                            debug_assert_eq!(actual.front_capacity, front + additional);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.shift(-isize::try_from(front).expect("too small to wrap")).expect("enough front capacity");

                                            assert_eq!(actual.front_capacity, additional);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_back_capacity_is_increased_by_requested() {
                                for front in 1..32 {
                                    for additional in 1..32 {
                                        for back in 1..32 {
                                            let mut actual = Dynamic::<usize>::default();

                                            _ = actual.reserve_back(front + additional + back).expect("successful allocation");

                                            _ = actual.shift(isize::try_from(front + additional).expect("too small to wrap")).expect("enough back capacity to shift into");

                                            debug_assert_eq!(actual.initialized, 0);
                                            debug_assert_eq!(actual.front_capacity, front + additional);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.shift(-isize::try_from(front).expect("too small to wrap")).expect("enough front capacity");

                                            assert_eq!(actual.back_capacity, back + front);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_initialize_elements() {
                                for front in 1..32 {
                                    for additional in 1..32 {
                                        for back in 1..32 {
                                            let mut actual = Dynamic::<usize>::default();

                                            _ = actual.reserve_back(front + additional + back).expect("successful allocation");

                                            _ = actual.shift(isize::try_from(front + additional).expect("too small to wrap")).expect("enough back capacity to shift into");

                                            debug_assert_eq!(actual.initialized, 0);
                                            debug_assert_eq!(actual.front_capacity, front + additional);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.shift(-isize::try_from(front).expect("too small to wrap")).expect("enough front capacity");

                                            assert_eq!(actual.initialized, 0);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_reallocate_memory() {
                                for front in 1..32 {
                                    for additional in 1..32 {
                                        for back in 1..32 {
                                            let mut actual = Dynamic::<usize>::default();

                                            _ = actual.reserve_back(front + additional + back).expect("successful allocation");

                                            _ = actual.shift(isize::try_from(front + additional).expect("too small to wrap")).expect("enough back capacity to shift into");

                                            debug_assert_eq!(actual.initialized, 0);
                                            debug_assert_eq!(actual.front_capacity, front + additional);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            let allocation = actual.buffer;

                                            _ = actual.shift(-isize::try_from(front).expect("too small to wrap")).expect("enough front capacity");

                                            assert_eq!(actual.buffer, allocation);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_capacity_many_elements_can_be_prepended_without_reallocating_memory() {
                                for front in 1..32 {
                                    for additional in 1..32 {
                                        for back in 1..32 {
                                            let mut actual = Dynamic::<usize>::default();

                                            _ = actual.reserve_back(front + additional + back).expect("successful allocation");

                                            _ = actual.shift(isize::try_from(front + additional).expect("too small to wrap")).expect("enough back capacity to shift into");

                                            debug_assert_eq!(actual.initialized, 0);
                                            debug_assert_eq!(actual.front_capacity, front + additional);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.shift(-isize::try_from(front).expect("too small to wrap")).expect("enough front capacity");

                                            let allocation = actual.buffer;

                                            for element in 0..(front + additional + back) {
                                                _ = actual.prepend(element).expect("uses capacity");
                                            }

                                            assert_eq!(actual.buffer, allocation);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_capacity_many_elements_can_be_appended_without_reallocating_memory() {
                                for front in 1..32 {
                                    for additional in 1..32 {
                                        for back in 1..32 {
                                            let mut actual = Dynamic::<usize>::default();

                                            _ = actual.reserve_back(front + additional + back).expect("successful allocation");

                                            _ = actual.shift(isize::try_from(front + additional).expect("too small to wrap")).expect("enough back capacity to shift into");

                                            debug_assert_eq!(actual.initialized, 0);
                                            debug_assert_eq!(actual.front_capacity, front + additional);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.shift(-isize::try_from(front).expect("too small to wrap")).expect("enough front capacity");

                                            let allocation = actual.buffer;

                                            for element in 0..(front + additional + back) {
                                                _ = actual.append(element).expect("uses capacity");
                                            }

                                            assert_eq!(actual.buffer, allocation);
                                        }
                                    }
                                }
                            }
                        }

                        mod when_not_empty {
                            use super::*;

                            #[test]
                            fn then_front_capacity_is_decreased_by_requested() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for additional in 1..32 {
                                            for back in 1..32 {
                                                let mut actual: Dynamic<_> = (0..elements).collect();

                                                _ = actual.reserve_front(front + additional).expect("successful allocation");
                                                _ = actual.reserve_back(back).expect("successful allocation");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front + additional);
                                                debug_assert_eq!(actual.back_capacity, back);

                                                _ = actual.shift(-isize::try_from(front).expect("too small to wrap")).expect("enough front capacity");

                                                assert_eq!(actual.front_capacity, additional);
                                            }
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_back_capacity_is_increased_by_requested() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for additional in 1..32 {
                                            for back in 1..32 {
                                                let mut actual: Dynamic<_> = (0..elements).collect();

                                                _ = actual.reserve_front(front + additional).expect("successful allocation");
                                                _ = actual.reserve_back(back).expect("successful allocation");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front + additional);
                                                debug_assert_eq!(actual.back_capacity, back);

                                                _ = actual.shift(-isize::try_from(front).expect("too small to wrap")).expect("enough front capacity");

                                                assert_eq!(actual.back_capacity, back + front);
                                            }
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_modify_initialized_elements() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for additional in 1..32 {
                                            for back in 1..32 {
                                                let expected = 0..elements;

                                                let mut actual: Dynamic<_> = expected.clone().collect();

                                                _ = actual.reserve_front(front + additional).expect("successful allocation");
                                                _ = actual.reserve_back(back).expect("successful allocation");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front + additional);
                                                debug_assert_eq!(actual.back_capacity, back);

                                                _ = actual.shift(-isize::try_from(front).expect("too small to wrap")).expect("enough front capacity");

                                                assert!(actual.eq(expected));
                                            }
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_reallocate_memory() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for additional in 1..32 {
                                            for back in 1..32 {
                                                let mut actual: Dynamic<_> = (0..elements).collect();

                                                _ = actual.reserve_front(front + additional).expect("successful allocation");
                                                _ = actual.reserve_back(back).expect("successful allocation");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front + additional);
                                                debug_assert_eq!(actual.back_capacity, back);

                                                let allocation = actual.buffer;

                                                _ = actual.shift(-isize::try_from(front).expect("too small to wrap")).expect("enough front capacity");

                                                assert_eq!(actual.buffer, allocation);
                                            }
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_front_many_elements_can_be_prepended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for additional in 1..32 {
                                            for back in 1..32 {
                                                let expected = 0..elements;

                                                let mut actual: Dynamic<_> = expected.clone().collect();

                                                _ = actual.reserve_front(front + additional).expect("successful allocation");
                                                _ = actual.reserve_back(back).expect("successful allocation");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front + additional);
                                                debug_assert_eq!(actual.back_capacity, back);

                                                _ = actual.shift(-isize::try_from(front).expect("too small to wrap")).expect("enough front capacity");

                                                let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                                for _ in 0..additional {
                                                    _ = actual.prepend(usize::MAX).expect("uses capacity");
                                                }

                                                assert!(pointers.iter().copied().eq(expected));
                                            }
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_back_many_elements_can_be_appended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for additional in 1..32 {
                                            for back in 1..32 {
                                                let expected = 0..elements;

                                                let mut actual: Dynamic<_> = expected.clone().collect();

                                                _ = actual.reserve_front(front + additional).expect("successful allocation");
                                                _ = actual.reserve_back(back).expect("successful allocation");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front + additional);
                                                debug_assert_eq!(actual.back_capacity, back);

                                                _ = actual.shift(-isize::try_from(front).expect("too small to wrap")).expect("enough front capacity");

                                                let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                                for _ in 0..(back + front) {
                                                    _ = actual.append(usize::MAX).expect("uses capacity");
                                                }

                                                assert!(pointers.iter().copied().eq(expected));
                                            }
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_both_front_many_elements_can_be_prepended_and_back_many_elements_can_be_appended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for additional in 1..32 {
                                            for back in 1..32 {
                                                let expected = 0..elements;

                                                let mut actual: Dynamic<_> = expected.clone().collect();

                                                _ = actual.reserve_front(front + additional).expect("successful allocation");
                                                _ = actual.reserve_back(back).expect("successful allocation");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front + additional);
                                                debug_assert_eq!(actual.back_capacity, back);

                                                _ = actual.shift(-isize::try_from(front).expect("too small to wrap")).expect("enough front capacity");

                                                let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                                for _ in 0..additional {
                                                    _ = actual.prepend(usize::MAX).expect("uses capacity");
                                                }

                                                for _ in 0..(back + front) {
                                                    _ = actual.append(usize::MAX).expect("uses capacity");
                                                }

                                                assert!(pointers.iter().copied().eq(expected));
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                mod when_positive_requested {
                    use super::*;

                    mod when_back_is_less_than_requested {
                        use super::*;

                        mod when_empty {
                            use super::*;

                            #[test]
                            fn then_does_not_modify_front_capacity() {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        for additional in 1..32 {
                                            let mut actual = Dynamic::<usize>::default();

                                            _ = actual.reserve_back(front + back).expect("successful allocation");

                                            _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                            debug_assert_eq!(actual.initialized, 0);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.shift(isize::try_from(back + additional).expect("too small to wrap")).expect_err("not enough back capacity");

                                            assert_eq!(actual.front_capacity, front);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_modify_back_capacity() {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        for additional in 1..32 {
                                            let mut actual = Dynamic::<usize>::default();

                                            _ = actual.reserve_back(front + back).expect("successful allocation");

                                            _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                            debug_assert_eq!(actual.initialized, 0);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.shift(isize::try_from(back + additional).expect("too small to wrap")).expect_err("not enough back capacity");

                                            assert_eq!(actual.back_capacity, back);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_initialize_elements() {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        for additional in 1..32 {
                                            let mut actual = Dynamic::<usize>::default();

                                            _ = actual.reserve_back(front + back).expect("successful allocation");

                                            _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                            debug_assert_eq!(actual.initialized, 0);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.shift(isize::try_from(back + additional).expect("too small to wrap")).expect_err("not enough back capacity");

                                            assert_eq!(actual.initialized, 0);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_reallocate_memory() {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        for additional in 1..32 {
                                            let mut actual = Dynamic::<usize>::default();

                                            _ = actual.reserve_back(front + back).expect("successful allocation");

                                            _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                            debug_assert_eq!(actual.initialized, 0);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            let allocation = actual.buffer;

                                            _ = actual.shift(isize::try_from(back + additional).expect("too small to wrap")).expect_err("not enough back capacity");

                                            assert_eq!(actual.buffer, allocation);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_capacity_many_elements_can_be_prepended_without_reallocating_memory() {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        for additional in 1..32 {
                                            let mut actual = Dynamic::<usize>::default();

                                            _ = actual.reserve_back(front + back).expect("successful allocation");

                                            _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                            debug_assert_eq!(actual.initialized, 0);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.shift(isize::try_from(back + additional).expect("too small to wrap")).expect_err("not enough back capacity");

                                            let allocation = actual.buffer;

                                            for element in 0..(front + back) {
                                                _ = actual.prepend(element).expect("uses capacity");
                                            }

                                            assert_eq!(actual.buffer, allocation);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_capacity_many_elements_can_be_appended_without_reallocating_memory() {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        for additional in 1..32 {
                                            let mut actual = Dynamic::<usize>::default();

                                            _ = actual.reserve_back(front + back).expect("successful allocation");

                                            _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                            debug_assert_eq!(actual.initialized, 0);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.shift(isize::try_from(back + additional).expect("too small to wrap")).expect_err("not enough back capacity");

                                            let allocation = actual.buffer;

                                            for element in 0..(front + back) {
                                                _ = actual.append(element).expect("uses capacity");
                                            }

                                            assert_eq!(actual.buffer, allocation);
                                        }
                                    }
                                }
                            }
                        }

                        mod when_not_empty {
                            use super::*;

                            #[test]
                            fn then_does_not_modify_front_capacity() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            for additional in 1..32 {
                                                let mut actual: Dynamic<_> = (0..elements).collect();

                                                _ = actual.reserve_front(front).expect("successful allocation");
                                                _ = actual.reserve_back(back).expect("successful allocation");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front);
                                                debug_assert_eq!(actual.back_capacity, back);

                                                _ = actual.shift(isize::try_from(back + additional).expect("too small to wrap")).expect_err("not enough back capacity");

                                                assert_eq!(actual.front_capacity, front);
                                            }
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_modify_back_capacity() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            for additional in 1..32 {
                                                let mut actual: Dynamic<_> = (0..elements).collect();

                                                _ = actual.reserve_front(front).expect("successful allocation");
                                                _ = actual.reserve_back(back).expect("successful allocation");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front);
                                                debug_assert_eq!(actual.back_capacity, back);

                                                _ = actual.shift(isize::try_from(back + additional).expect("too small to wrap")).expect_err("not enough back capacity");

                                                assert_eq!(actual.back_capacity, back);
                                            }
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_modify_initialized_elements() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            for additional in 1..32 {
                                                let expected = 0..elements;

                                                let mut actual: Dynamic<_> = expected.clone().collect();

                                                _ = actual.reserve_front(front).expect("successful allocation");
                                                _ = actual.reserve_back(back).expect("successful allocation");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front);
                                                debug_assert_eq!(actual.back_capacity, back);

                                                _ = actual.shift(isize::try_from(back + additional).expect("too small to wrap")).expect_err("not enough back capacity");

                                                assert!(actual.eq(expected));
                                            }
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_reallocate_memory() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            for additional in 1..32 {
                                                let mut actual: Dynamic<_> = (0..elements).collect();

                                                _ = actual.reserve_front(front).expect("successful allocation");
                                                _ = actual.reserve_back(back).expect("successful allocation");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front);
                                                debug_assert_eq!(actual.back_capacity, back);

                                                let allocation = actual.buffer;

                                                _ = actual.shift(isize::try_from(back + additional).expect("too small to wrap")).expect_err("not enough back capacity");

                                                assert_eq!(actual.buffer, allocation);
                                            }
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_front_many_elements_can_be_prepended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            for additional in 1..32 {
                                                let expected = 0..elements;

                                                let mut actual: Dynamic<_> = expected.clone().collect();

                                                _ = actual.reserve_front(front).expect("successful allocation");
                                                _ = actual.reserve_back(back).expect("successful allocation");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front);
                                                debug_assert_eq!(actual.back_capacity, back);

                                                _ = actual.shift(isize::try_from(back + additional).expect("too small to wrap")).expect_err("not enough back capacity");

                                                let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                                for _ in 0..front {
                                                    // NOTE: this is distinct from the expected values.
                                                    _ = actual.prepend(usize::MAX).expect("uses capacity");
                                                }

                                                assert!(pointers.iter().copied().eq(expected));
                                            }
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_back_many_elements_can_be_appended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            for additional in 1..32 {
                                                let expected = 0..elements;

                                                let mut actual: Dynamic<_> = expected.clone().collect();

                                                _ = actual.reserve_front(front).expect("successful allocation");
                                                _ = actual.reserve_back(back).expect("successful allocation");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front);
                                                debug_assert_eq!(actual.back_capacity, back);

                                                _ = actual.shift(isize::try_from(back + additional).expect("too small to wrap")).expect_err("not enough back capacity");

                                                let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                                for _ in 0..back {
                                                    // NOTE: this is distinct from the expected values.
                                                    _ = actual.append(usize::MAX).expect("uses capacity");
                                                }

                                                assert!(pointers.iter().copied().eq(expected));
                                            }
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_both_front_many_elements_can_be_prepended_and_back_many_elements_can_be_appended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            for additional in 1..32 {
                                                let expected = 0..elements;

                                                let mut actual: Dynamic<_> = expected.clone().collect();

                                                _ = actual.reserve_front(front).expect("successful allocation");
                                                _ = actual.reserve_back(back).expect("successful allocation");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front);
                                                debug_assert_eq!(actual.back_capacity, back);

                                                _ = actual.shift(isize::try_from(back + additional).expect("too small to wrap")).expect_err("not enough back capacity");

                                                let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                                for _ in 0..front {
                                                    // NOTE: this is distinct from the expected values.
                                                    _ = actual.prepend(usize::MAX).expect("uses capacity");
                                                }

                                                for _ in 0..back {
                                                    // NOTE: this is distinct from the expected values.
                                                    _ = actual.append(usize::MAX).expect("uses capacity");
                                                }

                                                assert!(pointers.iter().copied().eq(expected));
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }

                    mod when_back_is_exactly_requested {
                        use super::*;

                        mod when_empty {
                            use super::*;

                            #[test]
                            fn then_front_capacity_is_increased_to_sum_with_back() {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(front + back).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.shift(isize::try_from(back).expect("too small to wrap")).expect("enough back capacity");

                                        assert_eq!(actual.front_capacity, front + back);
                                    }
                                }
                            }

                            #[test]
                            fn then_back_capacity_is_decreased_to_zero() {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(front + back).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.shift(isize::try_from(back).expect("too small to wrap")).expect("enough back capacity");

                                        assert_eq!(actual.back_capacity, 0);
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_initialize_elements() {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(front + back).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.shift(isize::try_from(back).expect("too small to wrap")).expect("enough back capacity");

                                        assert_eq!(actual.initialized, 0);
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_reallocate_memory() {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(front + back).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        let allocation = actual.buffer;

                                        _ = actual.shift(isize::try_from(back).expect("too small to wrap")).expect("enough back capacity");

                                        assert_eq!(actual.buffer, allocation);
                                    }
                                }
                            }

                            #[test]
                            fn then_front_many_elements_can_be_prepended_without_reallocating_memory() {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(front + back).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.shift(isize::try_from(back).expect("too small to wrap")).expect("enough back capacity");

                                        let allocation = actual.buffer;

                                        for _ in 0..(front + back) {
                                            // NOTE: this is distinct from the expected values.
                                            _ = actual.prepend(usize::MAX).expect("uses capacity");
                                        }

                                        assert_eq!(actual.buffer, allocation);
                                    }
                                }
                            }
                        }

                        mod when_not_empty {
                            use super::*;

                            #[test]
                            fn then_front_capacity_is_increased_to_sum_with_back() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.shift(isize::try_from(back).expect("too small to wrap")).expect("enough back capacity");

                                            assert_eq!(actual.front_capacity, front + back);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_back_capacity_is_decreased_to_zero() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.shift(isize::try_from(back).expect("too small to wrap")).expect("enough back capacity");

                                            assert_eq!(actual.back_capacity, 0);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_modify_initialized_elements() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.shift(isize::try_from(back).expect("too small to wrap")).expect("enough back capacity");

                                            assert!(actual.eq(expected));
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_reallocate_memory() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            let allocation = actual.buffer;

                                            _ = actual.shift(isize::try_from(back).expect("too small to wrap")).expect("enough back capacity");

                                            assert_eq!(actual.buffer, allocation);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_front_many_elements_can_be_prepended_without_invalidaing_pointers() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.shift(isize::try_from(back).expect("too small to wrap")).expect("enough back capacity");

                                            let allocation = actual.buffer;

                                            for _ in 0..(front + back) {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.prepend(usize::MAX).expect("uses capacity");
                                            }

                                            assert_eq!(actual.buffer, allocation);
                                        }
                                    }
                                }
                            }
                        }
                    }

                    mod when_back_is_more_than_requested {
                        use super::*;

                        mod when_empty {
                            use super::*;

                            #[test]
                            fn then_front_capacity_is_increased_by_requested() {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        for additional in 1..32 {
                                            let mut actual = Dynamic::<usize>::default();

                                            _ = actual.reserve_back(front + back + additional).expect("successful allocation");

                                            _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                            debug_assert_eq!(actual.initialized, 0);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back + additional);

                                            _ = actual.shift(isize::try_from(back).expect("too small to wrap")).expect("enough back capacity");

                                            assert_eq!(actual.front_capacity, front + back);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_back_capacity_is_decreased_by_requested() {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        for additional in 1..32 {
                                            let mut actual = Dynamic::<usize>::default();

                                            _ = actual.reserve_back(front + back + additional).expect("successful allocation");

                                            _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                            debug_assert_eq!(actual.initialized, 0);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back + additional);

                                            _ = actual.shift(isize::try_from(back).expect("too small to wrap")).expect("enough back capacity");

                                            assert_eq!(actual.back_capacity, additional);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_initialize_elements() {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        for additional in 1..32 {
                                            let mut actual = Dynamic::<usize>::default();

                                            _ = actual.reserve_back(front + back + additional).expect("successful allocation");

                                            _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                            debug_assert_eq!(actual.initialized, 0);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back + additional);

                                            _ = actual.shift(isize::try_from(back).expect("too small to wrap")).expect("enough back capacity");

                                            assert_eq!(actual.initialized, 0);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_reallocate_memory() {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        for additional in 1..32 {
                                            let mut actual = Dynamic::<usize>::default();

                                            _ = actual.reserve_back(front + back + additional).expect("successful allocation");

                                            _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                            debug_assert_eq!(actual.initialized, 0);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back + additional);

                                            let allocation = actual.buffer;

                                            _ = actual.shift(isize::try_from(back).expect("too small to wrap")).expect("enough back capacity");

                                            assert_eq!(actual.buffer, allocation);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_capacity_many_elements_can_be_prepended_without_reallocating_memory() {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        for additional in 1..32 {
                                            let mut actual = Dynamic::<usize>::default();

                                            _ = actual.reserve_back(front + back + additional).expect("successful allocation");

                                            _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                            debug_assert_eq!(actual.initialized, 0);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back + additional);

                                            _ = actual.shift(isize::try_from(back).expect("too small to wrap")).expect("enough back capacity");

                                            let allocation = actual.buffer;

                                            for element in 0..(front + back + additional) {
                                                _ = actual.prepend(element).expect("uses capacity");
                                            }

                                            assert_eq!(actual.buffer, allocation);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_capacity_many_elements_can_be_appended_without_reallocating_memory() {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        for additional in 1..32 {
                                            let mut actual = Dynamic::<usize>::default();

                                            _ = actual.reserve_back(front + back + additional).expect("successful allocation");

                                            _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                            debug_assert_eq!(actual.initialized, 0);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back + additional);

                                            _ = actual.shift(isize::try_from(back).expect("too small to wrap")).expect("enough back capacity");

                                            let allocation = actual.buffer;

                                            for element in 0..(front + back + additional) {
                                                _ = actual.append(element).expect("uses capacity");
                                            }

                                            assert_eq!(actual.buffer, allocation);
                                        }
                                    }
                                }
                            }
                        }

                        mod when_not_empty {
                            use super::*;

                            #[test]
                            fn then_front_capacity_is_increased_by_requested() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            for additional in 1..32 {
                                                let mut actual: Dynamic<_> = (0..elements).collect();

                                                _ = actual.reserve_front(front).expect("successful allocation");
                                                _ = actual.reserve_back(back + additional).expect("successful allocation");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front);
                                                debug_assert_eq!(actual.back_capacity, back + additional);

                                                _ = actual.shift(isize::try_from(back).expect("too small to wrap")).expect("enough back capacity");

                                                assert_eq!(actual.front_capacity, front + back);
                                            }
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_back_capacity_is_decreased_by_requested() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            for additional in 1..32 {
                                                let mut actual: Dynamic<_> = (0..elements).collect();

                                                _ = actual.reserve_front(front).expect("successful allocation");
                                                _ = actual.reserve_back(back + additional).expect("successful allocation");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front);
                                                debug_assert_eq!(actual.back_capacity, back + additional);

                                                _ = actual.shift(isize::try_from(back).expect("too small to wrap")).expect("enough back capacity");

                                                assert_eq!(actual.back_capacity, additional);
                                            }
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_modify_initialized_elements() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            for additional in 1..32 {
                                                let expected = 0..elements;

                                                let mut actual: Dynamic<_> = expected.clone().collect();

                                                _ = actual.reserve_front(front).expect("successful allocation");
                                                _ = actual.reserve_back(back + additional).expect("successful allocation");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front);
                                                debug_assert_eq!(actual.back_capacity, back + additional);

                                                _ = actual.shift(isize::try_from(back).expect("too small to wrap")).expect("enough back capacity");

                                                assert!(actual.eq(expected));
                                            }
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_reallocate_memory() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            for additional in 1..32 {
                                                let mut actual: Dynamic<_> = (0..elements).collect();

                                                _ = actual.reserve_front(front).expect("successful allocation");
                                                _ = actual.reserve_back(back + additional).expect("successful allocation");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front);
                                                debug_assert_eq!(actual.back_capacity, back + additional);

                                                let allocation = actual.buffer;

                                                _ = actual.shift(isize::try_from(back).expect("too small to wrap")).expect("enough back capacity");

                                                assert_eq!(actual.buffer, allocation);
                                            }
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_front_many_elements_can_be_prepended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            for additional in 1..32 {
                                                let expected = 0..elements;

                                                let mut actual: Dynamic<_> = expected.clone().collect();

                                                _ = actual.reserve_front(front).expect("successful allocation");
                                                _ = actual.reserve_back(back + additional).expect("successful allocation");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front);
                                                debug_assert_eq!(actual.back_capacity, back + additional);

                                                _ = actual.shift(isize::try_from(back).expect("too small to wrap")).expect("enough back capacity");

                                                let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                                for _ in 0..(front + back) {
                                                    // NOTE: this is distinct from the expected vlaues.
                                                    _ = actual.prepend(usize::MAX).expect("uses capacity");
                                                }

                                                assert!(pointers.iter().copied().eq(expected));
                                            }
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_back_many_elements_can_be_appended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            for additional in 1..32 {
                                                let expected = 0..elements;

                                                let mut actual: Dynamic<_> = expected.clone().collect();

                                                _ = actual.reserve_front(front).expect("successful allocation");
                                                _ = actual.reserve_back(back + additional).expect("successful allocation");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front);
                                                debug_assert_eq!(actual.back_capacity, back + additional);

                                                _ = actual.shift(isize::try_from(back).expect("too small to wrap")).expect("enough back capacity");

                                                let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                                for _ in 0..additional {
                                                    // NOTE: this is distinct from the expected vlaues.
                                                    _ = actual.append(usize::MAX).expect("uses capacity");
                                                }

                                                assert!(pointers.iter().copied().eq(expected));
                                            }
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_both_front_many_elements_can_be_prepended_and_back_many_elements_can_be_appended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            for additional in 1..32 {
                                                let expected = 0..elements;

                                                let mut actual: Dynamic<_> = expected.clone().collect();

                                                _ = actual.reserve_front(front).expect("successful allocation");
                                                _ = actual.reserve_back(back + additional).expect("successful allocation");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front);
                                                debug_assert_eq!(actual.back_capacity, back + additional);

                                                _ = actual.shift(isize::try_from(back).expect("too small to wrap")).expect("enough back capacity");

                                                let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                                for _ in 0..(front + back) {
                                                    // NOTE: this is distinct from the expected vlaues.
                                                    _ = actual.prepend(usize::MAX).expect("uses capacity");
                                                }

                                                for _ in 0..additional {
                                                    // NOTE: this is distinct from the expected vlaues.
                                                    _ = actual.append(usize::MAX).expect("uses capacity");
                                                }

                                                assert!(pointers.iter().copied().eq(expected));
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        mod remove_via_front {
            use super::*;

            mod when_empty {
                use super::*;

                #[test]
                fn then_yields_none() {
                    for requested in 0..32 {
                        for front in 0..32 {
                            for back in 0..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_back(front + back).expect("successful allocation");

                                _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, front);
                                debug_assert_eq!(actual.back_capacity, back);

                                assert_eq!(actual.remove_via_front(requested), None);
                            }
                        }
                    }
                }

                #[test]
                fn then_does_not_modify_capacity() {
                    for requested in 0..32 {
                        for front in 0..32 {
                            for back in 0..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_back(front + back).expect("successful allocation");

                                _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, front);
                                debug_assert_eq!(actual.back_capacity, back);

                                _ = actual.remove_via_front(requested);

                                assert_eq!(actual.capacity(), front + back);
                            }
                        }
                    }
                }

                #[test]
                fn then_does_not_initialize_elements() {
                    for requested in 0..32 {
                        for front in 0..32 {
                            for back in 0..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_back(front + back).expect("successful allocation");

                                _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, front);
                                debug_assert_eq!(actual.back_capacity, back);

                                _ = actual.remove_via_front(requested);

                                assert_eq!(actual.initialized, 0);
                            }
                        }
                    }
                }

                #[test]
                fn then_does_not_reallocate_memory() {
                    for requested in 0..32 {
                        for front in 0..32 {
                            for back in 0..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_back(front + back).expect("successful allocation");

                                _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, front);
                                debug_assert_eq!(actual.back_capacity, back);

                                let allocation = actual.buffer;

                                _ = actual.remove_via_front(requested);

                                assert_eq!(actual.buffer, allocation);
                            }
                        }
                    }
                }

                #[test]
                fn then_capacity_many_elements_can_be_prepended_without_reallocating_memory() {
                    for requested in 0..32 {
                        for front in 0..32 {
                            for back in 0..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_back(front + back).expect("successful allocation");

                                _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, front);
                                debug_assert_eq!(actual.back_capacity, back);

                                _ = actual.remove_via_front(requested);

                                let allocation = actual.buffer;

                                for element in 0..(front + back) {
                                    _ = actual.prepend(element).expect("uses capacity");
                                }

                                assert_eq!(actual.buffer, allocation);
                            }
                        }
                    }
                }
            }

            mod when_not_empty {
                use super::*;

                mod when_index_out_of_bounds {
                    use super::*;

                    #[test]
                    fn then_yields_none() {
                        for elements in 1..32 {
                            for front in 0..32 {
                                for back in 0..32 {
                                    for additional in 0..32 {
                                        let mut actual: Dynamic<_> = (0..elements).collect();

                                        _ = actual.reserve_front(front).expect("successful allocation");
                                        _ = actual.reserve_back(back).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        assert_eq!(actual.remove_via_front(elements + additional), None);
                                    }
                                }
                            }
                        }
                    }

                    #[test]
                    fn then_does_not_modify_front_capacity() {
                        for elements in 1..32 {
                            for front in 0..32 {
                                for back in 0..32 {
                                    for additional in 0..32 {
                                        let mut actual: Dynamic<_> = (0..elements).collect();

                                        _ = actual.reserve_front(front).expect("successful allocation");
                                        _ = actual.reserve_back(back).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.remove_via_front(elements + additional);

                                        assert_eq!(actual.front_capacity, front);
                                    }
                                }
                            }
                        }
                    }

                    #[test]
                    fn then_does_not_modify_back_capacity() {
                        for elements in 1..32 {
                            for front in 0..32 {
                                for back in 0..32 {
                                    for additional in 0..32 {
                                        let mut actual: Dynamic<_> = (0..elements).collect();

                                        _ = actual.reserve_front(front).expect("successful allocation");
                                        _ = actual.reserve_back(back).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.remove_via_front(elements + additional);

                                        assert_eq!(actual.back_capacity, back);
                                    }
                                }
                            }
                        }
                    }

                    #[test]
                    fn then_does_not_modify_initialized_elements() {
                        for elements in 1..32 {
                            for front in 0..32 {
                                for back in 0..32 {
                                    for additional in 0..32 {
                                        let expected = 0..elements;

                                        let mut actual: Dynamic<_> = expected.clone().collect();

                                        _ = actual.reserve_front(front).expect("successful allocation");
                                        _ = actual.reserve_back(back).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.remove_via_front(elements + additional);

                                        assert!(actual.eq(expected));
                                    }
                                }
                            }
                        }
                    }

                    #[test]
                    fn then_does_not_reallocate_memory() {
                        for elements in 1..32 {
                            for front in 0..32 {
                                for back in 0..32 {
                                    for additional in 0..32 {
                                        let mut actual: Dynamic<_> = (0..elements).collect();

                                        _ = actual.reserve_front(front).expect("successful allocation");
                                        _ = actual.reserve_back(back).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        let allocation = actual.buffer;

                                        _ = actual.remove_via_front(elements + additional);

                                        assert_eq!(actual.buffer, allocation);
                                    }
                                }
                            }
                        }
                    }

                    #[test]
                    fn then_front_many_elements_can_be_prepended_without_invalidating_pointers() {
                        for elements in 1..32 {
                            for front in 0..32 {
                                for back in 0..32 {
                                    for additional in 0..32 {
                                        let expected = 0..elements;

                                        let mut actual: Dynamic<_> = expected.clone().collect();

                                        _ = actual.reserve_front(front).expect("successful allocation");
                                        _ = actual.reserve_back(back).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.remove_via_front(elements + additional);

                                        let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                        for _ in 0..front {
                                            // NOTE: this is distinct from the expected values.
                                            _ = actual.prepend(usize::MAX).expect("uses capacity");
                                        }

                                        assert!(pointers.iter().copied().eq(expected));
                                    }
                                }
                            }
                        }
                    }

                    #[test]
                    fn then_back_many_elements_can_be_appended_without_invalidating_pointers() {
                        for elements in 1..32 {
                            for front in 0..32 {
                                for back in 0..32 {
                                    for additional in 0..32 {
                                        let expected = 0..elements;

                                        let mut actual: Dynamic<_> = expected.clone().collect();

                                        _ = actual.reserve_front(front).expect("successful allocation");
                                        _ = actual.reserve_back(back).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.remove_via_front(elements + additional);

                                        let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                        for _ in 0..back {
                                            // NOTE: this is distinct from the expected values.
                                            _ = actual.append(usize::MAX).expect("uses capacity");
                                        }

                                        assert!(pointers.iter().copied().eq(expected));
                                    }
                                }
                            }
                        }
                    }

                    #[test]
                    fn then_both_front_many_elements_can_be_prepended_and_back_many_elements_can_be_appended_without_invalidating_pointers() {
                        for elements in 1..32 {
                            for front in 0..32 {
                                for back in 0..32 {
                                    for additional in 0..32 {
                                        let expected = 0..elements;

                                        let mut actual: Dynamic<_> = expected.clone().collect();

                                        _ = actual.reserve_front(front).expect("successful allocation");
                                        _ = actual.reserve_back(back).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.remove_via_front(elements + additional);

                                        let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                        for _ in 0..front {
                                            // NOTE: this is distinct from the expected values.
                                            _ = actual.prepend(usize::MAX).expect("uses capacity");
                                        }

                                        for _ in 0..back {
                                            // NOTE: this is distinct from the expected values.
                                            _ = actual.append(usize::MAX).expect("uses capacity");
                                        }

                                        assert!(pointers.iter().copied().eq(expected));
                                    }
                                }
                            }
                        }
                    }
                }

                mod when_index_within_bounds {
                    use super::*;

                    mod when_only_one_element {
                        use super::*;

                        #[test]
                        fn then_yields_the_element() {
                            for element in 1..32 {
                                for front in 0..32 {
                                    for back in 0..32 {
                                        let mut actual: Dynamic<_> = core::iter::once(element).collect();

                                        _ = actual.reserve_front(front).expect("successful allocation");
                                        _ = actual.reserve_back(back).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, 1);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        assert_eq!(actual.remove_via_front(0), Some(element));
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_increases_capacity_by_one() {
                            for element in 1..32 {
                                for front in 0..32 {
                                    for back in 0..32 {
                                        let mut actual: Dynamic<_> = core::iter::once(element).collect();

                                        _ = actual.reserve_front(front).expect("successful allocation");
                                        _ = actual.reserve_back(back).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, 1);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.remove_via_front(0);

                                        assert_eq!(actual.capacity(), front + back + 1);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_is_empty() {
                            for element in 1..32 {
                                for front in 0..32 {
                                    for back in 0..32 {
                                        let mut actual: Dynamic<_> = core::iter::once(element).collect();

                                        _ = actual.reserve_front(front).expect("successful allocation");
                                        _ = actual.reserve_back(back).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, 1);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.remove_via_front(0);

                                        assert_eq!(actual.initialized, 0);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_reallocate_memory() {
                            for element in 1..32 {
                                for front in 0..32 {
                                    for back in 0..32 {
                                        let mut actual: Dynamic<_> = core::iter::once(element).collect();

                                        _ = actual.reserve_front(front).expect("successful allocation");
                                        _ = actual.reserve_back(back).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, 1);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        let allocation = actual.buffer;

                                        _ = actual.remove_via_front(0);

                                        assert_eq!(actual.buffer, allocation);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_capacity_many_elements_can_be_prepended_without_reallocating_memory() {
                            for element in 1..32 {
                                for front in 0..32 {
                                    for back in 0..32 {
                                        let mut actual: Dynamic<_> = core::iter::once(element).collect();

                                        _ = actual.reserve_front(front).expect("successful allocation");
                                        _ = actual.reserve_back(back).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, 1);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.remove_via_front(0);

                                        let allocation = actual.buffer;

                                        #[expect(clippy::range_plus_one, reason = "the removed element")]
                                        for _ in 0..(front + back + 1) {
                                            _ = actual.append(usize::MAX).expect("uses capacity");
                                        }

                                        assert_eq!(actual.buffer, allocation);
                                    }
                                }
                            }
                        }
                    }

                    mod when_more_than_one_element {
                        use super::*;

                        mod when_requested_is_first_element {
                            use super::*;

                            #[test]
                            fn then_yields_the_element() {
                                for value_offset in 0..32 {
                                    for elements in 1..32 {
                                        for front in 0..32 {
                                            for back in 0..32 {
                                                let mut actual: Dynamic<_> = (value_offset..(value_offset + elements)).collect();

                                                _ = actual.reserve_front(front).expect("successful allocation");
                                                _ = actual.reserve_back(back).expect("successful allocation");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front);
                                                debug_assert_eq!(actual.back_capacity, back);

                                                assert_eq!(actual.remove_via_front(0), Some(value_offset));
                                            }
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_increases_front_capacity_by_one() {
                                for elements in 1..32 {
                                    for front in 0..32 {
                                        for back in 0..32 {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.remove_via_front(0);

                                            assert_eq!(actual.front_capacity, front + 1);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_modfiy_back_capacity() {
                                for elements in 1..32 {
                                    for front in 0..32 {
                                        for back in 0..32 {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.remove_via_front(0);

                                            assert_eq!(actual.back_capacity, back);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_decreases_initialized_by_one() {
                                for elements in 1..32 {
                                    for front in 0..32 {
                                        for back in 0..32 {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.remove_via_front(0);

                                            assert_eq!(actual.initialized, elements - 1);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_reallocate_memory() {
                                for elements in 1..32 {
                                    for front in 0..32 {
                                        for back in 0..32 {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            let allocation = actual.buffer;

                                            _ = actual.remove_via_front(0);

                                            assert_eq!(actual.buffer, allocation);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_modify_remaining_elements() {
                                for elements in 1..32 {
                                    for front in 0..32 {
                                        for back in 0..32 {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.remove_via_front(0);

                                            assert!(actual.eq(1..elements));
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_invalidate_pointers_to_remaining_elements() {
                                for elements in 1..32 {
                                    for front in 0..32 {
                                        for back in 0..32 {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            #[expect(clippy::multiple_unsafe_ops_per_block, reason = "pointer offset")]
                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr().add(1), elements - 1) };

                                            _ = actual.remove_via_front(0);

                                            assert!(pointers.iter().copied().eq(1..elements));
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_front_many_elements_can_be_prepended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for front in 0..32 {
                                        for back in 0..32 {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.remove_via_front(0);

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements - 1) };

                                            #[expect(clippy::range_plus_one, reason = "the one removed element")]
                                            for _ in 0..(front + 1) {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.prepend(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(1..elements));
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_back_many_elements_can_be_appended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for front in 0..32 {
                                        for back in 0..32 {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.remove_via_front(0);

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements - 1) };

                                            for _ in 0..back {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.append(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(1..elements));
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_both_front_many_elements_can_be_prepended_back_many_elements_can_be_appended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for front in 0..32 {
                                        for back in 0..32 {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.remove_via_front(0);

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements - 1) };

                                            #[expect(clippy::range_plus_one, reason = "the one removed element")]
                                            for _ in 0..(front + 1) {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.prepend(usize::MAX).expect("uses capacity");
                                            }

                                            for _ in 0..back {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.append(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(1..elements));
                                        }
                                    }
                                }
                            }
                        }

                        mod when_requested_is_not_first_element {
                            use super::*;

                            #[test]
                            fn then_yields_the_element() {
                                for value_offset in 0..16 {
                                    for elements in 2..16 {
                                        for front in 0..16 {
                                            for back in 0..16 {
                                                for removing in 1..elements {
                                                    let mut actual: Dynamic<_> = (value_offset..(value_offset + elements)).collect();

                                                    _ = actual.reserve_front(front).expect("successful allocation");
                                                    _ = actual.reserve_back(back).expect("successful allocation");

                                                    debug_assert_eq!(actual.initialized, elements);
                                                    debug_assert_eq!(actual.front_capacity, front);
                                                    debug_assert_eq!(actual.back_capacity, back);

                                                    assert_eq!(actual.remove_via_front(removing), Some(value_offset + removing));
                                                }
                                            }
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_increases_front_capacitry_by_one() {
                                for elements in 2..32 {
                                    for front in 0..32 {
                                        for back in 0..32 {
                                            for removing in 1..elements {
                                                let mut actual: Dynamic<_> = (0..elements).collect();

                                                _ = actual.reserve_front(front).expect("successful allocation");
                                                _ = actual.reserve_back(back).expect("successful allocation");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front);
                                                debug_assert_eq!(actual.back_capacity, back);

                                                _ = actual.remove_via_front(removing);

                                                assert_eq!(actual.front_capacity, front + 1);
                                            }
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_modify_back_capacity() {
                                for elements in 2..32 {
                                    for front in 0..32 {
                                        for back in 0..32 {
                                            for removing in 1..elements {
                                                let mut actual: Dynamic<_> = (0..elements).collect();

                                                _ = actual.reserve_front(front).expect("successful allocation");
                                                _ = actual.reserve_back(back).expect("successful allocation");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front);
                                                debug_assert_eq!(actual.back_capacity, back);

                                                _ = actual.remove_via_front(removing);

                                                assert_eq!(actual.back_capacity, back);
                                            }
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_decreases_initialized_by_one() {
                                for elements in 2..32 {
                                    for front in 0..32 {
                                        for back in 0..32 {
                                            for removing in 1..elements {
                                                let mut actual: Dynamic<_> = (0..elements).collect();

                                                _ = actual.reserve_front(front).expect("successful allocation");
                                                _ = actual.reserve_back(back).expect("successful allocation");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front);
                                                debug_assert_eq!(actual.back_capacity, back);

                                                _ = actual.remove_via_front(removing);

                                                assert_eq!(actual.initialized, elements - 1);
                                            }
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_reallocate_memory() {
                                for elements in 2..32 {
                                    for front in 0..32 {
                                        for back in 0..32 {
                                            for removing in 1..elements {
                                                let mut actual: Dynamic<_> = (0..elements).collect();

                                                _ = actual.reserve_front(front).expect("successful allocation");
                                                _ = actual.reserve_back(back).expect("successful allocation");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front);
                                                debug_assert_eq!(actual.back_capacity, back);

                                                let allocation = actual.buffer;

                                                _ = actual.remove_via_front(removing);

                                                assert_eq!(actual.buffer, allocation);
                                            }
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_places_the_first_element_into_position_of_the_removed_element() {
                                for value_offset in 0..16 {
                                    for elements in 2..16 {
                                        for front in 0..16 {
                                            for back in 0..16 {
                                                for removing in 1..elements {
                                                    let mut actual: Dynamic<_> = (value_offset..(value_offset + elements)).collect();

                                                    _ = actual.reserve_front(front).expect("successful allocation");
                                                    _ = actual.reserve_back(back).expect("successful allocation");

                                                    debug_assert_eq!(actual.initialized, elements);
                                                    debug_assert_eq!(actual.front_capacity, front);
                                                    debug_assert_eq!(actual.back_capacity, back);

                                                    _ = actual.remove_via_front(removing);

                                                    assert_eq!(actual[removing - 1], value_offset);
                                                }
                                            }
                                        }
                                    }
                                }



                            }

                            #[test]
                            fn then_does_not_modify_leading_remaining_elements() {
                                for elements in 2..32 {
                                    for front in 0..32 {
                                        for back in 0..32 {
                                            for removing in 1..elements {
                                                let mut actual: Dynamic<_> = (0..elements).collect();

                                                _ = actual.reserve_front(front).expect("successful allocation");
                                                _ = actual.reserve_back(back).expect("successful allocation");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front);
                                                debug_assert_eq!(actual.back_capacity, back);

                                                _ = actual.remove_via_front(removing);

                                                assert!(actual.as_slice()[..(removing - 1)].iter().copied().eq(1..removing));
                                            }
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_invalidate_pointers_to_leading_remaining_elements() {
                                for elements in 2..32 {
                                    for front in 0..32 {
                                        for back in 0..32 {
                                            for removing in 1..elements {
                                                let mut actual: Dynamic<_> = (0..elements).collect();

                                                _ = actual.reserve_front(front).expect("successful allocation");
                                                _ = actual.reserve_back(back).expect("successful allocation");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front);
                                                debug_assert_eq!(actual.back_capacity, back);

                                                #[expect(clippy::multiple_unsafe_ops_per_block, reason = "pointer offset")]
                                                let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr().add(1), removing - 1) };

                                                _ = actual.remove_via_front(removing);

                                                assert!(pointers.iter().copied().eq(1..removing));
                                            }
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_modify_trailing_remaining_elements() {
                                for elements in 2..32 {
                                    for front in 0..32 {
                                        for back in 0..32 {
                                            for removing in 1..elements {
                                                let mut actual: Dynamic<_> = (0..elements).collect();

                                                _ = actual.reserve_front(front).expect("successful allocation");
                                                _ = actual.reserve_back(back).expect("successful allocation");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front);
                                                debug_assert_eq!(actual.back_capacity, back);

                                                _ = actual.remove_via_front(removing);

                                                assert!(actual.as_slice()[removing..].iter().copied().eq((removing + 1)..elements));
                                            }
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_invalidate_pointers_to_trailing_remaining_elements() {
                                for elements in 2..32 {
                                    for front in 0..32 {
                                        for back in 0..32 {
                                            for removing in 1..elements {
                                                let mut actual: Dynamic<_> = (0..elements).collect();

                                                _ = actual.reserve_front(front).expect("successful allocation");
                                                _ = actual.reserve_back(back).expect("successful allocation");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front);
                                                debug_assert_eq!(actual.back_capacity, back);

                                                #[expect(clippy::multiple_unsafe_ops_per_block, reason = "pointer offset")]
                                                let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr().add(removing + 1), elements - removing - 1) };

                                                _ = actual.remove_via_front(removing);

                                                assert!(pointers.iter().copied().eq((removing + 1)..elements));
                                            }
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_front_many_elements_can_be_prepended_without_invalidating_pointers() {
                                for elements in 2..32 {
                                    for front in 0..32 {
                                        for back in 0..32 {
                                            for removing in 1..elements {
                                                let mut actual: Dynamic<_> = (0..elements).collect();

                                                _ = actual.reserve_front(front).expect("successful allocation");
                                                _ = actual.reserve_back(back).expect("successful allocation");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front);
                                                debug_assert_eq!(actual.back_capacity, back);

                                                _ = actual.remove_via_front(removing);

                                                let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements - 1) };

                                                #[expect(clippy::range_plus_one, reason = "the one removed element")]
                                                for _ in 0..(front + 1) {
                                                    // NOTE: this is distinct from the expected values.
                                                    _ = actual.prepend(usize::MAX).expect("uses capacity");
                                                }

                                                assert!(pointers.iter().copied().eq((1..removing).chain(core::iter::once(0)).chain((removing + 1)..elements)));
                                            }
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_back_many_elements_can_be_appended_without_invalidating_pointers() {
                                for elements in 2..32 {
                                    for front in 0..32 {
                                        for back in 0..32 {
                                            for removing in 1..elements {
                                                let mut actual: Dynamic<_> = (0..elements).collect();

                                                _ = actual.reserve_front(front).expect("successful allocation");
                                                _ = actual.reserve_back(back).expect("successful allocation");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front);
                                                debug_assert_eq!(actual.back_capacity, back);

                                                _ = actual.remove_via_front(removing);

                                                let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements - 1) };

                                                for _ in 0..back {
                                                    // NOTE: this is distinct from the expected values.
                                                    _ = actual.append(usize::MAX).expect("uses capacity");
                                                }

                                                assert!(pointers.iter().copied().eq((1..removing).chain(core::iter::once(0)).chain((removing + 1)..elements)));
                                            }
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_both_front_many_elements_can_be_prepended_an_back_many_elements_can_be_appended_without_invalidating_pointers() {
                                for elements in 2..32 {
                                    for front in 0..32 {
                                        for back in 0..32 {
                                            for removing in 1..elements {
                                                let mut actual: Dynamic<_> = (0..elements).collect();

                                                _ = actual.reserve_front(front).expect("successful allocation");
                                                _ = actual.reserve_back(back).expect("successful allocation");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front);
                                                debug_assert_eq!(actual.back_capacity, back);

                                                _ = actual.remove_via_front(removing);

                                                let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements - 1) };

                                                #[expect(clippy::range_plus_one, reason = "the one removed element")]
                                                for _ in 0..(front + 1) {
                                                    // NOTE: this is distinct from the expected values.
                                                    _ = actual.prepend(usize::MAX).expect("uses capacity");
                                                }

                                                for _ in 0..back {
                                                    // NOTE: this is distinct from the expected values.
                                                    _ = actual.append(usize::MAX).expect("uses capacity");
                                                }

                                                assert!(pointers.iter().copied().eq((1..removing).chain(core::iter::once(0)).chain((removing + 1)..elements)));
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        mod remove_via_back {
            use super::*;

            mod when_empty {
                use super::*;

                #[test]
                fn then_yields_none() {
                    for requested in 0..32 {
                        for front in 0..32 {
                            for back in 0..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_back(front + back).expect("successful allocation");

                                _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, front);
                                debug_assert_eq!(actual.back_capacity, back);

                                assert_eq!(actual.remove_via_back(requested), None);
                            }
                        }
                    }
                }

                #[test]
                fn then_does_not_modify_capacity() {
                    for requested in 0..32 {
                        for front in 0..32 {
                            for back in 0..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_back(front + back).expect("successful allocation");

                                _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, front);
                                debug_assert_eq!(actual.back_capacity, back);

                                _ = actual.remove_via_back(requested);

                                assert_eq!(actual.capacity(), front + back);
                            }
                        }
                    }
                }

                #[test]
                fn then_does_not_initialize_elements() {
                    for requested in 0..32 {
                        for front in 0..32 {
                            for back in 0..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_back(front + back).expect("successful allocation");

                                _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, front);
                                debug_assert_eq!(actual.back_capacity, back);

                                _ = actual.remove_via_back(requested);

                                assert_eq!(actual.initialized, 0);
                            }
                        }
                    }
                }

                #[test]
                fn then_does_not_reallocate_memory() {
                    for requested in 0..32 {
                        for front in 0..32 {
                            for back in 0..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_back(front + back).expect("successful allocation");

                                _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, front);
                                debug_assert_eq!(actual.back_capacity, back);

                                let allocation = actual.buffer;

                                _ = actual.remove_via_back(requested);

                                assert_eq!(actual.buffer, allocation);
                            }
                        }
                    }
                }

                #[test]
                fn then_capacity_many_elements_can_be_appended_without_reallocating_memory() {
                    for requested in 0..32 {
                        for front in 0..32 {
                            for back in 0..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_back(front + back).expect("successful allocation");

                                _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, front);
                                debug_assert_eq!(actual.back_capacity, back);

                                _ = actual.remove_via_back(requested);

                                let allocation = actual.buffer;

                                for element in 0..(front + back) {
                                    _ = actual.append(element).expect("uses capacity");
                                }

                                assert_eq!(actual.buffer, allocation);
                            }
                        }
                    }
                }
            }

            mod when_not_empty {
                use super::*;

                mod when_index_out_of_bounds {
                    use super::*;

                    #[test]
                    fn then_yields_none() {
                        for elements in 1..32 {
                            for front in 0..32 {
                                for back in 0..32 {
                                    for additional in 0..32 {
                                        let mut actual: Dynamic<_> = (0..elements).collect();

                                        _ = actual.reserve_front(front).expect("successful allocation");
                                        _ = actual.reserve_back(back).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        assert_eq!(actual.remove_via_back(elements + additional), None);
                                    }
                                }
                            }
                        }
                    }

                    #[test]
                    fn then_does_not_modify_front_capacity() {
                        for elements in 1..32 {
                            for front in 0..32 {
                                for back in 0..32 {
                                    for additional in 0..32 {
                                        let mut actual: Dynamic<_> = (0..elements).collect();

                                        _ = actual.reserve_front(front).expect("successful allocation");
                                        _ = actual.reserve_back(back).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.remove_via_back(elements + additional);

                                        assert_eq!(actual.front_capacity, front);
                                    }
                                }
                            }
                        }
                    }

                    #[test]
                    fn then_does_not_modify_back_capacity() {
                        for elements in 1..32 {
                            for front in 0..32 {
                                for back in 0..32 {
                                    for additional in 0..32 {
                                        let mut actual: Dynamic<_> = (0..elements).collect();

                                        _ = actual.reserve_front(front).expect("successful allocation");
                                        _ = actual.reserve_back(back).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.remove_via_back(elements + additional);

                                        assert_eq!(actual.back_capacity, back);
                                    }
                                }
                            }
                        }
                    }

                    #[test]
                    fn then_does_not_modify_initialized_elements() {
                        for elements in 1..32 {
                            for front in 0..32 {
                                for back in 0..32 {
                                    for additional in 0..32 {
                                        let expected = 0..elements;

                                        let mut actual: Dynamic<_> = expected.clone().collect();

                                        _ = actual.reserve_front(front).expect("successful allocation");
                                        _ = actual.reserve_back(back).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.remove_via_back(elements + additional);

                                        assert!(actual.eq(expected));
                                    }
                                }
                            }
                        }
                    }

                    #[test]
                    fn then_does_not_reallocate_memory() {
                        for elements in 1..32 {
                            for front in 0..32 {
                                for back in 0..32 {
                                    for additional in 0..32 {
                                        let mut actual: Dynamic<_> = (0..elements).collect();

                                        _ = actual.reserve_front(front).expect("successful allocation");
                                        _ = actual.reserve_back(back).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        let allocation = actual.buffer;

                                        _ = actual.remove_via_back(elements + additional);

                                        assert_eq!(actual.buffer, allocation);
                                    }
                                }
                            }
                        }
                    }

                    #[test]
                    fn then_front_many_elements_can_be_prepended_without_invalidating_pointers() {
                        for elements in 1..32 {
                            for front in 0..32 {
                                for back in 0..32 {
                                    for additional in 0..32 {
                                        let expected = 0..elements;

                                        let mut actual: Dynamic<_> = expected.clone().collect();

                                        _ = actual.reserve_front(front).expect("successful allocation");
                                        _ = actual.reserve_back(back).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.remove_via_back(elements + additional);

                                        let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                        for _ in 0..front {
                                            // NOTE: this is distinct from the expected values.
                                            _ = actual.prepend(usize::MAX).expect("uses capacity");
                                        }

                                        assert!(pointers.iter().copied().eq(expected));
                                    }
                                }
                            }
                        }
                    }

                    #[test]
                    fn then_back_many_elements_can_be_appended_without_invalidating_pointers() {
                        for elements in 1..32 {
                            for front in 0..32 {
                                for back in 0..32 {
                                    for additional in 0..32 {
                                        let expected = 0..elements;

                                        let mut actual: Dynamic<_> = expected.clone().collect();

                                        _ = actual.reserve_front(front).expect("successful allocation");
                                        _ = actual.reserve_back(back).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.remove_via_back(elements + additional);

                                        let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                        for _ in 0..back {
                                            // NOTE: this is distinct from the expected values.
                                            _ = actual.append(usize::MAX).expect("uses capacity");
                                        }

                                        assert!(pointers.iter().copied().eq(expected));
                                    }
                                }
                            }
                        }
                    }

                    #[test]
                    fn then_both_front_many_elements_can_be_prepended_and_back_many_elements_can_be_appended_without_invalidating_pointers() {
                        for elements in 1..32 {
                            for front in 0..32 {
                                for back in 0..32 {
                                    for additional in 0..32 {
                                        let expected = 0..elements;

                                        let mut actual: Dynamic<_> = expected.clone().collect();

                                        _ = actual.reserve_front(front).expect("successful allocation");
                                        _ = actual.reserve_back(back).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.remove_via_back(elements + additional);

                                        let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                        for _ in 0..front {
                                            // NOTE: this is distinct from the expected values.
                                            _ = actual.prepend(usize::MAX).expect("uses capacity");
                                        }

                                        for _ in 0..back {
                                            // NOTE: this is distinct from the expected values.
                                            _ = actual.append(usize::MAX).expect("uses capacity");
                                        }

                                        assert!(pointers.iter().copied().eq(expected));
                                    }
                                }
                            }
                        }
                    }
                }

                mod when_index_within_bounds {
                    use super::*;

                    mod when_only_one_element {
                        use super::*;

                        #[test]
                        fn then_yields_the_element() {
                            for element in 1..32 {
                                for front in 0..32 {
                                    for back in 0..32 {
                                        let mut actual: Dynamic<_> = core::iter::once(element).collect();

                                        _ = actual.reserve_front(front).expect("successful allocation");
                                        _ = actual.reserve_back(back).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, 1);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        assert_eq!(actual.remove_via_back(0), Some(element));
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_increases_capacity_by_one() {
                            for element in 1..32 {
                                for front in 0..32 {
                                    for back in 0..32 {
                                        let mut actual: Dynamic<_> = core::iter::once(element).collect();

                                        _ = actual.reserve_front(front).expect("successful allocation");
                                        _ = actual.reserve_back(back).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, 1);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.remove_via_back(0);

                                        assert_eq!(actual.capacity(), front + back + 1);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_is_empty() {
                            for element in 1..32 {
                                for front in 0..32 {
                                    for back in 0..32 {
                                        let mut actual: Dynamic<_> = core::iter::once(element).collect();

                                        _ = actual.reserve_front(front).expect("successful allocation");
                                        _ = actual.reserve_back(back).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, 1);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.remove_via_back(0);

                                        assert_eq!(actual.initialized, 0);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_reallocate_memory() {
                            for element in 1..32 {
                                for front in 0..32 {
                                    for back in 0..32 {
                                        let mut actual: Dynamic<_> = core::iter::once(element).collect();

                                        _ = actual.reserve_front(front).expect("successful allocation");
                                        _ = actual.reserve_back(back).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, 1);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        let allocation = actual.buffer;

                                        _ = actual.remove_via_back(0);

                                        assert_eq!(actual.buffer, allocation);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_capacity_many_elements_can_be_prepended_without_reallocating_memory() {
                            for element in 1..32 {
                                for front in 0..32 {
                                    for back in 0..32 {
                                        let mut actual: Dynamic<_> = core::iter::once(element).collect();

                                        _ = actual.reserve_front(front).expect("successful allocation");
                                        _ = actual.reserve_back(back).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, 1);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.remove_via_back(0);

                                        let allocation = actual.buffer;

                                        #[expect(clippy::range_plus_one, reason = "the removed element")]
                                        for _ in 0..(front + back + 1) {
                                            _ = actual.append(usize::MAX).expect("uses capacity");
                                        }

                                        assert_eq!(actual.buffer, allocation);
                                    }
                                }
                            }
                        }
                    }

                    mod when_more_than_one_element {
                        use super::*;

                        mod when_requested_is_last_element {
                            use super::*;

                            #[test]
                            fn then_yields_the_element() {
                                for value_offset in 0..32 {
                                    for elements in 1..32 {
                                        for front in 0..32 {
                                            for back in 0..32 {
                                                let mut actual: Dynamic<_> = (value_offset..(value_offset + elements)).collect();

                                                _ = actual.reserve_front(front).expect("successful allocation");
                                                _ = actual.reserve_back(back).expect("successful allocation");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front);
                                                debug_assert_eq!(actual.back_capacity, back);

                                                assert_eq!(actual.remove_via_front(elements - 1), Some(value_offset + elements - 1));
                                            }
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_modify_front_capacity() {
                                for elements in 1..32 {
                                    for front in 0..32 {
                                        for back in 0..32 {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.remove_via_back(elements - 1);

                                            assert_eq!(actual.front_capacity, front);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_increases_back_capacity_by_one() {
                                for elements in 1..32 {
                                    for front in 0..32 {
                                        for back in 0..32 {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.remove_via_back(elements - 1);

                                            assert_eq!(actual.back_capacity, back + 1);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_decreases_initialized_by_one() {
                                for elements in 1..32 {
                                    for front in 0..32 {
                                        for back in 0..32 {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.remove_via_back(elements - 1);

                                            assert_eq!(actual.initialized, elements - 1);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_reallocate_memory() {
                                for elements in 1..32 {
                                    for front in 0..32 {
                                        for back in 0..32 {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            let allocation = actual.buffer;

                                            _ = actual.remove_via_back(elements - 1);

                                            assert_eq!(actual.buffer, allocation);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_modify_remaining_elements() {
                                for elements in 1..32 {
                                    for front in 0..32 {
                                        for back in 0..32 {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.remove_via_back(elements - 1);

                                            assert!(actual.eq(0..(elements - 1)));
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_invalidate_pointers_to_remaining_elements() {
                                for elements in 1..32 {
                                    for front in 0..32 {
                                        for back in 0..32 {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements - 1) };

                                            _ = actual.remove_via_back(elements - 1);

                                            assert!(pointers.iter().copied().eq(0..(elements - 1)));
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_front_many_elements_can_be_prepended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for front in 0..32 {
                                        for back in 0..32 {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.remove_via_back(elements - 1);

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements - 1) };

                                            for _ in 0..front {
                                                _ = actual.prepend(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(0..(elements - 1)));
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_back_many_elements_can_be_appended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for front in 0..32 {
                                        for back in 0..32 {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.remove_via_back(elements - 1);

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements - 1) };

                                            #[expect(clippy::range_plus_one, reason = "the removed element")]
                                            for _ in 0..(back + 1) {
                                                _ = actual.append(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(0..(elements - 1)));
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_both_front_many_elements_can_be_prepended_and_back_many_elements_can_be_appended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for front in 0..32 {
                                        for back in 0..32 {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.remove_via_back(elements - 1);

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements - 1) };


                                            for _ in 0..front {
                                                _ = actual.prepend(usize::MAX).expect("uses capacity");
                                            }

                                            #[expect(clippy::range_plus_one, reason = "the removed element")]
                                            for _ in 0..(back + 1) {
                                                _ = actual.append(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(0..(elements - 1)));
                                        }
                                    }
                                }
                            }
                        }

                        mod when_requested_is_not_last_element {
                            use super::*;

                            #[test]
                            fn then_yields_the_element() {
                                for value_offset in 0..16 {
                                    for elements in 2..16 {
                                        for front in 0..16 {
                                            for back in 0..16 {
                                                for removing in 0..(elements - 1) {
                                                    let mut actual: Dynamic<_> = (value_offset..(value_offset + elements)).collect();

                                                    _ = actual.reserve_front(front).expect("successful allocation");
                                                    _ = actual.reserve_back(back).expect("successful allocation");

                                                    debug_assert_eq!(actual.initialized, elements);
                                                    debug_assert_eq!(actual.front_capacity, front);
                                                    debug_assert_eq!(actual.back_capacity, back);

                                                    assert_eq!(actual.remove_via_back(removing), Some(value_offset + removing));
                                                }
                                            }
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_modify_front_capacity() {
                                for elements in 2..32 {
                                    for front in 0..32 {
                                        for back in 0..32 {
                                            for removing in 0..(elements - 1) {
                                                let mut actual: Dynamic<_> = (0..elements).collect();

                                                _ = actual.reserve_front(front).expect("successful allocation");
                                                _ = actual.reserve_back(back).expect("successful allocation");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front);
                                                debug_assert_eq!(actual.back_capacity, back);

                                                _ = actual.remove_via_back(removing);

                                                assert_eq!(actual.front_capacity, front);
                                            }
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_increases_back_capacity_by_one() {
                                for elements in 2..32 {
                                    for front in 0..32 {
                                        for back in 0..32 {
                                            for removing in 0..(elements - 1) {
                                                let mut actual: Dynamic<_> = (0..elements).collect();

                                                _ = actual.reserve_front(front).expect("successful allocation");
                                                _ = actual.reserve_back(back).expect("successful allocation");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front);
                                                debug_assert_eq!(actual.back_capacity, back);

                                                _ = actual.remove_via_back(removing);

                                                assert_eq!(actual.back_capacity, back + 1);
                                            }
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_decreases_initialized_by_one() {
                                for elements in 2..32 {
                                    for front in 0..32 {
                                        for back in 0..32 {
                                            for removing in 0..(elements - 1) {
                                                let mut actual: Dynamic<_> = (0..elements).collect();

                                                _ = actual.reserve_front(front).expect("successful allocation");
                                                _ = actual.reserve_back(back).expect("successful allocation");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front);
                                                debug_assert_eq!(actual.back_capacity, back);

                                                _ = actual.remove_via_back(removing);

                                                assert_eq!(actual.initialized, elements - 1);
                                            }
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_reallocate_memory() {
                                for elements in 2..32 {
                                    for front in 0..32 {
                                        for back in 0..32 {
                                            for removing in 0..(elements - 1) {
                                                let mut actual: Dynamic<_> = (0..elements).collect();

                                                _ = actual.reserve_front(front).expect("successful allocation");
                                                _ = actual.reserve_back(back).expect("successful allocation");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front);
                                                debug_assert_eq!(actual.back_capacity, back);

                                                let allocation = actual.buffer;

                                                _ = actual.remove_via_back(removing);

                                                assert_eq!(actual.buffer, allocation);
                                            }
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_places_the_last_element_into_position_of_the_removed_element() {
                                for value_offset in 0..16 {
                                    for elements in 2..16 {
                                        for front in 0..16 {
                                            for back in 0..16 {
                                                for removing in 0..(elements - 1) {
                                                    let mut actual: Dynamic<_> = (value_offset..(value_offset + elements)).collect();

                                                    _ = actual.reserve_front(front).expect("successful allocation");
                                                    _ = actual.reserve_back(back).expect("successful allocation");

                                                    debug_assert_eq!(actual.initialized, elements);
                                                    debug_assert_eq!(actual.front_capacity, front);
                                                    debug_assert_eq!(actual.back_capacity, back);

                                                    _ = actual.remove_via_back(removing);

                                                    assert_eq!(actual[removing], value_offset + elements - 1);
                                                }
                                            }
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_modify_leading_remaining_elements() {
                                for elements in 2..32 {
                                    for front in 0..32 {
                                        for back in 0..32 {
                                            for removing in 0..(elements - 1) {
                                                let mut actual: Dynamic<_> = (0..elements).collect();

                                                _ = actual.reserve_front(front).expect("successful allocation");
                                                _ = actual.reserve_back(back).expect("successful allocation");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front);
                                                debug_assert_eq!(actual.back_capacity, back);

                                                _ = actual.remove_via_back(removing);

                                                assert!(actual.as_slice()[..removing].iter().copied().eq(0..removing));
                                            }
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_invalidate_pointers_to_leading_remaining_elements() {
                                for elements in 2..32 {
                                    for front in 0..32 {
                                        for back in 0..32 {
                                            for removing in 0..(elements - 1) {
                                                let mut actual: Dynamic<_> = (0..elements).collect();

                                                _ = actual.reserve_front(front).expect("successful allocation");
                                                _ = actual.reserve_back(back).expect("successful allocation");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front);
                                                debug_assert_eq!(actual.back_capacity, back);


                                                let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), removing) };

                                                _ = actual.remove_via_back(removing);

                                                assert!(pointers.iter().copied().eq(0..removing));
                                            }
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_modify_trailing_remaining_elements() {
                                for elements in 2..32 {
                                    for front in 0..32 {
                                        for back in 0..32 {
                                            for removing in 0..(elements - 1) {
                                                let mut actual: Dynamic<_> = (0..elements).collect();

                                                _ = actual.reserve_front(front).expect("successful allocation");
                                                _ = actual.reserve_back(back).expect("successful allocation");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front);
                                                debug_assert_eq!(actual.back_capacity, back);

                                                _ = actual.remove_via_back(removing);

                                                assert!(actual.as_slice()[(removing + 1)..].iter().copied().eq((removing + 1)..(elements - 1)));
                                            }
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_invalidate_pointers_to_trailing_remaining_elements() {
                                for elements in 2..32 {
                                    for front in 0..32 {
                                        for back in 0..32 {
                                            for removing in 0..(elements - 1) {
                                                let mut actual: Dynamic<_> = (0..elements).collect();

                                                _ = actual.reserve_front(front).expect("successful allocation");
                                                _ = actual.reserve_back(back).expect("successful allocation");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front);
                                                debug_assert_eq!(actual.back_capacity, back);

                                                #[expect(clippy::multiple_unsafe_ops_per_block, reason = "pointer offset")]
                                                let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr().add(removing + 1), elements - removing - 2) };

                                                _ = actual.remove_via_back(removing);

                                                assert!(pointers.iter().copied().eq((removing + 1)..(elements - 1)));
                                            }
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_front_many_elements_can_be_prepended_without_invalidating_pointers() {
                                for elements in 2..32 {
                                    for front in 0..32 {
                                        for back in 0..32 {
                                            for removing in 0..(elements - 1) {
                                                let mut actual: Dynamic<_> = (0..elements).collect();

                                                _ = actual.reserve_front(front).expect("successful allocation");
                                                _ = actual.reserve_back(back).expect("successful allocation");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front);
                                                debug_assert_eq!(actual.back_capacity, back);

                                                _ = actual.remove_via_back(removing);

                                                let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements - 1) };

                                                for _ in 0..front {
                                                    // NOTE: this is distinct from the expected values.
                                                    _ = actual.prepend(usize::MAX).expect("uses capacity");
                                                }

                                                assert!(pointers.iter().copied().eq((0..removing).chain(core::iter::once(elements - 1)).chain((removing + 1)..(elements - 1))));
                                            }
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_back_many_elements_can_be_appended_without_invalidating_pointers() {
                                for elements in 2..32 {
                                    for front in 0..32 {
                                        for back in 0..32 {
                                            for removing in 0..(elements - 1) {
                                                let mut actual: Dynamic<_> = (0..elements).collect();

                                                _ = actual.reserve_front(front).expect("successful allocation");
                                                _ = actual.reserve_back(back).expect("successful allocation");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front);
                                                debug_assert_eq!(actual.back_capacity, back);

                                                _ = actual.remove_via_back(removing);

                                                let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements - 1) };

                                                #[expect(clippy::range_plus_one, reason = "the one removed element")]
                                                for _ in 0..(back + 1) {
                                                    // NOTE: this is distinct from the expected values.
                                                    _ = actual.append(usize::MAX).expect("uses capacity");
                                                }

                                                assert!(pointers.iter().copied().eq((0..removing).chain(core::iter::once(elements - 1)).chain((removing + 1)..(elements - 1))));
                                            }
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_both_front_many_elements_can_be_prepended_and_back_many_elements_can_be_appended_without_invalidating_pointers() {
                                for elements in 2..32 {
                                    for front in 0..32 {
                                        for back in 0..32 {
                                            for removing in 0..(elements - 1) {
                                                let mut actual: Dynamic<_> = (0..elements).collect();

                                                _ = actual.reserve_front(front).expect("successful allocation");
                                                _ = actual.reserve_back(back).expect("successful allocation");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front);
                                                debug_assert_eq!(actual.back_capacity, back);

                                                _ = actual.remove_via_back(removing);

                                                let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements - 1) };

                                                for _ in 0..front {
                                                    // NOTE: this is distinct from the expected values.
                                                    _ = actual.prepend(usize::MAX).expect("uses capacity");
                                                }

                                                #[expect(clippy::range_plus_one, reason = "the one removed element")]
                                                for _ in 0..(back + 1) {
                                                    // NOTE: this is distinct from the expected values.
                                                    _ = actual.append(usize::MAX).expect("uses capacity");
                                                }

                                                assert!(pointers.iter().copied().eq((0..removing).chain(core::iter::once(elements - 1)).chain((removing + 1)..(elements - 1))));
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        mod resize {
            use super::*;

            mod when_no_capacity {
                use super::*;

                mod when_zero_requested {
                    use super::*;

                    mod when_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_capacity() {
                            let mut actual = Dynamic::<usize>::default();

                            debug_assert_eq!(actual.initialized, 0);
                            debug_assert_eq!(actual.front_capacity, 0);
                            debug_assert_eq!(actual.back_capacity, 0);

                            _ = actual.resize(0).expect("does nothing");

                            assert_eq!(actual.capacity(), 0);
                        }

                        #[test]
                        fn then_does_not_initialize_elements() {
                            let mut actual = Dynamic::<usize>::default();

                            debug_assert_eq!(actual.initialized, 0);
                            debug_assert_eq!(actual.front_capacity, 0);
                            debug_assert_eq!(actual.back_capacity, 0);

                            _ = actual.resize(0).expect("does nothing");

                            assert_eq!(actual.initialized, 0);
                        }
                    }

                    mod when_not_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_front_capacity() {
                            for elements in 1..32 {
                                let mut actual: Dynamic<_> = (0..elements).collect();

                                debug_assert_eq!(actual.initialized, elements);
                                debug_assert_eq!(actual.front_capacity, 0);
                                debug_assert_eq!(actual.back_capacity, 0);

                                _ = actual.resize(0).expect("does nothing");

                                assert_eq!(actual.front_capacity, 0);
                            }
                        }

                        #[test]
                        fn then_does_not_modify_back_capacity() {
                            for elements in 1..32 {
                                let mut actual: Dynamic<_> = (0..elements).collect();

                                debug_assert_eq!(actual.initialized, elements);
                                debug_assert_eq!(actual.front_capacity, 0);
                                debug_assert_eq!(actual.back_capacity, 0);

                                _ = actual.resize(0).expect("does nothing");

                                assert_eq!(actual.front_capacity, 0);
                            }
                        }

                        #[test]
                        fn then_does_not_modify_initialized_elements() {
                            for elements in 1..32 {
                                let expected = 0..elements;

                                let mut actual: Dynamic<_> = expected.clone().collect();

                                debug_assert_eq!(actual.initialized, elements);
                                debug_assert_eq!(actual.front_capacity, 0);
                                debug_assert_eq!(actual.back_capacity, 0);

                                _ = actual.resize(0).expect("does nothing");

                                assert!(actual.eq(expected));
                            }
                        }

                        #[test]
                        fn then_does_not_reallocate_memory() {
                            for elements in 1..32 {
                                let mut actual: Dynamic<_> = (0..elements).collect();

                                debug_assert_eq!(actual.initialized, elements);
                                debug_assert_eq!(actual.front_capacity, 0);
                                debug_assert_eq!(actual.back_capacity, 0);

                                let allocation = actual.buffer;

                                _ = actual.resize(0).expect("does nothing");

                                assert_eq!(actual.buffer, allocation);
                            }
                        }
                    }
                }

                mod when_negative_requested {
                    use super::*;

                    mod when_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_capacity() {
                            for requested in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, 0);
                                debug_assert_eq!(actual.back_capacity, 0);

                                _ = actual.resize(-requested).expect_err("not enough capacity");

                                assert_eq!(actual.capacity(), 0);
                            }
                        }

                        #[test]
                        fn then_does_not_initialize_elements() {
                            for requested in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, 0);
                                debug_assert_eq!(actual.back_capacity, 0);

                                _ = actual.resize(-requested).expect_err("not enough capacity");

                                assert_eq!(actual.initialized, 0);
                            }
                        }
                    }

                    mod when_not_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_front_capacity() {
                            for elements in 1..32 {
                                for requested in 1..32 {
                                    let mut actual: Dynamic<_> = (0..elements).collect();

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.resize(-requested).expect_err("not enough capacity");

                                    assert_eq!(actual.front_capacity, 0);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_back_capacity() {
                            for elements in 1..32 {
                                for requested in 1..32 {
                                    let mut actual: Dynamic<_> = (0..elements).collect();

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.resize(-requested).expect_err("not enough capacity");

                                    assert_eq!(actual.back_capacity, 0);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_initialized_elements() {
                            for elements in 1..32 {
                                for requested in 1..32 {
                                    let expected = 0..elements;

                                    let mut actual: Dynamic<_> = expected.clone().collect();

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.resize(-requested).expect_err("not enough capacity");

                                    assert!(actual.eq(expected));
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_reallocate_memory() {
                            for elements in 1..32 {
                                for requested in 1..32 {
                                    let mut actual: Dynamic<_> = (0..elements).collect();

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    let allocation = actual.buffer;

                                    _ = actual.resize(-requested).expect_err("not enough capacity");

                                    assert_eq!(actual.buffer, allocation);
                                }
                            }
                        }
                    }
                }

                mod when_positive_requested {
                    use super::*;

                    mod when_empty {
                        use super::*;

                        #[test]
                        fn when_zero_size_type_then_can_allocate_maximum_possible_amount() {
                            let mut actual = Dynamic::<()>::default();

                            debug_assert_eq!(actual.initialized, 0);
                            debug_assert_eq!(actual.front_capacity, 0);
                            debug_assert_eq!(actual.back_capacity, 0);

                            _ = actual.resize(isize::MAX).expect("successful allocation");

                            assert_eq!(actual.capacity(), isize::MAX as usize);
                        }

                        #[test]
                        fn then_increases_capacity_to_requested() {
                            for requested in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, 0);
                                debug_assert_eq!(actual.back_capacity, 0);

                                _ = actual.resize(isize::try_from(requested).expect("too small to wrap")).expect("successful allocation");

                                assert_eq!(actual.capacity(), requested);
                            }
                        }

                        #[test]
                        fn then_does_not_initialize_elements() {
                            for requested in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, 0);
                                debug_assert_eq!(actual.back_capacity, 0);

                                _ = actual.resize(requested).expect("successful allocation");

                                assert_eq!(actual.initialized, 0);
                            }
                        }

                        #[test]
                        fn then_requested_many_elements_can_be_appended_without_reallocating_memory() {
                            for requested in 1..32 {
                                let mut actual = Dynamic::<isize>::default();

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, 0);
                                debug_assert_eq!(actual.back_capacity, 0);

                                _ = actual.resize(requested).expect("successful allocation");

                                let allocation = actual.buffer;

                                for element in 0..requested {
                                    _ = actual.append(element).expect("uses capacity");
                                }

                                assert_eq!(actual.buffer, allocation);
                            }
                        }
                    }

                    mod when_not_empty {
                        use super::*;

                        #[test]
                        fn when_zero_size_type_then_can_allocate_maximum_possible_amount() {
                            for elements in 1..32 {
                                let mut actual: Dynamic<_> = core::iter::repeat_n((), elements).collect();

                                debug_assert_eq!(actual.initialized, elements);
                                debug_assert_eq!(actual.front_capacity, 0);
                                debug_assert_eq!(actual.back_capacity, 0);

                                _ = actual.resize(isize::MAX - isize::try_from(elements).expect("positive value")).expect("successful allocation");

                                assert_eq!(actual.capacity(), isize::MAX as usize - elements);
                            }
                        }

                        #[test]
                        fn then_does_not_modify_front_capacity() {
                            for elements in 1..32 {
                                for requested in 1..32 {
                                    let mut actual: Dynamic<_> = (0..elements).collect();

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.resize(requested).expect("successful allocation");

                                    assert_eq!(actual.front_capacity, 0);
                                }
                            }
                        }

                        #[test]
                        fn then_increases_back_capacity_by_requested() {
                            for elements in 1..32 {
                                for requested in 1..32 {
                                    let mut actual: Dynamic<_> = (0..elements).collect();

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.resize(isize::try_from(requested).expect("too small to wrap")).expect("successful reallocation");

                                    assert_eq!(actual.back_capacity, requested);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_initialized_elements() {
                            for elements in 1..32 {
                                for requested in 1..32 {
                                    let expected = 0..elements;

                                    let mut actual: Dynamic<_> = expected.clone().collect();

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.resize(requested).expect("successful allocation");

                                    assert!(actual.eq(expected));
                                }
                            }
                        }

                        #[test]
                        fn then_requested_many_elements_can_be_appended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for requested in 1..32 {
                                    let expected = 0..elements;

                                    let mut actual: Dynamic<_> = expected.clone().collect();

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.resize(requested).expect("successful allocation");

                                    let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                    for _ in 0..requested {
                                        // NOTE: this is distinct from the expected values.
                                        _ = actual.append(usize::MAX).expect("uses capacity");
                                    }

                                    assert!(pointers.iter().copied().eq(expected));
                                }
                            }
                        }
                    }
                }
            }

            mod when_only_front_capacity {
                use super::*;

                mod when_zero_requested {
                    use super::*;

                    mod when_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_capacity() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_front(capacity).expect("successful allocation");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, capacity);
                                debug_assert_eq!(actual.back_capacity, 0);

                                _ = actual.resize(0).expect("does nothing");

                                assert_eq!(actual.capacity(), capacity);
                            }
                        }

                        #[test]
                        fn then_does_not_initialize_elements() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_front(capacity).expect("successful allocation");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, capacity);
                                debug_assert_eq!(actual.back_capacity, 0);

                                _ = actual.resize(0).expect("does nothing");

                                assert_eq!(actual.initialized, 0);
                            }
                        }

                        #[test]
                        fn then_does_not_reallocate_memory() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_front(capacity).expect("successful allocation");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, capacity);
                                debug_assert_eq!(actual.back_capacity, 0);

                                let allocation = actual.buffer;

                                _ = actual.resize(0).expect("does nothing");

                                assert_eq!(actual.buffer, allocation);
                            }
                        }

                        #[test]
                        fn then_capacity_many_elements_can_be_appended_without_reallocating_memory() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_front(capacity).expect("successful allocation");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, capacity);
                                debug_assert_eq!(actual.back_capacity, 0);

                                _ = actual.resize(0).expect("does nothing");

                                let allocation = actual.buffer;

                                for elements in 0..capacity {
                                    _ = actual.append(elements).expect("uses capacity");
                                }

                                assert_eq!(actual.buffer, allocation);
                            }
                        }
                    }

                    mod when_not_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_front_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let mut actual: Dynamic<_> = (0..elements).collect();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.resize(0).expect("does nothing");

                                    assert_eq!(actual.front_capacity, capacity);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_back_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let mut actual: Dynamic<_> = (0..elements).collect();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.resize(0).expect("does nothing");

                                    assert_eq!(actual.back_capacity, 0);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_initialized_elements() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let expected = 0..elements;

                                    let mut actual: Dynamic<_> = expected.clone().collect();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.resize(0).expect("does nothing");

                                    assert!(actual.eq(expected));
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_reallocate_memory() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let mut actual: Dynamic<_> = (0..elements).collect();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    let allocation = actual.buffer;

                                    _ = actual.resize(0).expect("does nothing");

                                    assert_eq!(actual.buffer, allocation);
                                }
                            }
                        }

                        #[test]
                        fn then_capacity_many_elements_can_be_prepended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let expected = 0..elements;

                                    let mut actual: Dynamic<_> = expected.clone().collect();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.resize(0).expect("does nothing");

                                    let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                    for _ in 0..capacity {
                                        // NOTE: this is distinct from the expected values.
                                        _ = actual.prepend(usize::MAX).expect("uses capacity");
                                    }

                                    assert!(pointers.iter().copied().eq(expected));
                                }
                            }
                        }
                    }
                }

                mod when_negative_requested {
                    use super::*;

                    mod when_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_capacity() {
                            for capacity in 1..32 {
                                for requested in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.resize(-isize::try_from(requested).expect("too small to wrap")).expect_err("not enough back capacity");

                                    assert_eq!(actual.capacity(), capacity);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_initialize_elements() {
                            for capacity in 1..32 {
                                for requested in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.resize(-isize::try_from(requested).expect("too small to wrap")).expect_err("not enough back capacity");

                                    assert_eq!(actual.initialized, 0);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_reallocate_memory() {
                            for capacity in 1..32 {
                                for requested in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    let allocation = actual.buffer;

                                    _ = actual.resize(-isize::try_from(requested).expect("too small to wrap")).expect_err("not enough back capacity");

                                    assert_eq!(actual.buffer, allocation);
                                }
                            }
                        }

                        #[test]
                        fn then_capacity_many_elements_can_be_appended_without_reallocating_memory() {
                            for capacity in 1..32 {
                                for requested in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.resize(-isize::try_from(requested).expect("too small to wrap")).expect_err("not enough back capacity");

                                    let allocation = actual.buffer;

                                    for element in 0..capacity {
                                        _ = actual.append(element).expect("uses capacity");
                                    }

                                    assert_eq!(actual.buffer, allocation);
                                }
                            }
                        }
                    }

                    mod when_not_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_front_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for requested in 1..32 {
                                        let mut actual: Dynamic<_> = (0..elements).collect();

                                        _ = actual.reserve_front(capacity).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, capacity);
                                        debug_assert_eq!(actual.back_capacity, 0);

                                        _ = actual.resize(-isize::try_from(requested).expect("too small to wrap")).expect_err("not enough back capacity");

                                        assert_eq!(actual.front_capacity, capacity);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_back_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for requested in 1..32 {
                                        let mut actual: Dynamic<_> = (0..elements).collect();

                                        _ = actual.reserve_front(capacity).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, capacity);
                                        debug_assert_eq!(actual.back_capacity, 0);

                                        _ = actual.resize(-isize::try_from(requested).expect("too small to wrap")).expect_err("not enough back capacity");

                                        assert_eq!(actual.back_capacity, 0);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_initialized_elements() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for requested in 1..32 {
                                        let expected = 0..elements;

                                        let mut actual: Dynamic<_> = expected.clone().collect();

                                        _ = actual.reserve_front(capacity).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, capacity);
                                        debug_assert_eq!(actual.back_capacity, 0);

                                        _ = actual.resize(-isize::try_from(requested).expect("too small to wrap")).expect_err("not enough back capacity");

                                        assert!(actual.eq(expected));
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_reallocate_memory() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for requested in 1..32 {
                                        let mut actual: Dynamic<_> = (0..elements).collect();

                                        _ = actual.reserve_front(capacity).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, capacity);
                                        debug_assert_eq!(actual.back_capacity, 0);

                                        let allocation = actual.buffer;

                                        _ = actual.resize(-isize::try_from(requested).expect("too small to wrap")).expect_err("not enough back capacity");

                                        assert_eq!(actual.buffer, allocation);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_capacity_many_elements_can_be_prepended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for requested in 1..32 {
                                        let expected = 0..elements;

                                        let mut actual: Dynamic<_> = expected.clone().collect();

                                        _ = actual.reserve_front(capacity).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, capacity);
                                        debug_assert_eq!(actual.back_capacity, 0);

                                        _ = actual.resize(-isize::try_from(requested).expect("too small to wrap")).expect_err("not enough back capacity");

                                        let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                        for _ in 0..capacity {
                                            // NOTE: this is distinct from the expected values.
                                            _ = actual.prepend(usize::MAX).expect("uses capacity");
                                        }

                                        assert!(pointers.iter().copied().eq(expected));
                                    }
                                }
                            }
                        }
                    }
                }

                mod when_positive_requested {
                    use super::*;

                    mod when_empty {
                        use super::*;

                        #[test]
                        fn when_zero_size_type_then_can_allocate_maximum_possible_amount() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<()>::default();

                                _ = actual.reserve_front(capacity).expect("successful allocation");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, capacity);
                                debug_assert_eq!(actual.back_capacity, 0);

                                _ = actual.resize(isize::MAX - isize::try_from(capacity).expect("too small to wrap")).expect("successful reallocation");

                                assert_eq!(actual.capacity(), isize::MAX as usize);
                            }
                        }

                        #[test]
                        fn then_increases_capacity_by_requested() {
                            for front in 1..32 {
                                for back in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_front(front).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, front);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.resize(isize::try_from(back).expect("too small to wrap")).expect("successful reallocation");

                                    assert_eq!(actual.capacity(), front + back);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_initialize_elements() {
                            for front in 1..32 {
                                for back in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_front(front).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, front);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.resize(isize::try_from(back).expect("too small to wrap")).expect("successful reallocation");

                                    assert_eq!(actual.initialized, 0);
                                }
                            }
                        }

                        #[test]
                        fn then_capacity_many_elements_can_be_prepended_without_reallocating_memory() {
                            for front in 1..32 {
                                for back in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_front(front).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, front);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.resize(isize::try_from(back).expect("too small to wrap")).expect("successful reallocation");

                                    let allocation = actual.buffer;

                                    for element in 0..(front + back) {
                                        _ = actual.append(element).expect("uses capacity");
                                    }

                                    assert_eq!(actual.buffer, allocation);
                                }
                            }
                        }
                    }

                    mod when_not_empty {
                        use super::*;

                        #[test]
                        fn when_zero_size_type_then_can_allocate_maximum_possible_amount() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let mut actual: Dynamic<_> = core::iter::repeat_n((), elements).collect();

                                    _ = actual.reserve_front(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, capacity);
                                    debug_assert_eq!(actual.back_capacity, 0);

                                    _ = actual.resize(isize::MAX - isize::try_from(capacity + elements).expect("too small to wrap")).expect("successful reallocation");

                                    assert_eq!(actual.capacity(), isize::MAX as usize - elements);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_front_capacity() {
                            for elements in 1..32 {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        let mut actual: Dynamic<_> = (0..elements).collect();

                                        _ = actual.reserve_front(front).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, 0);

                                        _ = actual.resize(isize::try_from(back).expect("too small to wrap")).expect("successful reallocation");

                                        assert_eq!(actual.front_capacity, front);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_increases_back_capacity_by_requested() {
                            for elements in 1..32 {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        let mut actual: Dynamic<_> = (0..elements).collect();

                                        _ = actual.reserve_front(front).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, 0);

                                        _ = actual.resize(isize::try_from(back).expect("too small to wrap")).expect("successful reallocation");

                                        assert_eq!(actual.back_capacity, back);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_initialized_elements() {
                            for elements in 1..32 {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        let expected = 0..elements;

                                        let mut actual: Dynamic<_> = expected.clone().collect();

                                        _ = actual.reserve_front(front).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, 0);

                                        _ = actual.resize(isize::try_from(back).expect("too small to wrap")).expect("successful reallocation");

                                        assert!(actual.eq(expected));
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_front_many_elements_can_be_prepended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        let expected = 0..elements;

                                        let mut actual: Dynamic<_> = expected.clone().collect();

                                        _ = actual.reserve_front(front).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, 0);

                                        _ = actual.resize(isize::try_from(back).expect("too small to wrap")).expect("successful reallocation");

                                        let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                        for _ in 0..front {
                                            // NOTE: this is distinct from the expected values.
                                            _ = actual.prepend(usize::MAX).expect("uses capacity");
                                        }

                                        assert!(pointers.iter().copied().eq(expected));
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_back_many_elements_can_be_appended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        let expected = 0..elements;

                                        let mut actual: Dynamic<_> = expected.clone().collect();

                                        _ = actual.reserve_front(front).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, 0);

                                        _ = actual.resize(isize::try_from(back).expect("too small to wrap")).expect("successful reallocation");

                                        let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                        for _ in 0..back {
                                            // NOTE: this is distinct from the expected values.
                                            _ = actual.append(usize::MAX).expect("uses capacity");
                                        }

                                        assert!(pointers.iter().copied().eq(expected));
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_both_front_many_elements_can_be_prepended_and_back_many_elements_can_be_appended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        let expected = 0..elements;

                                        let mut actual: Dynamic<_> = expected.clone().collect();

                                        _ = actual.reserve_front(front).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, 0);

                                        _ = actual.resize(isize::try_from(back).expect("too small to wrap")).expect("successful reallocation");

                                        let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                        for _ in 0..front {
                                            // NOTE: this is distinct from the expected values.
                                            _ = actual.prepend(usize::MAX).expect("uses capacity");
                                        }

                                        for _ in 0..back {
                                            // NOTE: this is distinct from the expected values.
                                            _ = actual.append(usize::MAX).expect("uses capacity");
                                        }

                                        assert!(pointers.iter().copied().eq(expected));
                                    }
                                }
                            }
                        }
                    }
                }
            }

            mod when_only_back_capacity {
                use super::*;

                mod when_zero_requested {
                    use super::*;

                    mod when_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_capacity() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_back(capacity).expect("successful allocation");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, 0);
                                debug_assert_eq!(actual.back_capacity, capacity);

                                _ = actual.resize(0).expect("does nothing");

                                assert_eq!(actual.capacity(), capacity);
                            }
                        }

                        #[test]
                        fn then_does_not_initialize_elements() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_back(capacity).expect("successful allocation");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, 0);
                                debug_assert_eq!(actual.back_capacity, capacity);

                                _ = actual.resize(0).expect("does nothing");

                                assert_eq!(actual.initialized, 0);
                            }
                        }

                        #[test]
                        fn then_does_not_reallocate_memory() {
                            for capacity in 1..32 {
                                let mut actual = Dynamic::<usize>::default();

                                _ = actual.reserve_back(capacity).expect("successful allocation");

                                debug_assert_eq!(actual.initialized, 0);
                                debug_assert_eq!(actual.front_capacity, 0);
                                debug_assert_eq!(actual.back_capacity, capacity);

                                let allocation = actual.buffer;

                                _ = actual.resize(0).expect("does nothing");

                                assert_eq!(actual.buffer, allocation);
                            }
                        }
                    }

                    mod when_not_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_front_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let mut actual: Dynamic<_> = (0..elements).collect();

                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    _ = actual.resize(0).expect("does nothing");

                                    assert_eq!(actual.front_capacity, 0);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_back_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let mut actual: Dynamic<_> = (0..elements).collect();

                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    _ = actual.resize(0).expect("does nothing");

                                    assert_eq!(actual.back_capacity, capacity);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_initialized_elements() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let expected = 0..elements;

                                    let mut actual: Dynamic<_> = expected.clone().collect();

                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    _ = actual.resize(0).expect("does nothing");

                                    assert!(actual.eq(expected));
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_reallocate_memory() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let mut actual: Dynamic<_> = (0..elements).collect();

                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    let allocation = actual.buffer;

                                    _ = actual.resize(0).expect("does nothing");

                                    assert_eq!(actual.buffer, allocation);
                                }
                            }
                        }

                        #[test]
                        fn then_capacity_many_elements_can_be_appended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    let expected = 0..elements;

                                    let mut actual: Dynamic<_> = expected.clone().collect();

                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, elements);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    _ = actual.resize(0).expect("does nothing");

                                    let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                    for _ in 0..capacity {
                                        // NOTE: this is distinct from the expected values.
                                        _ = actual.append(usize::MAX).expect("uses capacity");
                                    }

                                    assert!(pointers.iter().copied().eq(expected));
                                }
                            }
                        }
                    }
                }

                mod when_negative_requested {
                    use super::*;

                    mod when_less_than_capacity {
                        use super::*;

                        mod when_empty {
                            use super::*;

                            #[test]
                            fn then_decreases_capacity_by_requested() {
                                for capacity in 1..32 {
                                    for additional in 1..capacity {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(capacity).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, 0);
                                        debug_assert_eq!(actual.back_capacity, capacity);

                                        _ = actual.resize(-isize::try_from(additional).expect("too small to wrap")).expect("succssful reallocation");

                                        assert_eq!(actual.capacity(), capacity - additional);
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_initialize_elements() {
                                for capacity in 1..32 {
                                    for additional in 1..capacity {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(capacity).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, 0);
                                        debug_assert_eq!(actual.back_capacity, capacity);

                                        _ = actual.resize(-isize::try_from(additional).expect("too small to wrap")).expect("succssful reallocation");

                                        assert_eq!(actual.initialized, 0);
                                    }
                                }
                            }

                            #[test]
                            fn then_capacity_many_elements_can_be_appended_without_reallocating_memory() {
                                for capacity in 1..32 {
                                    for additional in 1..capacity {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(capacity).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, 0);
                                        debug_assert_eq!(actual.back_capacity, capacity);

                                        _ = actual.resize(-isize::try_from(additional).expect("too small to wrap")).expect("succssful reallocation");

                                        let allocation = actual.buffer;

                                        for element in 0..(capacity - additional) {
                                            _ = actual.append(element).expect("uses capacity");
                                        }

                                        assert_eq!(actual.buffer, allocation);
                                    }
                                }
                            }
                        }

                        mod when_not_empty {
                            use super::*;

                            #[test]
                            fn then_does_not_modify_front_capacity() {
                                for elements in 1..32 {
                                    for capacity in 1..32 {
                                        for additional in 1..capacity {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_back(capacity).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, 0);
                                            debug_assert_eq!(actual.back_capacity, capacity);

                                            _ = actual.resize(-isize::try_from(additional).expect("too small to wrap")).expect("succssful reallocation");

                                            assert_eq!(actual.front_capacity, 0);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_decreases_back_capacity_by_requested() {
                                for elements in 1..32 {
                                    for capacity in 1..32 {
                                        for additional in 1..capacity {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_back(capacity).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, 0);
                                            debug_assert_eq!(actual.back_capacity, capacity);

                                            _ = actual.resize(-isize::try_from(additional).expect("too small to wrap")).expect("succssful reallocation");

                                            assert_eq!(actual.back_capacity, capacity - additional);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_modify_initialized_elements() {
                                for elements in 1..32 {
                                    for capacity in 1..32 {
                                        for additional in 1..capacity {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_back(capacity).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, 0);
                                            debug_assert_eq!(actual.back_capacity, capacity);

                                            _ = actual.resize(-isize::try_from(additional).expect("too small to wrap")).expect("succssful reallocation");

                                            assert!(actual.eq(expected));
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_capacity_many_elements_can_be_appended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for capacity in 1..32 {
                                        for additional in 1..capacity {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_back(capacity).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, 0);
                                            debug_assert_eq!(actual.back_capacity, capacity);

                                            _ = actual.resize(-isize::try_from(additional).expect("too small to wrap")).expect("succssful reallocation");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..(capacity - additional) {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.append(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }
                        }
                    }

                    mod when_exactly_capacity {
                        use super::*;

                        mod when_empty {
                            use super::*;

                            #[test]
                            fn then_decreases_capacity_by_requested() {
                                for capacity in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    _ = actual.resize(-isize::try_from(capacity).expect("too small to wrap")).expect("succssful reallocation");

                                    assert_eq!(actual.capacity(), 0);
                                }
                            }

                            #[test]
                            fn then_does_not_initialize_elements() {
                                for capacity in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    _ = actual.resize(-isize::try_from(capacity).expect("too small to wrap")).expect("succssful reallocation");

                                    assert_eq!(actual.initialized, 0);
                                }
                            }
                        }

                        mod when_not_empty {
                            use super::*;

                            #[test]
                            fn then_does_not_modify_front_capacity() {
                                for elements in 1..32 {
                                    for capacity in 1..32 {
                                        let mut actual: Dynamic<_> = (0..elements).collect();

                                        _ = actual.reserve_back(capacity).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, 0);
                                        debug_assert_eq!(actual.back_capacity, capacity);

                                        _ = actual.resize(-isize::try_from(capacity).expect("too small to wrap")).expect("succssful reallocation");

                                        assert_eq!(actual.front_capacity, 0);
                                    }
                                }
                            }

                            #[test]
                            fn then_decreases_back_capacity_to_zero() {
                                for elements in 1..32 {
                                    for capacity in 1..32 {
                                        let mut actual: Dynamic<_> = (0..elements).collect();

                                        _ = actual.reserve_back(capacity).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, 0);
                                        debug_assert_eq!(actual.back_capacity, capacity);

                                        _ = actual.resize(-isize::try_from(capacity).expect("too small to wrap")).expect("succssful reallocation");

                                        assert_eq!(actual.back_capacity, 0);
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_modify_initialized_elements() {
                                for elements in 1..32 {
                                    for capacity in 1..32 {
                                        let expected = 0..elements;

                                        let mut actual: Dynamic<_> = expected.clone().collect();

                                        _ = actual.reserve_back(capacity).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, 0);
                                        debug_assert_eq!(actual.back_capacity, capacity);

                                        _ = actual.resize(-isize::try_from(capacity).expect("too small to wrap")).expect("succssful reallocation");

                                        assert!(actual.eq(expected));
                                    }
                                }
                            }
                        }
                    }

                    mod when_more_than_capacity {
                        use super::*;

                        mod when_empty {
                            use super::*;

                            #[test]
                            fn then_does_not_modify_capacity() {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(capacity).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, 0);
                                        debug_assert_eq!(actual.back_capacity, capacity);

                                        _ = actual.resize(-isize::try_from(capacity + additional).expect("too small to wrap")).expect_err("not enough back capacity");

                                        assert_eq!(actual.capacity(), capacity);
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_initialize_elements() {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(capacity).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, 0);
                                        debug_assert_eq!(actual.back_capacity, capacity);

                                        _ = actual.resize(-isize::try_from(capacity + additional).expect("too small to wrap")).expect_err("not enough back capacity");

                                        assert_eq!(actual.initialized, 0);
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_reallocate_memory() {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(capacity).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, 0);
                                        debug_assert_eq!(actual.back_capacity, capacity);

                                        let allocation = actual.buffer;

                                        _ = actual.resize(-isize::try_from(capacity + additional).expect("too small to wrap")).expect_err("not enough back capacity");

                                        assert_eq!(actual.buffer, allocation);
                                    }
                                }
                            }

                            #[test]
                            fn then_capacity_many_elements_can_be_appended_without_reallocating_memory() {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(capacity).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, 0);
                                        debug_assert_eq!(actual.back_capacity, capacity);

                                        _ = actual.resize(-isize::try_from(capacity + additional).expect("too small to wrap")).expect_err("not enough back capacity");

                                        let allocation = actual.buffer;

                                        for element in 0..capacity {
                                            _ = actual.append(element).expect("uses capacity");
                                        }

                                        assert_eq!(actual.buffer, allocation);
                                    }
                                }
                            }
                        }

                        mod when_not_empty {
                            use super::*;

                            #[test]
                            fn then_does_not_modify_front_capacity() {
                                for elements in 1..32 {
                                    for capacity in 1..32 {
                                        for additional in 1..32 {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_back(capacity).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, 0);
                                            debug_assert_eq!(actual.back_capacity, capacity);

                                            _ = actual.resize(-isize::try_from(capacity + additional).expect("too small to wrap")).expect_err("not enough back capacity");

                                            assert_eq!(actual.front_capacity, 0);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_modify_back_capacity() {
                                for elements in 1..32 {
                                    for capacity in 1..32 {
                                        for additional in 1..32 {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_back(capacity).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, 0);
                                            debug_assert_eq!(actual.back_capacity, capacity);

                                            _ = actual.resize(-isize::try_from(capacity + additional).expect("too small to wrap")).expect_err("not enough back capacity");

                                            assert_eq!(actual.back_capacity, capacity);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_modify_initialized_elements() {
                                for elements in 1..32 {
                                    for capacity in 1..32 {
                                        for additional in 1..32 {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_back(capacity).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, 0);
                                            debug_assert_eq!(actual.back_capacity, capacity);

                                            _ = actual.resize(-isize::try_from(capacity + additional).expect("too small to wrap")).expect_err("not enough back capacity");

                                            assert!(actual.eq(expected));
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_reallocate_memory() {
                                for elements in 1..32 {
                                    for capacity in 1..32 {
                                        for additional in 1..32 {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_back(capacity).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, 0);
                                            debug_assert_eq!(actual.back_capacity, capacity);

                                            let allocation = actual.buffer;

                                            _ = actual.resize(-isize::try_from(capacity + additional).expect("too small to wrap")).expect_err("not enough back capacity");

                                            assert_eq!(actual.buffer, allocation);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_capacity_many_elements_can_be_appended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for capacity in 1..32 {
                                        for additional in 1..32 {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_back(capacity).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, 0);
                                            debug_assert_eq!(actual.back_capacity, capacity);

                                            _ = actual.resize(-isize::try_from(capacity + additional).expect("too small to wrap")).expect_err("not enough back capacity");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..capacity {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.append(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                mod when_positive_requested {
                    use super::*;

                    mod when_empty {
                        use super::*;

                        #[test]
                        fn then_increases_capacity_by_requested() {
                            for capacity in 1..32 {
                                for additional in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    _ = actual.resize(isize::try_from(additional).expect("too small to wrap")).expect("successful reallocation");

                                    assert_eq!(actual.capacity(), capacity + additional);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_initialize_elements() {
                            for capacity in 1..32 {
                                for additional in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    _ = actual.resize(isize::try_from(additional).expect("too small to wrap")).expect("successful reallocation");

                                    assert_eq!(actual.initialized, 0);
                                }
                            }
                        }

                        #[test]
                        fn then_requested_many_elements_can_be_appended_without_reallocating_memory() {
                            for capacity in 1..32 {
                                for additional in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_back(capacity).expect("successful allocation");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, 0);
                                    debug_assert_eq!(actual.back_capacity, capacity);

                                    _ = actual.resize(isize::try_from(additional).expect("too small to wrap")).expect("successful reallocation");

                                    let allocation = actual.buffer;

                                    for element in 0..(capacity + additional) {
                                        _ = actual.append(element).expect("uses capacity");
                                    }

                                    assert_eq!(actual.buffer, allocation);
                                }
                            }
                        }
                    }

                    mod when_not_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_front_capacity() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let mut actual: Dynamic<_> = (0..elements).collect();

                                        _ = actual.reserve_back(capacity).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, 0);
                                        debug_assert_eq!(actual.back_capacity, capacity);

                                        _ = actual.resize(isize::try_from(additional).expect("too small to wrap")).expect("successful reallocation");

                                        assert_eq!(actual.front_capacity, 0);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_increases_back_capacity_by_requested() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let mut actual: Dynamic<_> = (0..elements).collect();

                                        _ = actual.reserve_back(capacity).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, 0);
                                        debug_assert_eq!(actual.back_capacity, capacity);

                                        _ = actual.resize(isize::try_from(additional).expect("too small to wrap")).expect("successful reallocation");

                                        assert_eq!(actual.back_capacity, capacity + additional);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_initialized_elements() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let expected = 0..elements;

                                        let mut actual: Dynamic<_> = expected.clone().collect();

                                        _ = actual.reserve_back(capacity).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, 0);
                                        debug_assert_eq!(actual.back_capacity, capacity);

                                        _ = actual.resize(isize::try_from(additional).expect("too small to wrap")).expect("successful reallocation");

                                        assert!(actual.eq(expected));
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_requested_many_elements_can_be_appended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for capacity in 1..32 {
                                    for additional in 1..32 {
                                        let expected = 0..elements;

                                        let mut actual: Dynamic<_> = expected.clone().collect();

                                        _ = actual.reserve_back(capacity).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, 0);
                                        debug_assert_eq!(actual.back_capacity, capacity);

                                        _ = actual.resize(isize::try_from(additional).expect("too small to wrap")).expect("successful reallocation");

                                        let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                        for _ in 0..(capacity + additional) {
                                            // NOTE: this is distinct from the expected values.
                                            _ = actual.append(usize::MAX).expect("uses capacity");
                                        }

                                        assert!(pointers.iter().copied().eq(expected));
                                    }
                                }
                            }
                        }
                    }
                }
            }

            mod when_both_front_and_back_capacity {
                use super::*;

                mod when_zero_requested {
                    use super::*;

                    mod when_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_capacity() {
                            for front in 1..32 {
                                for back in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_back(front + back).expect("successful allocation");

                                    _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, front);
                                    debug_assert_eq!(actual.back_capacity, back);

                                    _ = actual.resize(0).expect("does nothing");

                                    assert_eq!(actual.capacity(), front + back);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_initialize_elements() {
                            for front in 1..32 {
                                for back in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_back(front + back).expect("successful allocation");

                                    _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, front);
                                    debug_assert_eq!(actual.back_capacity, back);

                                    _ = actual.resize(0).expect("does nothing");

                                    assert_eq!(actual.initialized, 0);
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_reallocate_memory() {
                            for front in 1..32 {
                                for back in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_back(front + back).expect("successful allocation");

                                    _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, front);
                                    debug_assert_eq!(actual.back_capacity, back);

                                    let allocation = actual.buffer;

                                    _ = actual.resize(0).expect("does nothing");

                                    assert_eq!(actual.buffer, allocation);
                                }
                            }
                        }

                        #[test]
                        fn then_capacity_many_elements_can_be_appended_without_reallocating_memory() {
                            for front in 1..32 {
                                for back in 1..32 {
                                    let mut actual = Dynamic::<usize>::default();

                                    _ = actual.reserve_back(front + back).expect("successful allocation");

                                    _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, front);
                                    debug_assert_eq!(actual.back_capacity, back);

                                    _ = actual.resize(0).expect("does nothing");

                                    let allocation = actual.buffer;

                                    for element in 0..(front + back) {
                                        _ = actual.append(element).expect("uses capacity");
                                    }

                                    assert_eq!(actual.buffer, allocation);
                                }
                            }
                        }

                    }

                    mod when_not_empty {
                        use super::*;

                        #[test]
                        fn then_does_not_modify_front_capacity() {
                            for elements in 1..32 {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        let mut actual: Dynamic<_> = (0..elements).collect();

                                        _ = actual.reserve_front(front).expect("successful allocation");
                                        _ = actual.reserve_back(back).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.resize(0).expect("does nothing");

                                        assert_eq!(actual.front_capacity, front);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_back_capacity() {
                            for elements in 1..32 {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        let mut actual: Dynamic<_> = (0..elements).collect();

                                        _ = actual.reserve_front(front).expect("successful allocation");
                                        _ = actual.reserve_back(back).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.resize(0).expect("does nothing");

                                        assert_eq!(actual.back_capacity, back);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_initialized_elements() {
                            for elements in 1..32 {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        let expected = 0..elements;

                                        let mut actual: Dynamic<_> = expected.clone().collect();

                                        _ = actual.reserve_front(front).expect("successful allocation");
                                        _ = actual.reserve_back(back).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.resize(0).expect("does nothing");

                                        assert!(actual.eq(expected));
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_reallocate_memory() {
                            for elements in 1..32 {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        let mut actual: Dynamic<_> = (0..elements).collect();

                                        _ = actual.reserve_front(front).expect("successful allocation");
                                        _ = actual.reserve_back(back).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        let allocation = actual.buffer;

                                        _ = actual.resize(0).expect("does nothing");

                                        assert_eq!(actual.buffer, allocation);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_front_many_elements_can_be_prepended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        let expected = 0..elements;

                                        let mut actual: Dynamic<_> = expected.clone().collect();

                                        _ = actual.reserve_front(front).expect("successful allocation");
                                        _ = actual.reserve_back(back).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.resize(0).expect("does nothing");

                                        let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                        for _ in 0..front {
                                            // NOTE: this is distinct from the expected values.
                                            _ = actual.prepend(usize::MAX).expect("uses capacity");
                                        }

                                        assert!(pointers.iter().copied().eq(expected));
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_back_many_elements_can_be_appended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        let expected = 0..elements;

                                        let mut actual: Dynamic<_> = expected.clone().collect();

                                        _ = actual.reserve_front(front).expect("successful allocation");
                                        _ = actual.reserve_back(back).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.resize(0).expect("does nothing");

                                        let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                        for _ in 0..back {
                                            // NOTE: this is distinct from the expected values.
                                            _ = actual.append(usize::MAX).expect("uses capacity");
                                        }

                                        assert!(pointers.iter().copied().eq(expected));
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_both_front_many_elements_can_be_prepended_and_back_many_elements_can_be_appended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        let expected = 0..elements;

                                        let mut actual: Dynamic<_> = expected.clone().collect();

                                        _ = actual.reserve_front(front).expect("successful allocation");
                                        _ = actual.reserve_back(back).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.resize(0).expect("does nothing");

                                        let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                        for _ in 0..front {
                                            // NOTE: this is distinct from the expected values.
                                            _ = actual.prepend(usize::MAX).expect("uses capacity");
                                        }

                                        for _ in 0..back {
                                            // NOTE: this is distinct from the expected values.
                                            _ = actual.append(usize::MAX).expect("uses capacity");
                                        }

                                        assert!(pointers.iter().copied().eq(expected));
                                    }
                                }
                            }
                        }
                    }
                }

                mod when_negative_requested {
                    use super::*;

                    mod when_less_than_back_capacity {
                        use super::*;

                        mod when_empty {
                            use super::*;

                            #[test]
                            fn then_decreases_capacity_by_requested() {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        for additional in 1..back {
                                            let mut actual = Dynamic::<usize>::default();

                                            _ = actual.reserve_back(front + back).expect("successful allocation");

                                            _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                            debug_assert_eq!(actual.initialized, 0);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.resize(-isize::try_from(additional).expect("too small to wrap")).expect("successful reallocation");

                                            assert_eq!(actual.capacity(), front + back - additional);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_initialize_elements() {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        for additional in 1..back {
                                            let mut actual = Dynamic::<usize>::default();

                                            _ = actual.reserve_back(front + back).expect("successful allocation");

                                            _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                            debug_assert_eq!(actual.initialized, 0);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.resize(-isize::try_from(additional).expect("too small to wrap")).expect("successful reallocation");

                                            assert_eq!(actual.initialized, 0);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_capacity_many_elements_can_be_appended_without_reallocating_memory() {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        for additional in 1..back {
                                            let mut actual = Dynamic::<usize>::default();

                                            _ = actual.reserve_back(front + back).expect("successful allocation");

                                            _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                            debug_assert_eq!(actual.initialized, 0);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.resize(-isize::try_from(additional).expect("too small to wrap")).expect("successful reallocation");

                                            let allocation = actual.buffer;

                                            for element in 0..(front + back - additional) {
                                                _ = actual.append(element).expect("uses capacity");
                                            }

                                            assert_eq!(actual.buffer, allocation);
                                        }
                                    }
                                }
                            }
                        }

                        mod when_not_empty {
                            use super::*;

                            #[test]
                            fn then_does_not_modify_front_capacity() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            for additional in 1..back {
                                                let mut actual: Dynamic<_> = (0..elements).collect();

                                                _ = actual.reserve_front(front).expect("successful allocation");
                                                _ = actual.reserve_back(back).expect("successful allocation");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front);
                                                debug_assert_eq!(actual.back_capacity, back);

                                                _ = actual.resize(-isize::try_from(additional).expect("too small to wrap")).expect("successful reallocation");

                                                assert_eq!(actual.front_capacity, front);
                                            }
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_decreases_back_capacity_by_requested() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            for additional in 1..back {
                                                let mut actual: Dynamic<_> = (0..elements).collect();

                                                _ = actual.reserve_front(front).expect("successful allocation");
                                                _ = actual.reserve_back(back).expect("successful allocation");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front);
                                                debug_assert_eq!(actual.back_capacity, back);

                                                _ = actual.resize(-isize::try_from(additional).expect("too small to wrap")).expect("successful reallocation");

                                                assert_eq!(actual.back_capacity, back - additional);
                                            }
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_modify_initialized_elements() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            for additional in 1..back {
                                                let expected = 0..elements;

                                                let mut actual: Dynamic<_> = expected.clone().collect();

                                                _ = actual.reserve_front(front).expect("successful allocation");
                                                _ = actual.reserve_back(back).expect("successful allocation");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front);
                                                debug_assert_eq!(actual.back_capacity, back);

                                                _ = actual.resize(-isize::try_from(additional).expect("too small to wrap")).expect("successful reallocation");

                                                assert!(actual.eq(expected));
                                            }
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_front_many_elements_can_be_prepended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            for additional in 1..back {
                                                let expected = 0..elements;

                                                let mut actual: Dynamic<_> = expected.clone().collect();

                                                _ = actual.reserve_front(front).expect("successful allocation");
                                                _ = actual.reserve_back(back).expect("successful allocation");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front);
                                                debug_assert_eq!(actual.back_capacity, back);

                                                _ = actual.resize(-isize::try_from(additional).expect("too small to wrap")).expect("successful reallocation");

                                                let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                                for _ in 0..front {
                                                    // NOTE: this is distinct from the expected values.
                                                    _ = actual.prepend(usize::MAX).expect("uses capacity");
                                                }

                                                assert!(pointers.iter().copied().eq(expected));
                                            }
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_back_many_elements_can_be_appended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            for additional in 1..back {
                                                let expected = 0..elements;

                                                let mut actual: Dynamic<_> = expected.clone().collect();

                                                _ = actual.reserve_front(front).expect("successful allocation");
                                                _ = actual.reserve_back(back).expect("successful allocation");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front);
                                                debug_assert_eq!(actual.back_capacity, back);

                                                _ = actual.resize(-isize::try_from(additional).expect("too small to wrap")).expect("successful reallocation");

                                                let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                                for _ in 0..(back - additional) {
                                                    // NOTE: this is distinct from the expected values.
                                                    _ = actual.append(usize::MAX).expect("uses capacity");
                                                }

                                                assert!(pointers.iter().copied().eq(expected));
                                            }
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_both_front_many_elements_can_be_prepended_and_back_many_elements_can_be_appended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            for additional in 1..back {
                                                let expected = 0..elements;

                                                let mut actual: Dynamic<_> = expected.clone().collect();

                                                _ = actual.reserve_front(front).expect("successful allocation");
                                                _ = actual.reserve_back(back).expect("successful allocation");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front);
                                                debug_assert_eq!(actual.back_capacity, back);

                                                _ = actual.resize(-isize::try_from(additional).expect("too small to wrap")).expect("successful reallocation");

                                                let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                                for _ in 0..front {
                                                    // NOTE: this is distinct from the expected values.
                                                    _ = actual.prepend(usize::MAX).expect("uses capacity");
                                                }

                                                for _ in 0..(back - additional) {
                                                    // NOTE: this is distinct from the expected values.
                                                    _ = actual.append(usize::MAX).expect("uses capacity");
                                                }

                                                assert!(pointers.iter().copied().eq(expected));
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }

                    mod when_exactly_back_capacity {
                        use super::*;

                        mod when_empty {
                            use super::*;

                            #[test]
                            fn then_decreases_capacity_by_requested() {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(front + back).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.resize(-isize::try_from(back).expect("too small to wrap")).expect("successful reallocation");

                                        assert_eq!(actual.capacity(), front);
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_initialize_elements() {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(front + back).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.resize(-isize::try_from(back).expect("too small to wrap")).expect("successful reallocation");

                                        assert_eq!(actual.initialized, 0);
                                    }
                                }
                            }

                            #[test]
                            fn then_capacity_many_elements_can_be_appended_without_reallocating_memory() {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(front + back).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.resize(-isize::try_from(back).expect("too small to wrap")).expect("successful reallocation");

                                        let allocation = actual.buffer;

                                        for element in 0..front {
                                            _ = actual.append(element).expect("uses capacity");
                                        }

                                        assert_eq!(actual.buffer, allocation);
                                    }
                                }
                            }
                        }

                        mod when_not_empty {
                            use super::*;

                            #[test]
                            fn then_does_not_modify_front_capacity() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.resize(-isize::try_from(back).expect("too small to wrap")).expect("successful reallocation");

                                            assert_eq!(actual.front_capacity, front);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_decreases_back_capacity_to_zero() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.resize(-isize::try_from(back).expect("too small to wrap")).expect("successful reallocation");

                                            assert_eq!(actual.back_capacity, 0);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_modify_initialized_elements() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.resize(-isize::try_from(back).expect("too small to wrap")).expect("successful reallocation");

                                            assert!(actual.eq(expected));
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_front_many_elements_can_be_prepended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.resize(-isize::try_from(back).expect("too small to wrap")).expect("successful reallocation");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..front {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.prepend(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }
                        }
                    }

                    mod when_more_than_back_requested {
                        use super::*;

                        mod when_empty {
                            use super::*;

                            #[test]
                            fn then_does_not_modify_capacity() {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        for additional in 1..32 {
                                            let mut actual = Dynamic::<usize>::default();

                                            _ = actual.reserve_back(front + back).expect("successful allocation");

                                            _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                            debug_assert_eq!(actual.initialized, 0);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.resize(-isize::try_from(back + additional).expect("too small to wrap")).expect_err("not enough back capacity");

                                            assert_eq!(actual.capacity(), front + back);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_initialize_elements() {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        for additional in 1..32 {
                                            let mut actual = Dynamic::<usize>::default();

                                            _ = actual.reserve_back(front + back).expect("successful allocation");

                                            _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                            debug_assert_eq!(actual.initialized, 0);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.resize(-isize::try_from(back + additional).expect("too small to wrap")).expect_err("not enough back capacity");

                                            assert_eq!(actual.initialized, 0);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_reallocate_memory() {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        for additional in 1..32 {
                                            let mut actual = Dynamic::<usize>::default();

                                            _ = actual.reserve_back(front + back).expect("successful allocation");

                                            _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                            debug_assert_eq!(actual.initialized, 0);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            let allocation = actual.buffer;

                                            _ = actual.resize(-isize::try_from(back + additional).expect("too small to wrap")).expect_err("not enough back capacity");

                                            assert_eq!(actual.buffer, allocation);
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_capacity_many_elements_can_be_appended_without_reallocating_memory() {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        for additional in 1..32 {
                                            let mut actual = Dynamic::<usize>::default();

                                            _ = actual.reserve_back(front + back).expect("successful allocation");

                                            _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                            debug_assert_eq!(actual.initialized, 0);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.resize(-isize::try_from(back + additional).expect("too small to wrap")).expect_err("not enough back capacity");

                                            let allocation = actual.buffer;

                                            for element in 0..(front + back) {
                                                _ = actual.append(element).expect("uses capacity");
                                            }

                                            assert_eq!(actual.buffer, allocation);
                                        }
                                    }
                                }
                            }
                        }

                        mod when_not_empty {
                            use super::*;

                            #[test]
                            fn then_does_not_modify_front_capacity() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            for additional in 1..32 {
                                                let mut actual: Dynamic<_> = (0..elements).collect();

                                                _ = actual.reserve_front(front).expect("successful allocation");
                                                _ = actual.reserve_back(back).expect("successful allocation");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front);
                                                debug_assert_eq!(actual.back_capacity, back);

                                                _ = actual.resize(-isize::try_from(back + additional).expect("too small to wrap")).expect_err("not enough back capacity");

                                                assert_eq!(actual.front_capacity, front);
                                            }
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_modify_back_capacity() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            for additional in 1..32 {
                                                let mut actual: Dynamic<_> = (0..elements).collect();

                                                _ = actual.reserve_front(front).expect("successful allocation");
                                                _ = actual.reserve_back(back).expect("successful allocation");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front);
                                                debug_assert_eq!(actual.back_capacity, back);

                                                _ = actual.resize(-isize::try_from(back + additional).expect("too small to wrap")).expect_err("not enough back capacity");

                                                assert_eq!(actual.back_capacity, back);
                                            }
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_modify_initialized_elements() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            for additional in 1..32 {
                                                let expected = 0..elements;

                                                let mut actual: Dynamic<_> = expected.clone().collect();

                                                _ = actual.reserve_front(front).expect("successful allocation");
                                                _ = actual.reserve_back(back).expect("successful allocation");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front);
                                                debug_assert_eq!(actual.back_capacity, back);

                                                _ = actual.resize(-isize::try_from(back + additional).expect("too small to wrap")).expect_err("not enough back capacity");

                                                assert!(actual.eq(expected));
                                            }
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_does_not_reallocate_memory() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            for additional in 1..32 {
                                                let mut actual: Dynamic<_> = (0..elements).collect();

                                                _ = actual.reserve_front(front).expect("successful allocation");
                                                _ = actual.reserve_back(back).expect("successful allocation");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front);
                                                debug_assert_eq!(actual.back_capacity, back);

                                                let allocation = actual.buffer;

                                                _ = actual.resize(-isize::try_from(back + additional).expect("too small to wrap")).expect_err("not enough back capacity");

                                                assert_eq!(actual.buffer, allocation);
                                            }
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_front_many_elements_can_be_prepended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            for additional in 1..32 {
                                                let expected = 0..elements;

                                                let mut actual: Dynamic<_> = expected.clone().collect();

                                                _ = actual.reserve_front(front).expect("successful allocation");
                                                _ = actual.reserve_back(back).expect("successful allocation");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front);
                                                debug_assert_eq!(actual.back_capacity, back);

                                                _ = actual.resize(-isize::try_from(back + additional).expect("too small to wrap")).expect_err("not enough back capacity");

                                                let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                                for _ in 0..front {
                                                    // NOTE: this is distinct from the expected values.
                                                    _ = actual.prepend(usize::MAX).expect("uses capacity");
                                                }

                                                assert!(pointers.iter().copied().eq(expected));
                                            }
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_back_many_elements_can_be_appended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            for additional in 1..32 {
                                                let expected = 0..elements;

                                                let mut actual: Dynamic<_> = expected.clone().collect();

                                                _ = actual.reserve_front(front).expect("successful allocation");
                                                _ = actual.reserve_back(back).expect("successful allocation");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front);
                                                debug_assert_eq!(actual.back_capacity, back);

                                                _ = actual.resize(-isize::try_from(back + additional).expect("too small to wrap")).expect_err("not enough back capacity");

                                                let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                                for _ in 0..back {
                                                    // NOTE: this is distinct from the expected values.
                                                    _ = actual.append(usize::MAX).expect("uses capacity");
                                                }

                                                assert!(pointers.iter().copied().eq(expected));
                                            }
                                        }
                                    }
                                }
                            }

                            #[test]
                            fn then_both_front_many_elements_can_be_prepended_and_back_many_elements_can_be_appended_without_invalidating_pointers() {
                                for elements in 1..32 {
                                    for front in 1..32 {
                                        for back in 1..32 {
                                            for additional in 1..32 {
                                                let expected = 0..elements;

                                                let mut actual: Dynamic<_> = expected.clone().collect();

                                                _ = actual.reserve_front(front).expect("successful allocation");
                                                _ = actual.reserve_back(back).expect("successful allocation");

                                                debug_assert_eq!(actual.initialized, elements);
                                                debug_assert_eq!(actual.front_capacity, front);
                                                debug_assert_eq!(actual.back_capacity, back);

                                                _ = actual.resize(-isize::try_from(back + additional).expect("too small to wrap")).expect_err("not enough back capacity");

                                                let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                                for _ in 0..front {
                                                    // NOTE: this is distinct from the expected values.
                                                    _ = actual.prepend(usize::MAX).expect("uses capacity");
                                                }

                                                for _ in 0..back {
                                                    // NOTE: this is distinct from the expected values.
                                                    _ = actual.append(usize::MAX).expect("uses capacity");
                                                }

                                                assert!(pointers.iter().copied().eq(expected));
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                mod when_positive_requested {
                    use super::*;

                    mod when_empty {
                        use super::*;

                        #[test]
                        fn when_zero_size_type_then_can_allocate_maximum_possible_amount() {
                            for front in 1..32 {
                                for back in 1..32 {
                                    let mut actual = Dynamic::<()>::default();

                                    _ = actual.reserve_back(front + back).expect("successful allocation");

                                    _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                    debug_assert_eq!(actual.initialized, 0);
                                    debug_assert_eq!(actual.front_capacity, front);
                                    debug_assert_eq!(actual.back_capacity, back);

                                    _ = actual.resize(isize::try_from(isize::MAX as usize - front - back).expect("too small to wrap")).expect("does nothing");

                                    assert_eq!(actual.capacity(), isize::MAX as usize);
                                }
                            }
                        }

                        #[test]
                        fn then_increases_capacity_by_requested() {
                            for front in 1..32 {
                                for back in 1..32 {
                                    for additional in 1..32 {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(front + back).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.resize(isize::try_from(additional).expect("too small to wrap")).expect("does nothing");

                                        assert_eq!(actual.capacity(), front + back + additional);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_initialize_elements() {
                            for front in 1..32 {
                                for back in 1..32 {
                                    for additional in 1..32 {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(front + back).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.resize(isize::try_from(additional).expect("too small to wrap")).expect("does nothing");

                                        assert_eq!(actual.initialized, 0);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_capacity_many_elements_can_be_appended_without_reallocating_memory() {
                            for front in 1..32 {
                                for back in 1..32 {
                                    for additional in 1..32 {
                                        let mut actual = Dynamic::<usize>::default();

                                        _ = actual.reserve_back(front + back).expect("successful allocation");

                                        _ = actual.shift(isize::try_from(front).expect("too small to wrap")).expect("enough back capacity to shift into");

                                        debug_assert_eq!(actual.initialized, 0);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.resize(isize::try_from(additional).expect("too small to wrap")).expect("does nothing");

                                        let allocation = actual.buffer;

                                        for element in 0..(front + back + additional) {
                                            _ = actual.append(element).expect("uses capacity");
                                        }

                                        assert_eq!(actual.buffer, allocation);
                                    }
                                }
                            }
                        }
                    }

                    mod when_not_empty {
                        use super::*;

                        #[test]
                        fn when_zero_size_type_then_can_allocate_maximum_possible_amount() {
                            for elements in 1..32 {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        let mut actual: Dynamic<_> = core::iter::repeat_n((), elements).collect();

                                        _ = actual.reserve_front(front).expect("successful allocation");
                                        _ = actual.reserve_back(back).expect("successful allocation");

                                        debug_assert_eq!(actual.initialized, elements);
                                        debug_assert_eq!(actual.front_capacity, front);
                                        debug_assert_eq!(actual.back_capacity, back);

                                        _ = actual.resize(isize::try_from(isize::MAX as usize - front - elements - back).expect("too small to wrap")).expect("does nothing");

                                        assert_eq!(actual.capacity(), isize::MAX as usize - elements);
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_front_capacity() {
                            for elements in 1..32 {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        for additional in 1..32 {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.resize(isize::try_from(additional).expect("too small to wrap")).expect("does nothing");

                                            assert_eq!(actual.front_capacity, front);
                                        }
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_increases_back_capacity_by_requested() {
                            for elements in 1..32 {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        for additional in 1..32 {
                                            let mut actual: Dynamic<_> = (0..elements).collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.resize(isize::try_from(additional).expect("too small to wrap")).expect("does nothing");

                                            assert_eq!(actual.back_capacity, back + additional);
                                        }
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_does_not_modify_initialized_elements() {
                            for elements in 1..32 {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        for additional in 1..32 {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.resize(isize::try_from(additional).expect("too small to wrap")).expect("does nothing");

                                            assert!(actual.eq(expected));
                                        }
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_front_many_elements_can_be_prepended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        for additional in 1..32 {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.resize(isize::try_from(additional).expect("too small to wrap")).expect("does nothing");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..front {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.prepend(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_back_many_elements_can_be_appended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        for additional in 1..32 {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.resize(isize::try_from(additional).expect("too small to wrap")).expect("does nothing");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..(back + additional) {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.append(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }
                        }

                        #[test]
                        fn then_both_front_many_elements_can_be_prepended_and_back_many_elements_can_be_appended_without_invalidating_pointers() {
                            for elements in 1..32 {
                                for front in 1..32 {
                                    for back in 1..32 {
                                        for additional in 1..32 {
                                            let expected = 0..elements;

                                            let mut actual: Dynamic<_> = expected.clone().collect();

                                            _ = actual.reserve_front(front).expect("successful allocation");
                                            _ = actual.reserve_back(back).expect("successful allocation");

                                            debug_assert_eq!(actual.initialized, elements);
                                            debug_assert_eq!(actual.front_capacity, front);
                                            debug_assert_eq!(actual.back_capacity, back);

                                            _ = actual.resize(isize::try_from(additional).expect("too small to wrap")).expect("does nothing");

                                            let pointers = unsafe { core::slice::from_raw_parts(actual.as_ptr(), elements) };

                                            for _ in 0..front {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.prepend(usize::MAX).expect("uses capacity");
                                            }

                                            for _ in 0..(back + additional) {
                                                // NOTE: this is distinct from the expected values.
                                                _ = actual.append(usize::MAX).expect("uses capacity");
                                            }

                                            assert!(pointers.iter().copied().eq(expected));
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    mod drop {
        use super::*;

        #[test]
        fn zero_size_type() {
            drop(Dynamic::<()>::default());
        }

        #[test]
        fn empty() {
            drop(Dynamic::<usize>::default());
        }

        #[test]
        fn all_initialized() {
            use crate::test::mock::DropCounter;

            const ELEMENTS: usize = 256;

            let dropped = DropCounter::new_counter();

            let mut actual =
                Dynamic::<DropCounter>::with_capacity(ELEMENTS).expect("successful allocation");

            for _ in 0..ELEMENTS {
                _ = actual
                    .append(DropCounter::new(&dropped))
                    .expect("uses capacity");
            }

            drop(actual);

            assert_eq!(dropped.take(), ELEMENTS);
        }

        #[test]
        fn all_front_capacity() {
            let mut actual = Dynamic::<usize>::default();

            _ = actual.reserve_front(256).expect("successful allocation");

            drop(actual);
        }

        #[test]
        fn all_back_capacity() {
            let mut actual = Dynamic::<usize>::default();

            _ = actual.reserve_back(256).expect("successful allocation");

            drop(actual);
        }

        #[test]
        fn front_capacity_and_initialized_elements_and_back_capacity() {
            use crate::test::mock::DropCounter;

            const ELEMENTS: usize = 256;

            let dropped = DropCounter::new_counter();

            let mut actual =
                Dynamic::<DropCounter>::with_capacity(ELEMENTS).expect("successful allocation");

            for _ in 0..ELEMENTS {
                _ = actual
                    .append(DropCounter::new(&dropped))
                    .expect("uses capacity");
            }

            _ = actual.reserve_front(256).expect("successful allocation");
            _ = actual.reserve_back(256).expect("successful allocation");

            drop(actual);

            assert_eq!(dropped.take(), ELEMENTS);
        }
    }

    mod try_from {
        use super::*;

        #[test]
        fn does_not_allocate_front_capacity() {
            let expected = [0, 1, 2, 3, 4, 5];
            let actual = Dynamic::try_from(expected.as_slice()).expect("successful allocation");

            assert_eq!(actual.front_capacity, 0);
        }

        #[test]
        fn does_not_allocate_back_capacity() {
            let expected = [0, 1, 2, 3, 4, 5];
            let actual = Dynamic::try_from(expected.as_slice()).expect("successful allocation");

            assert_eq!(actual.back_capacity, 0);
        }

        #[test]
        fn allocates_memory() {
            let expected = [0, 1, 2, 3, 4, 5];
            let actual = Dynamic::try_from(expected.as_slice()).expect("successful allocation");

            for index in 0..expected.len() {
                let ptr = unsafe { actual.buffer.as_ptr().add(index) };

                // Ideally, this will seg-fault if unowned memory.
                _ = unsafe { &mut *ptr }.write(index);
            }
        }

        #[test]
        fn has_elements() {
            let expected = [0, 1, 2, 3, 4, 5];
            let actual = Dynamic::try_from(expected.as_slice()).expect("successful allocation");

            assert_eq!(actual.initialized, expected.len());
        }

        #[test]
        fn initializes_elements() {
            let expected = [0, 1, 2, 3, 4, 5];

            let actual = Dynamic::try_from(expected.as_slice()).expect("successful allocation");

            for index in 0..expected.len() {
                assert_eq!(actual[index], expected[index]);
            }
        }
    }

    mod index {
        use super::*;

        use core::ops::Index as _;

        #[test]
        fn correct_element() {
            let expected = [0, 1, 2, 3, 4, 5];
            let actual = Dynamic::from_iter(expected);

            for (index, value) in expected.iter().enumerate() {
                assert_eq!(actual.index(index), value);
            }
        }

        #[test]
        #[should_panic = "index out of bounds"]
        fn panics_when_out_of_bounds() {
            let instance = Dynamic::<()>::default();

            let _: &() = instance.index(0);
        }
    }

    mod index_mut {
        use super::*;

        use core::ops::IndexMut as _;

        #[test]
        fn correct_element() {
            let mut expected = [0, 1, 2, 3, 4, 5];
            let mut actual = Dynamic::from_iter(expected);

            for (index, value) in expected.iter_mut().enumerate() {
                assert_eq!(actual.index_mut(index), value);
            }
        }

        #[test]
        #[should_panic = "index out of bounds"]
        fn panics_when_out_of_bounds() {
            let mut instance = Dynamic::<()>::default();

            let _: &mut () = instance.index_mut(0);
        }

        #[test]
        fn is_mutable() {
            let mut actual = Dynamic::from_iter([0, 1, 2, 3, 4, 5]);

            for element in actual.iter_mut() {
                *element = 0;
            }

            for element in actual {
                assert_eq!(element, 0);
            }
        }
    }

    mod iterator {
        use super::*;

        mod into {
            use super::*;

            #[test]
            fn element_count() {
                let expected = [0, 1, 2, 3, 4, 5];

                let actual: Dynamic<_> = expected.iter().copied().collect();

                assert_eq!(actual.into_iter().count(), expected.len());
            }

            #[test]
            fn in_order() {
                let expected = [0, 1, 2, 3, 4, 5];

                let actual: Dynamic<_> = expected.iter().copied().collect();

                assert!(actual.into_iter().eq(expected.into_iter()));
            }

            mod drop {
                use super::*;

                #[test]
                fn drops_unyielded_elements_when_advanced_from_front() {
                    use crate::test::mock::DropCounter;

                    const ELEMENTS: usize = 8;

                    for yielded in 0..ELEMENTS {
                        let dropped = DropCounter::new_counter();

                        #[expect(
                            clippy::useless_conversion,
                            reason = "explicitly testing into iterator"
                        )]
                        let mut actual =
                            Dynamic::from_iter(core::array::from_fn::<_, ELEMENTS, _>(|_| {
                                DropCounter::new(&dropped)
                            }))
                            .into_iter();

                        for _ in 0..yielded {
                            // Lifetime is passed to caller.
                            drop(actual.next());
                        }

                        // The above drops in caller scope, not the
                        // destructor being tested, so reset counter.
                        debug_assert_eq!(dropped.replace(0), yielded);

                        // Now we drop the iterator, so we expect all
                        // remaining elements to be dropped.
                        drop(actual);

                        assert_eq!(dropped.take(), ELEMENTS - yielded);
                    }
                }

                #[test]
                fn drops_unyielded_elements_when_advanced_from_back() {
                    use crate::test::mock::DropCounter;

                    const ELEMENTS: usize = 8;

                    for yielded in 0..ELEMENTS {
                        let dropped = DropCounter::new_counter();

                        #[expect(
                            clippy::useless_conversion,
                            reason = "explicitly testing into iterator"
                        )]
                        let mut actual =
                            Dynamic::from_iter(core::array::from_fn::<_, ELEMENTS, _>(|_| {
                                DropCounter::new(&dropped)
                            }))
                            .into_iter();

                        for _ in 0..yielded {
                            // Lifetime is passed to caller.
                            drop(actual.next_back());
                        }

                        // The above drops in caller scope, not the
                        // destructor being tested, so reset counter.
                        debug_assert_eq!(dropped.replace(0), yielded);

                        // Now we drop the iterator, so we expect all
                        // remaining elements to be dropped.
                        drop(actual);

                        assert_eq!(dropped.take(), ELEMENTS - yielded);
                    }
                }

                #[test]
                fn drops_unyielded_elements_when_advanced_from_both_ends() {
                    use crate::test::mock::DropCounter;

                    const ELEMENTS: usize = 8;

                    for front in 0..ELEMENTS {
                        for back in front..ELEMENTS {
                            let dropped = DropCounter::new_counter();

                            #[expect(
                                clippy::useless_conversion,
                                reason = "explicitly testing into iterator"
                            )]
                            let mut actual =
                                Dynamic::from_iter(core::array::from_fn::<_, ELEMENTS, _>(|_| {
                                    DropCounter::new(&dropped)
                                }))
                                .into_iter();

                            for _ in 0..front {
                                // Lifetime is passed to caller.
                                drop(actual.next());
                            }

                            for _ in front..back {
                                // Lifetime is passed to caller.
                                drop(actual.next_back());
                            }

                            // The above drops in caller scope, not the
                            // destructor being tested, so reset counter.
                            let expected = ELEMENTS - dropped.replace(0);

                            // Now we drop the iterator, so we expect all
                            // remaining elements to be dropped.
                            drop(actual);

                            assert_eq!(dropped.take(), expected);
                        }
                    }
                }
            }

            mod double_ended {
                use super::*;

                #[test]
                fn element_count() {
                    let expected = [0, 1, 2, 3, 4, 5];

                    let actual: Dynamic<_> = expected.iter().copied().collect();

                    assert_eq!(actual.into_iter().rev().count(), expected.len());
                }

                #[test]
                fn in_order() {
                    let expected = [0, 1, 2, 3, 4, 5];

                    let actual: Dynamic<_> = expected.iter().copied().collect();

                    assert!(actual.into_iter().rev().eq(expected.into_iter().rev()));
                }
            }

            mod exact_size {
                use super::*;

                #[test]
                fn hint() {
                    let expected = [0, 1, 2, 3, 4, 5];
                    let actual: Dynamic<_> = expected.iter().copied().collect();

                    assert_eq!(
                        actual.into_iter().size_hint(),
                        (expected.len(), Some(expected.len()))
                    );
                }

                #[test]
                fn len() {
                    let expected = [0, 1, 2, 3, 4, 5];
                    let actual: Dynamic<_> = expected.iter().copied().collect();

                    assert_eq!(actual.into_iter().len(), expected.len());
                }

                #[test]
                fn updates() {
                    let mut actual: Dynamic<_> = [0, 1, 2, 3, 4, 5].into_iter().collect();

                    for remaining in (0..actual.len()).rev() {
                        _ = actual.next();

                        assert_eq!(actual.len(), remaining);
                    }
                }
            }

            mod fused {
                use super::*;

                #[test]
                fn empty() {
                    let actual = Dynamic::<()>::default();
                    let mut actual = actual.into_iter();

                    // Yields `None` at least once.
                    assert_eq!(actual.next(), None);
                    assert_eq!(actual.next_back(), None);

                    // Continues to yield `None`.
                    assert_eq!(actual.next(), None);
                    assert_eq!(actual.next_back(), None);
                }

                #[test]
                fn exhausted() {
                    let actual: Dynamic<_> = [()].into_iter().collect();
                    let mut actual = actual.into_iter();

                    // Exhaust the elements.
                    let _: () = actual.next().expect("the one element");

                    // Yields `None` at least once.
                    assert_eq!(actual.next(), None);
                    assert_eq!(actual.next_back(), None);

                    // Continues to yield `None`.
                    assert_eq!(actual.next(), None);
                    assert_eq!(actual.next_back(), None);
                }
            }
        }

        mod from {
            use super::*;

            #[test]
            fn does_not_allocate_front_capacity() {
                let actual = Dynamic::from_iter([0, 1, 2, 3, 4, 5]);

                assert_eq!(actual.front_capacity, 0);
            }

            #[test]
            fn does_not_allocate_back_capacity() {
                let actual = Dynamic::from_iter([0, 1, 2, 3, 4, 5]);

                assert_eq!(actual.back_capacity, 0);
            }

            #[test]
            fn allocates_memory() {
                let expected = [0, 1, 2, 3, 4, 5];
                let actual: Dynamic<_> = expected.iter().copied().collect();

                for index in 0..expected.len() {
                    let ptr = unsafe { actual.buffer.as_ptr().add(index) };

                    // Ideally, this will seg-fault if unowned memory.
                    _ = unsafe { &mut *ptr }.write(index);
                }
            }

            #[test]
            fn updates_internal_state() {
                let expected = [0, 1, 2, 3, 4, 5];
                let actual: Dynamic<_> = expected.iter().copied().collect();

                assert_eq!(actual.initialized, expected.len());
            }

            #[test]
            fn initializes_elements() {
                let expected = [0, 1, 2, 3, 4, 5];
                let actual: Dynamic<_> = expected.iter().copied().collect();

                for index in 0..expected.len() {
                    assert_eq!(actual[index], expected[index]);
                }
            }

            #[test]
            fn empty() {
                let actual: Dynamic<()> = core::iter::empty().collect();

                assert_eq!(actual.front_capacity, 0);
                assert_eq!(actual.initialized, 0);
                assert_eq!(actual.back_capacity, 0);
            }

            #[test]
            fn handles_oversized_size_hint() {
                use crate::test::mock::SizeHint;

                let expected = [0, 1, 2, 3, 4, 5];

                let actual: Dynamic<_> = SizeHint {
                    data: expected.iter().copied(),
                    size_hint: (usize::MAX, Some(usize::MAX)),
                }
                .collect();

                assert_eq!(actual.len(), expected.len());
            }

            #[test]
            fn handles_undersized_size_hint() {
                use crate::test::mock::SizeHint;

                let expected = [0, 1, 2, 3, 4, 5];

                let actual: Dynamic<_> = SizeHint {
                    data: expected.iter().copied(),
                    size_hint: (0, Some(0)),
                }
                .collect();

                assert_eq!(actual.len(), expected.len());
            }

            #[test]
            fn handles_invalid_size_hint() {
                use crate::test::mock::SizeHint;

                let expected = [0, 1, 2, 3, 4, 5];

                let actual: Dynamic<_> = SizeHint {
                    data: expected.iter().copied(),
                    size_hint: (usize::MAX, Some(0)),
                }
                .collect();

                assert_eq!(actual.len(), expected.len());
            }

            #[test]
            fn handles_unbounded_size_hint() {
                use crate::test::mock::SizeHint;

                let expected = [0, 1, 2, 3, 4, 5];

                let actual: Dynamic<_> = SizeHint {
                    data: expected.iter().copied(),
                    size_hint: (0, None),
                }
                .collect();

                assert_eq!(actual.len(), expected.len());
            }
        }

        mod extend {
            use super::*;

            #[test]
            fn does_not_allocate_front_capacity() {
                let mut actual = Dynamic::<usize>::default();

                let expected = [0, 1, 2, 3, 4, 5];
                actual.extend(expected);

                assert_eq!(actual.front_capacity, 0);
            }

            #[test]
            fn does_not_allocate_back_capacity() {
                let mut actual = Dynamic::<usize>::default();

                let expected = [0, 1, 2, 3, 4, 5];
                actual.extend(expected);

                assert_eq!(actual.back_capacity, 0);
            }

            #[test]
            fn consumes_front_capacity() {
                let mut actual = Dynamic::<usize>::default();

                let expected = [0, 1, 2, 3, 4, 5];

                _ = actual
                    .reserve_front(expected.len())
                    .expect("successful allocation");

                actual.extend(expected);

                assert_eq!(actual.capacity_front(), 0);
            }

            #[test]
            fn consumes_back_capacity() {
                let mut actual = Dynamic::<usize>::default();

                let expected = [0, 1, 2, 3, 4, 5];

                _ = actual
                    .reserve_back(expected.len())
                    .expect("successful allocation");

                actual.extend(expected);

                assert_eq!(actual.capacity_back(), 0);
            }

            #[test]
            fn allocates_memory_when_empty() {
                let mut actual = Dynamic::<usize>::default();

                let expected = [0, 1, 2, 3, 4, 5];
                actual.extend(expected);

                for index in 0..expected.len() {
                    let ptr = unsafe { actual.buffer.as_ptr().add(index) };

                    // Ideally, this will seg-fault if unowned memory.
                    _ = unsafe { &mut *ptr }.write(index);
                }
            }

            #[test]
            fn reallocates_memory_when_not_enough_capacity() {
                let mut actual = Dynamic::<usize>::with_capacity(1).expect("successful allocation");

                let expected = [0, 1, 2, 3, 4, 5];
                actual.extend(expected);

                for index in 0..expected.len() {
                    let ptr = unsafe { actual.buffer.as_ptr().add(index) };

                    // Ideally, this will seg-fault if unowned memory.
                    _ = unsafe { &mut *ptr }.write(index);
                }
            }

            #[test]
            fn updates_internal_state() {
                let mut actual = Dynamic::default();

                let expected = [0, 1, 2, 3, 4, 5];

                actual.extend(expected);

                assert_eq!(actual.initialized, expected.len());
            }

            #[test]
            fn appends_elements() {
                let preexisting = [0, 1, 2];
                let mut actual: Dynamic<_> = preexisting.into_iter().collect();

                let expected = [3, 4, 5];
                actual.extend(expected.iter().copied());

                #[expect(clippy::shadow_unrelated, reason = "elements from them")]
                for (actual, expected) in actual.skip(preexisting.len()).zip(expected) {
                    assert_eq!(actual, expected);
                }
            }

            #[test]
            fn does_not_modify_other_elements() {
                let expected = [0, 1, 2, 3, 4, 5];
                let mut actual: Dynamic<_> = expected.iter().copied().collect();

                actual.extend([6, 7, 8, 9, 10]);

                for index in 0..expected.len() {
                    assert_eq!(actual[index], expected[index]);
                }
            }

            #[test]
            fn into_empty_instance() {
                let mut actual = Dynamic::<usize>::default();

                let expected = [0, 1, 2, 3, 4, 5];

                actual.extend(expected.iter().copied());

                assert!(actual.eq(expected));
            }

            #[test]
            fn from_empty_iterator() {
                let mut actual = Dynamic::<()>::default();

                actual.extend(core::iter::empty());

                assert_eq!(actual.front_capacity, 0);
                assert_eq!(actual.initialized, 0);
                assert_eq!(actual.back_capacity, 0);
            }

            #[test]
            fn handles_oversized_size_hint() {
                use crate::test::mock::SizeHint;

                let expected = [0, 1, 2, 3, 4, 5];

                let mut actual = Dynamic::default();

                actual.extend(SizeHint {
                    data: expected.iter().copied(),
                    size_hint: (usize::MAX, Some(usize::MAX)),
                });

                assert_eq!(actual.len(), expected.len());
            }

            #[test]
            fn handles_undersized_size_hint() {
                use crate::test::mock::SizeHint;

                let expected = [0, 1, 2, 3, 4, 5];

                let mut actual = Dynamic::default();

                actual.extend(SizeHint {
                    data: expected.iter().copied(),
                    size_hint: (0, Some(0)),
                });

                assert_eq!(actual.len(), expected.len());
            }

            #[test]
            fn handles_invalid_size_hint() {
                use crate::test::mock::SizeHint;

                let expected = [0, 1, 2, 3, 4, 5];

                let mut actual = Dynamic::default();

                actual.extend(SizeHint {
                    data: expected.iter().copied(),
                    size_hint: (usize::MAX, Some(0)),
                });

                assert_eq!(actual.len(), expected.len());
            }

            #[test]
            fn handles_unbounded_size_hint() {
                use crate::test::mock::SizeHint;

                let expected = [0, 1, 2, 3, 4, 5];

                let mut actual = Dynamic::default();

                actual.extend(SizeHint {
                    data: expected.iter().copied(),
                    size_hint: (0, None),
                });

                assert_eq!(actual.len(), expected.len());
            }
        }
    }

    mod default {
        use super::*;

        #[test]
        fn does_not_allocate_front_capacity() {
            let actual = Dynamic::<usize>::default();

            assert_eq!(actual.front_capacity, 0);
        }

        #[test]
        fn does_not_allocate_back_capacity() {
            let actual = Dynamic::<usize>::default();

            assert_eq!(actual.back_capacity, 0);
        }

        #[test]
        fn does_not_initialize_elements() {
            let actual = Dynamic::<()>::default();

            assert_eq!(actual.initialized, 0);
        }
    }

    mod clone {
        use super::*;

        #[test]
        fn does_not_allocate_front_capacity() {
            let actual = Dynamic::from_iter([0, 1, 2, 3, 4, 5]).clone().clone();

            assert_eq!(actual.front_capacity, 0);
        }

        #[test]
        fn does_not_allocate_back_capacity() {
            let actual = Dynamic::from_iter([0, 1, 2, 3, 4, 5]).clone().clone();

            assert_eq!(actual.back_capacity, 0);
        }

        #[test]
        fn has_elements() {
            let expected = Dynamic::from_iter([0, 1, 2, 3, 4, 5]);

            let actual = expected.clone();

            assert_eq!(actual.initialized, expected.len());
        }

        #[test]
        fn is_equivalent() {
            let expected = Dynamic::from_iter([0, 1, 2, 3, 4, 5]);

            let actual = expected.clone();

            assert_eq!(actual, expected);
        }
    }

    mod equality {
        use super::*;

        #[test]
        fn eq_when_same_elements() {
            let expected = [0, 1, 2, 3, 4, 5];

            let first: Dynamic<_> = expected.iter().copied().collect();
            let second: Dynamic<_> = expected.iter().copied().collect();

            assert_eq!(first, second);
        }

        #[test]
        fn ne_when_different_elements() {
            let first = Dynamic::from_iter([0]);
            let second = Dynamic::from_iter([1]);

            assert_ne!(first, second);
        }

        #[test]
        fn ignores_different_front_capacity() {
            let expected = [0, 1, 2, 3, 4, 5];

            let mut first: Dynamic<_> = expected.iter().copied().collect();
            let mut second: Dynamic<_> = expected.iter().copied().collect();

            _ = first.reserve_front(128).expect("successful allocation");
            _ = second.reserve_front(256).expect("successful allocation");

            assert_eq!(first, second);
        }

        #[test]
        fn ignores_different_back_capacity() {
            let expected = [0, 1, 2, 3, 4, 5];

            let mut first: Dynamic<_> = expected.iter().copied().collect();
            let mut second: Dynamic<_> = expected.iter().copied().collect();

            _ = first.reserve_back(128).expect("successful allocation");
            _ = second.reserve_back(256).expect("successful allocation");

            assert_eq!(first, second);
        }

        #[test]
        fn is_symmetric() {
            let expected = [0, 1, 2, 3, 4, 5];

            let first: Dynamic<_> = expected.iter().copied().collect();
            let second: Dynamic<_> = expected.iter().copied().collect();

            // `first == second` <=> `second == first`
            assert_eq!(first, second);
            assert_eq!(second, first);
        }

        #[test]
        fn is_transitive() {
            let expected = [0, 1, 2, 3, 4, 5];

            let first: Dynamic<_> = expected.iter().copied().collect();
            let second: Dynamic<_> = expected.iter().copied().collect();
            let third: Dynamic<_> = expected.iter().copied().collect();

            // `first == second && second == third` => `first == third`
            assert_eq!(first, second);
            assert_eq!(second, third);
            assert_eq!(third, first);
        }

        #[test]
        fn is_reflexive() {
            let actual = Dynamic::<()>::default();

            assert_eq!(actual, actual);
        }
    }

    mod fmt {
        use super::*;

        mod debug {
            use super::*;

            #[test]
            fn is_elements() {
                let expected = [0, 1, 2, 3, 4, 5];
                let actual: Dynamic<_> = expected.iter().copied().collect();

                assert_eq!(format!("{actual:?}"), format!("{expected:?}"));
            }
        }
    }

    mod collection {
        use super::*;

        mod count {
            use super::*;

            #[test]
            fn initialized_elements() {
                let expected = [0, 1, 2, 3, 4, 5];
                let actual: Dynamic<_> = expected.iter().copied().collect();

                assert_eq!(Collection::count(&actual), expected.len());
            }

            #[test]
            fn zero_when_empty() {
                let actual = Dynamic::<()>::default();

                assert_eq!(Collection::count(&actual), 0);
            }

            #[test]
            fn ignores_front_capacity() {
                let expected = [0, 1, 2, 3, 4, 5];

                let mut actual: Dynamic<_> = expected.iter().copied().collect();

                _ = actual.reserve_front(256).expect("successful allocation");

                assert_eq!(actual.count(), expected.len());
            }

            #[test]
            fn ignores_back_capacity() {
                let expected = [0, 1, 2, 3, 4, 5];

                let mut actual: Dynamic<_> = expected.iter().copied().collect();

                _ = actual.reserve_back(256).expect("successful allocation");

                assert_eq!(actual.count(), expected.len());
            }
        }
    }

    mod linear {
        use super::*;

        mod iter {
            use super::*;

            #[test]
            fn element_count() {
                let expected = [0, 1, 2, 3, 4, 5];
                let actual: Dynamic<_> = expected.iter().copied().collect();

                assert_eq!(actual.iter().count(), expected.len());
            }

            #[test]
            fn in_order() {
                let expected = [0, 1, 2, 3, 4, 5];
                let actual: Dynamic<_> = expected.iter().copied().collect();

                assert!(actual.iter().eq(expected.iter()));
            }

            mod double_ended {
                use super::*;

                #[test]
                fn element_count() {
                    let expected = [0, 1, 2, 3, 4, 5];
                    let actual: Dynamic<_> = expected.iter().copied().collect();

                    assert_eq!(actual.iter().rev().count(), expected.len());
                }

                #[test]
                fn in_order() {
                    let expected = [0, 1, 2, 3, 4, 5];
                    let actual: Dynamic<_> = expected.iter().copied().collect();

                    assert!(actual.iter().rev().eq(expected.iter().rev()));
                }
            }

            mod exact_size {
                use super::*;

                #[test]
                fn hint() {
                    let expected = [0, 1, 2, 3, 4, 5];
                    let actual: Dynamic<_> = expected.iter().copied().collect();

                    assert_eq!(
                        actual.iter().size_hint(),
                        (expected.len(), Some(expected.len()))
                    );
                }

                #[test]
                fn len() {
                    let expected = [0, 1, 2, 3, 4, 5];
                    let actual: Dynamic<_> = expected.iter().copied().collect();

                    assert_eq!(actual.iter().len(), expected.len());
                }

                #[test]
                fn updates() {
                    let actual: Dynamic<_> = [0, 1, 2, 3, 4, 5].into_iter().collect();
                    let mut actual = actual.iter();

                    for remaining in (0..actual.len()).rev() {
                        _ = actual.next();

                        assert_eq!(actual.len(), remaining);
                    }
                }
            }

            mod fused {
                use super::*;

                #[test]
                fn empty() {
                    let actual = Dynamic::<()>::default();
                    let mut actual = actual.iter();

                    // Yields `None` at least once.
                    assert_eq!(actual.next(), None);
                    assert_eq!(actual.next_back(), None);

                    // Continues to yield `None`.
                    assert_eq!(actual.next(), None);
                    assert_eq!(actual.next_back(), None);
                }

                #[test]
                fn exhausted() {
                    let actual: Dynamic<_> = [()].into_iter().collect();
                    let mut actual = actual.iter();

                    // Exhaust the elements.
                    let _: &() = actual.next().expect("the one element");

                    // Yields `None` at least once.
                    assert_eq!(actual.next(), None);
                    assert_eq!(actual.next_back(), None);

                    // Continues to yield `None`.
                    assert_eq!(actual.next(), None);
                    assert_eq!(actual.next_back(), None);
                }
            }
        }

        mod iter_mut {
            use super::*;

            #[test]
            fn element_count() {
                let expected = [0, 1, 2, 3, 4, 5];
                let mut actual: Dynamic<_> = expected.iter().copied().collect();

                assert_eq!(actual.iter_mut().count(), expected.len());
            }

            #[test]
            fn in_order() {
                let mut expected = [0, 1, 2, 3, 4, 5];
                let mut actual: Dynamic<_> = expected.iter().copied().collect();

                assert!(actual.iter_mut().eq(expected.iter_mut()));
            }

            mod double_ended {
                use super::*;

                #[test]
                fn element_count() {
                    let expected = [0, 1, 2, 3, 4, 5];
                    let mut actual: Dynamic<_> = expected.iter().copied().collect();

                    assert_eq!(actual.iter_mut().rev().count(), expected.len());
                }

                #[test]
                fn in_order() {
                    let mut expected = [0, 1, 2, 3, 4, 5];
                    let mut actual: Dynamic<_> = expected.iter().copied().collect();

                    assert!(actual.iter_mut().rev().eq(expected.iter_mut().rev()));
                }
            }

            mod exact_size {
                use super::*;

                #[test]
                fn hint() {
                    let expected = [0, 1, 2, 3, 4, 5];
                    let mut actual: Dynamic<_> = expected.iter().copied().collect();

                    assert_eq!(
                        actual.iter_mut().size_hint(),
                        (expected.len(), Some(expected.len()))
                    );
                }

                #[test]
                fn len() {
                    let expected = [0, 1, 2, 3, 4, 5];
                    let mut actual: Dynamic<_> = expected.iter().copied().collect();

                    assert_eq!(actual.iter_mut().len(), expected.len());
                }

                #[test]
                fn updates() {
                    let mut actual: Dynamic<_> = [0, 1, 2, 3, 4, 5].into_iter().collect();
                    let mut actual = actual.iter_mut();

                    for remaining in (0..actual.len()).rev() {
                        _ = actual.next();

                        assert_eq!(actual.len(), remaining);
                    }
                }
            }

            mod fused {
                use super::*;

                #[test]
                fn empty() {
                    let mut actual = Dynamic::<()>::default();
                    let mut actual = actual.iter_mut();

                    // Yields `None` at least once.
                    assert_eq!(actual.next(), None);
                    assert_eq!(actual.next_back(), None);

                    // Continues to yield `None`.
                    assert_eq!(actual.next(), None);
                    assert_eq!(actual.next_back(), None);
                }

                #[test]
                fn exhausted() {
                    let mut actual: Dynamic<_> = [()].into_iter().collect();
                    let mut actual = actual.iter_mut();

                    // Exhaust the elements.
                    let _: &mut () = actual.next().expect("the one element");

                    // Yields `None` at least once.
                    assert_eq!(actual.next(), None);
                    assert_eq!(actual.next_back(), None);

                    // Continues to yield `None`.
                    assert_eq!(actual.next(), None);
                    assert_eq!(actual.next_back(), None);
                }
            }
        }
    }

    mod array {
        use super::*;

        mod as_ptr {
            use super::*;

            #[test]
            fn address_of_underlying_buffer() {
                let actual = Dynamic::<i32>::from_iter([0, 1, 2, 3, 4, 5]);

                assert_eq!(
                    actual.as_ptr(),
                    actual.buffer.as_ptr().cast::<i32>().cast_const()
                );
            }

            #[test]
            fn skips_front_capacity() {
                let mut actual = Dynamic::<i32>::from_iter([0, 1, 2, 3, 4, 5]);

                _ = actual.reserve_front(256).expect("successful allocation");

                assert_eq!(actual.as_ptr(), unsafe {
                    actual.buffer.as_ptr().cast::<i32>().cast_const().add(256)
                });
            }

            #[test]
            #[should_panic = "no allocation to point to"]
            fn panics_if_no_allocation() {
                let actual = Dynamic::<()>::default();

                _ = actual.as_ptr();
            }
        }

        mod as_mut_ptr {
            use super::*;

            #[test]
            fn address_of_underlying_buffer() {
                let mut actual = Dynamic::<i32>::from_iter([0, 1, 2, 3, 4, 5]);

                assert_eq!(actual.as_mut_ptr(), actual.buffer.as_ptr().cast::<i32>());
            }

            #[test]
            fn skips_front_capacity() {
                let mut actual = Dynamic::<i32>::from_iter([0, 1, 2, 3, 4, 5]);

                _ = actual.reserve_front(256).expect("successful allocation");

                assert_eq!(actual.as_mut_ptr(), unsafe {
                    actual.buffer.as_ptr().cast::<i32>().add(256)
                });
            }

            #[test]
            #[should_panic = "no allocation to point to"]
            fn panics_if_no_allocation() {
                let mut actual = Dynamic::<()>::default();

                _ = actual.as_mut_ptr();
            }
        }
    }

    mod list {
        use super::*;

        use crate::structure::collection::linear::list::List as _;

        mod insert {
            use super::*;

            #[test]
            fn adds_element() {
                let expected = [0, 1, 2, 3, 4, 5];
                let mut actual: Dynamic<_> = expected.iter().copied().collect();

                _ = actual.insert(2, 12345).expect("successful allocation");

                assert_eq!(actual.initialized, expected.len() + 1);
            }

            #[test]
            fn initializes_element() {
                let expected = [0, 1, 2, 3, 4, 5];
                let mut actual: Dynamic<_> = expected.iter().copied().collect();

                _ = actual.insert(2, 12345).expect("successful allocation");

                assert_eq!(actual[2], 12345);
            }

            #[test]
            fn yields_element() {
                let expected = [0, 1, 2, 3, 4, 5];
                let mut actual: Dynamic<_> = expected.iter().copied().collect();

                let actual = actual.insert(2, 12345).expect("successful allocation");

                assert_eq!(actual, &mut 12345);
            }

            #[test]
            fn returned_reference_is_mutable() {
                let expected = [0, 1, 2, 3, 4, 5];
                let mut actual: Dynamic<_> = expected.iter().copied().collect();

                let actual = actual.insert(2, 12345).expect("successful allocation");

                *actual = 54321;

                assert_eq!(actual, &mut 54321);
            }

            #[test]
            fn will_allocate_when_empty() {
                let mut actual = Dynamic::<usize>::default();

                _ = actual.insert(0, 12345).expect("successful allocation");
            }

            #[test]
            fn will_reallocate_when_no_capacity() {
                let expected = [0, 1, 2, 3, 4, 5];
                let mut actual: Dynamic<_> = expected.iter().copied().collect();
                _ = actual.shrink(0).expect("no capacity");

                _ = actual.insert(2, 12345).expect("successful allocation");
            }

            #[test]
            fn does_not_modify_leading_elements() {
                const INDEX: usize = 2;

                let expected = [0, 1, 2, 3, 4, 5];
                let mut actual: Dynamic<_> = expected.iter().copied().collect();

                _ = actual.insert(INDEX, 12345).expect("successful allocation");

                for index in 0..INDEX {
                    assert_eq!(actual[index], expected[index]);
                }
            }

            #[test]
            fn does_not_modify_trailing_elements() {
                const INDEX: usize = 2;

                let expected = [0, 1, 2, 3, 4, 5];
                let mut actual: Dynamic<_> = expected.iter().copied().collect();

                _ = actual.insert(INDEX, 12345).expect("successful allocation");

                for index in INDEX..expected.len() {
                    assert_eq!(actual[index + 1], expected[index]);
                }
            }

            #[test]
            fn prepending_reallocates_when_no_capacity() {
                let mut actual = Dynamic::from_iter([0, 1, 2, 3, 4, 5]);

                _ = actual.insert(0, 12345).expect("successful allocation");
            }

            #[test]
            fn prepending_consumes_front_capacity_when_not_empty() {
                let mut actual = Dynamic::from_iter([0, 1, 2, 3, 4, 5]);
                _ = actual.reserve_front(1).expect("successful allocation");

                _ = actual.insert(0, 12345).expect("uses front capacity");

                assert_eq!(actual.capacity_front(), 0);
            }

            #[test]
            fn prepending_consumes_back_capacity_when_empty() {
                let mut actual = Dynamic::<usize>::default();
                _ = actual.reserve_back(1).expect("successful allocation");

                _ = actual.insert(0, 12345).expect("uses back capacity");

                assert_eq!(actual.capacity_back(), 0);
            }

            #[test]
            fn appending_reallocates_when_no_capacity() {
                let mut actual = Dynamic::from_iter([0, 1, 2, 3, 4, 5]);

                _ = actual.insert(6, 12345).expect("successful allocation");
            }

            #[test]
            fn appending_consumes_back_capacity_when_not_empty() {
                let mut actual = Dynamic::from_iter([0, 1, 2, 3, 4, 5]);
                _ = actual.reserve_back(1).expect("successful allocation");

                _ = actual.insert(6, 12345).expect("uses back capacity");

                assert_eq!(actual.capacity_back(), 0);
            }

            #[test]
            fn appending_consumes_front_capacity_when_empty() {
                let mut actual = Dynamic::<usize>::default();
                _ = actual.reserve_front(1).expect("successful allocation");

                _ = actual.insert(0, 12345).expect("uses front capacity");

                assert_eq!(actual.capacity_front(), 0);
            }
        }

        mod remove {
            use super::*;

            #[test]
            fn subtracts_element() {
                let expected = [0, 1, 2, 3, 4, 5];
                let mut actual: Dynamic<_> = expected.iter().copied().collect();

                _ = actual.remove(0);

                assert_eq!(actual.initialized, expected.len() - 1);
            }

            #[test]
            fn yields_element() {
                let expected = [0, 1, 2, 3, 4, 5];
                let mut actual: Dynamic<_> = expected.iter().copied().collect();

                (0..expected.len()).for_each(|index| {
                    assert_eq!(actual.remove(0).expect("front element"), expected[index]);
                });
            }

            #[test]
            fn does_not_modify_leading_elements() {
                const INDEX: usize = 2;

                let expected = [0, 1, 2, 3, 4, 5];
                let mut actual: Dynamic<_> = expected.iter().copied().collect();

                _ = actual.remove(INDEX);

                for index in 0..INDEX {
                    assert_eq!(actual[index], expected[index]);
                }
            }

            #[test]
            fn does_not_modify_trailing_elements() {
                const INDEX: usize = 2;

                let expected = [0, 1, 2, 3, 4, 5];
                let mut actual: Dynamic<_> = expected.iter().copied().collect();

                _ = actual.remove(INDEX);

                for index in INDEX..expected.len() - 1 {
                    assert_eq!(actual[index], expected[index + 1]);
                }
            }

            #[test]
            fn none_when_index_out_of_bounds() {
                let mut actual = Dynamic::<()>::default();

                assert!(actual.remove(0).is_none());
            }

            #[test]
            fn increases_front_capacity_if_first_element() {
                let mut actual = Dynamic::from_iter([0, 1, 2, 3, 4, 5]);

                for index in 0..actual.len() {
                    _ = actual.remove(0).expect("element to remove");

                    assert_eq!(actual.capacity_front(), index + 1);
                }
            }
        }

        mod drain {
            use super::*;

            mod iterator {
                use super::*;

                #[test]
                fn yields_no_elements_when_empty() {
                    let mut actual = Dynamic::<()>::default();

                    let mut actual = actual.drain(..);

                    assert_eq!(actual.next(), None);

                    drop(actual);
                }

                #[test]
                fn yields_no_elements_when_start_of_range_is_out_of_bounds() {
                    let mut actual = Dynamic::from_iter([0, 1, 2, 3, 4, 5]);

                    let mut actual = actual.drain(6..);

                    assert_eq!(actual.next(), None);
                    assert_eq!(actual.next_back(), None);
                }

                #[test]
                fn yields_elements_when_end_of_range_is_out_of_bounds() {
                    let mut actual = Dynamic::from_iter([0, 1, 2, 3, 4, 5]);

                    let actual = actual.drain(..usize::MAX);

                    assert!(actual.eq([0, 1, 2, 3, 4, 5]));
                }

                #[test]
                fn element_count() {
                    let mut expected = vec![0, 1, 2, 3, 4, 5];
                    let mut actual: Dynamic<_> = expected.iter().copied().collect();

                    assert_eq!(actual.drain(1..4).count(), expected.drain(1..4).count());
                }

                #[test]
                fn in_order() {
                    let mut expected = vec![0, 1, 2, 3, 4, 5];
                    let mut actual: Dynamic<_> = expected.iter().copied().collect();

                    assert!(actual.drain(1..4).eq(expected.drain(1..4)));
                }

                mod double_ended {
                    use super::*;

                    #[test]
                    fn yields_no_elements_when_empty() {
                        let mut actual = Dynamic::<()>::default();

                        let mut actual = actual.drain(..);

                        assert_eq!(actual.next_back(), None);

                        drop(actual);
                    }

                    #[test]
                    fn yields_no_elements_when_start_of_range_is_out_of_bounds() {
                        let mut actual = Dynamic::from_iter([0, 1, 2, 3, 4, 5]);

                        let mut actual = actual.drain(6..);

                        assert_eq!(actual.next_back(), None);
                    }

                    #[test]
                    fn yields_elements_when_end_of_range_is_out_of_bounds() {
                        let mut actual = Dynamic::from_iter([0, 1, 2, 3, 4, 5]);

                        let actual = actual.drain(..usize::MAX).rev();

                        assert!(actual.eq([5, 4, 3, 2, 1, 0]));
                    }

                    #[test]
                    fn element_count() {
                        let mut expected = vec![0, 1, 2, 3, 4, 5];
                        let mut actual: Dynamic<_> = expected.iter().copied().collect();

                        assert_eq!(
                            actual.drain(1..4).rev().count(),
                            expected.drain(1..4).rev().count()
                        );
                    }

                    #[test]
                    fn in_order() {
                        let mut expected = vec![0, 1, 2, 3, 4, 5];
                        let mut actual: Dynamic<_> = expected.iter().copied().collect();

                        assert!(actual.drain(1..4).rev().eq(expected.drain(1..4).rev()));
                    }

                    #[test]
                    fn prevents_elements_from_being_yielded_more_than_once() {
                        let mut underlying = Dynamic::from_iter([0, 1, 2, 0]);

                        let mut actual = underlying.drain(1..=2);

                        // make head and tail meet.
                        _ = actual.next().expect("the element with value '1'");
                        _ = actual.next_back().expect("the element with value '2'");

                        assert_eq!(actual.next(), None);
                        assert_eq!(actual.next_back(), None);
                    }
                }

                mod exact_size {
                    use super::*;

                    #[test]
                    fn hint() {
                        let mut expected = vec![0, 1, 2, 3, 4, 5];
                        let mut actual: Dynamic<_> = expected.iter().copied().collect();

                        let expected = expected.drain(1..4);

                        assert_eq!(
                            actual.drain(1..4).size_hint(),
                            (expected.len(), Some(expected.len()))
                        );
                    }

                    #[test]
                    fn len() {
                        let mut expected = vec![0, 1, 2, 3, 4, 5];
                        let mut actual: Dynamic<_> = expected.iter().copied().collect();

                        assert_eq!(actual.drain(1..4).len(), expected.drain(1..4).len());
                    }
                }

                mod fused {
                    use super::*;

                    #[test]
                    fn when_empty() {
                        let mut actual = Dynamic::<()>::default();
                        let mut actual = actual.drain(..);

                        // Yields `None` at least once.
                        assert_eq!(actual.next(), None);
                        assert_eq!(actual.next_back(), None);

                        // Continues to yield `None`.
                        assert_eq!(actual.next(), None);
                        assert_eq!(actual.next_back(), None);
                    }

                    #[test]
                    fn when_exhausted() {
                        let mut actual: Dynamic<_> = [()].into_iter().collect();
                        let mut actual = actual.drain(..);

                        // Exhaust the elements.
                        let _: () = actual.next().expect("the one element");

                        // Yields `None` at least once.
                        assert_eq!(actual.next(), None);
                        assert_eq!(actual.next_back(), None);

                        // Continues to yield `None`.
                        assert_eq!(actual.next(), None);
                        assert_eq!(actual.next_back(), None);
                    }
                }
            }

            mod drop {
                use super::*;

                #[test]
                fn drops_unyielded_elements_when_advanced_from_front() {
                    use crate::test::mock::DropCounter;

                    const ELEMENTS: usize = 8;

                    for yielded in 0..ELEMENTS {
                        let dropped = DropCounter::new_counter();

                        let mut actual =
                            Dynamic::from_iter(core::array::from_fn::<_, ELEMENTS, _>(|_| {
                                DropCounter::new(&dropped)
                            }));

                        let mut actual = actual.drain(..);

                        for _ in 0..yielded {
                            // Lifetime is passed to caller.
                            drop(actual.next());
                        }

                        // The above drops in caller scope, not the
                        // destructor being tested, so reset counter.
                        debug_assert_eq!(dropped.replace(0), yielded);

                        // Now we drop the iterator, so we expect all
                        // remaining elements to be dropped.
                        drop(actual);

                        assert_eq!(dropped.take(), ELEMENTS - yielded);
                    }
                }

                #[test]
                fn drops_unyielded_elements_when_advanced_from_back() {
                    use crate::test::mock::DropCounter;

                    const ELEMENTS: usize = 8;

                    for yielded in 0..ELEMENTS {
                        let dropped = DropCounter::new_counter();

                        let mut actual =
                            Dynamic::from_iter(core::array::from_fn::<_, ELEMENTS, _>(|_| {
                                DropCounter::new(&dropped)
                            }));

                        let mut actual = actual.drain(..);

                        for _ in 0..yielded {
                            // Lifetime is passed to caller.
                            drop(actual.next_back());
                        }

                        // The above drops in caller scope, not the
                        // destructor being tested, so reset counter.
                        debug_assert_eq!(dropped.replace(0), yielded);

                        // Now we drop the iterator, so we expect all
                        // remaining elements to be dropped.
                        drop(actual);

                        assert_eq!(dropped.take(), ELEMENTS - yielded);
                    }
                }

                #[test]
                fn drops_unyielded_elements_when_advanced_from_both_ends() {
                    use crate::test::mock::DropCounter;

                    const ELEMENTS: usize = 8;

                    for front in 0..ELEMENTS {
                        for back in front..ELEMENTS {
                            let dropped = DropCounter::new_counter();

                            let mut actual =
                                Dynamic::from_iter(core::array::from_fn::<_, ELEMENTS, _>(|_| {
                                    DropCounter::new(&dropped)
                                }));

                            let mut actual = actual.drain(..);

                            for _ in 0..front {
                                // Lifetime is passed to caller.
                                drop(actual.next());
                            }

                            for _ in front..back {
                                // Lifetime is passed to caller.
                                drop(actual.next_back());
                            }

                            // The above drops in caller scope, not the
                            // destructor being tested, so reset counter.
                            let expected = ELEMENTS - dropped.replace(0);

                            // Now we drop the iterator, so we expect all
                            // remaining elements to be dropped.
                            drop(actual);

                            assert_eq!(dropped.take(), expected);
                        }
                    }
                }

                #[test]
                fn can_drain_all_elements() {
                    let mut actual = Dynamic::from_iter([0, 1, 2, 3, 4, 5]);

                    drop(actual.drain(..));

                    assert_eq!(actual.initialized, 0);
                }

                #[test]
                fn does_not_modify_leading_elements() {
                    const ELEMENTS: usize = 8;

                    let expected = core::array::from_fn::<_, ELEMENTS, _>(|index| index);

                    for start in 0..ELEMENTS {
                        let mut actual: Dynamic<_> = expected.iter().copied().collect();

                        drop(actual.drain(start..));

                        assert!(actual.iter().eq(expected[..start].iter()));
                    }
                }

                #[test]
                fn does_not_modify_trailing_elements() {
                    const ELEMENTS: usize = 8;

                    let expected = core::array::from_fn::<_, ELEMENTS, _>(|index| index);

                    for end in 0..ELEMENTS {
                        let mut actual: Dynamic<_> = expected.iter().copied().collect();

                        drop(actual.drain(..end));

                        assert!(actual.iter().eq(expected[end..].iter()));
                    }
                }

                #[test]
                fn combines_leading_and_trailing_elements() {
                    const ELEMENTS: usize = 8;

                    let expected = core::array::from_fn::<_, ELEMENTS, _>(|index| index);

                    for start in 0..ELEMENTS {
                        for end in start..ELEMENTS {
                            let mut actual: Dynamic<_> = expected.iter().copied().collect();

                            drop(actual.drain(start..end));

                            let expected_leading = expected[..start].iter();
                            let expected_trailing = expected[end..].iter();

                            assert!(actual.iter().eq(expected_leading.chain(expected_trailing)));
                        }
                    }
                }

                #[test]
                fn increases_front_capacity_when_range_starts_at_front_but_ends_before_back() {
                    const ELEMENTS: usize = 8;

                    let expected = core::array::from_fn::<_, ELEMENTS, _>(|index| index);

                    for end in 0..ELEMENTS {
                        let mut actual: Dynamic<_> = expected.iter().copied().collect();
                        debug_assert_eq!(actual.front_capacity, 0);

                        drop(actual.drain(..end));

                        assert_eq!(actual.front_capacity, end);
                    }
                }

                #[test]
                fn increases_back_capacity_when_range_ends_at_back_but_starts_before_front() {
                    const ELEMENTS: usize = 8;

                    let expected = core::array::from_fn::<_, ELEMENTS, _>(|index| index);

                    for start in 0..ELEMENTS {
                        let mut actual: Dynamic<_> = expected.iter().copied().collect();
                        debug_assert_eq!(actual.back_capacity, 0);

                        drop(actual.drain(start..));

                        assert_eq!(actual.back_capacity, ELEMENTS - start);
                    }
                }

                #[test]
                fn increases_front_capacity_if_that_is_only_capacity() {
                    const ELEMENTS: usize = 8;

                    let expected = core::array::from_fn::<_, ELEMENTS, _>(|index| index);

                    for start in 1..(ELEMENTS - 1) {
                        let mut actual: Dynamic<_> = expected.iter().copied().collect();

                        // Add front capacity.
                        _ = actual
                            .reserve_front(ELEMENTS)
                            .expect("successful allocation");
                        debug_assert_eq!(actual.back_capacity, 0);

                        let removed = start..(ELEMENTS - 1);

                        drop(actual.drain(removed.clone()));

                        assert_eq!(actual.front_capacity, ELEMENTS + removed.len());
                    }
                }

                #[test]
                fn increases_back_capacity_if_that_is_only_capacity() {
                    const ELEMENTS: usize = 8;

                    let expected = core::array::from_fn::<_, ELEMENTS, _>(|index| index);

                    for start in 1..(ELEMENTS - 1) {
                        let mut actual: Dynamic<_> = expected.iter().copied().collect();

                        // Add front capacity.
                        _ = actual
                            .reserve_back(ELEMENTS)
                            .expect("successful allocation");
                        debug_assert_eq!(actual.front_capacity, 0);

                        let removed = start..(ELEMENTS - 1);

                        drop(actual.drain(removed.clone()));

                        assert_eq!(actual.back_capacity, ELEMENTS + removed.len());
                    }
                }

                #[test]
                fn increases_front_capacity_when_front_and_back_capacity_but_more_trailing_elements()
                 {
                    const ELEMENTS: usize = 8;

                    let expected = core::array::from_fn::<_, ELEMENTS, _>(|index| index);

                    for start in 1..(ELEMENTS / 2) {
                        let mut actual: Dynamic<_> = expected.iter().copied().collect();

                        _ = actual
                            .reserve_front(ELEMENTS)
                            .expect("successful allocation");
                        _ = actual
                            .reserve_back(ELEMENTS)
                            .expect("successful allocation");

                        let removed = start..(ELEMENTS / 2);

                        drop(actual.drain(removed.clone()));

                        assert_eq!(actual.front_capacity, ELEMENTS + removed.len());
                    }
                }

                #[test]
                fn increases_back_capacity_when_front_and_back_capacity_but_more_leading_elements()
                {
                    const ELEMENTS: usize = 8;

                    let expected = core::array::from_fn::<_, ELEMENTS, _>(|index| index);

                    for start in (ELEMENTS / 2)..ELEMENTS {
                        let mut actual: Dynamic<_> = expected.iter().copied().collect();

                        _ = actual
                            .reserve_front(ELEMENTS)
                            .expect("successful allocation");
                        _ = actual
                            .reserve_back(ELEMENTS)
                            .expect("successful allocation");

                        let removed = start..(ELEMENTS / 2);

                        drop(actual.drain(removed.clone()));

                        assert_eq!(actual.back_capacity, ELEMENTS + removed.len());
                    }
                }
            }
        }

        mod withdraw {
            use super::*;

            mod iterator {
                use super::*;

                #[test]
                fn element_count() {
                    let mut underlying = Dynamic::from_iter([0, 1, 2, 3, 4, 5]);

                    let actual = underlying.withdraw(|element| element % 2 == 0);

                    assert_eq!(actual.count(), 3);
                }

                #[test]
                fn in_order() {
                    let mut underlying = Dynamic::from_iter([0, 1, 2, 3, 4, 5]);

                    let actual = underlying.withdraw(|element| element % 2 == 0);

                    assert!(actual.eq([0, 2, 4]));
                }

                #[test]
                fn size_hint() {
                    let mut underlying = Dynamic::from_iter([0, 1, 2, 3, 4, 5]);

                    let actual = underlying.withdraw(|element| element % 2 == 0);

                    assert_eq!(actual.size_hint(), (0, Some(6)));
                }

                mod double_ended {
                    use super::*;

                    #[test]
                    fn element_count() {
                        let mut underlying = Dynamic::from_iter([0, 1, 2, 3, 4, 5]);

                        let actual = underlying.withdraw(|element| element % 2 == 0).rev();

                        assert_eq!(actual.count(), 3);
                    }

                    #[test]
                    fn in_order() {
                        let mut underlying = Dynamic::from_iter([0, 1, 2, 3, 4, 5]);

                        let actual = underlying.withdraw(|element| element % 2 == 0).rev();

                        assert!(actual.eq([4, 2, 0]));
                    }

                    #[test]
                    fn increases_back_capacity_when_withdrawing_last_element() {
                        let mut actual = Dynamic::from_iter([0, 1, 2, 3, 4, 5]);

                        drop(actual.withdraw(|element| element > &0).rev());

                        assert_eq!(actual.capacity_front(), 0);
                        assert_eq!(actual.capacity_back(), 5);
                    }

                    #[test]
                    fn increases_back_capacity_when_retained_are_combined() {
                        let mut actual = Dynamic::from_iter([0, 1, 2, 3, 4, 5]);

                        drop(actual.withdraw(|element| element % 2 == 1).rev());

                        assert_eq!(actual.capacity_front(), 0);
                        assert_eq!(actual.capacity_back(), 3);
                    }

                    #[test]
                    fn combines_retained_elements() {
                        let mut actual = Dynamic::from_iter([0, 1, 2, 3, 4, 5]);

                        drop(actual.withdraw(|element| element == &1).rev());

                        assert!(actual.eq([0, 2, 3, 4, 5]));
                    }

                    #[test]
                    fn prevents_elements_from_being_yielded_more_than_once() {
                        let mut underlying = Dynamic::from_iter([0, 1, 2, 0]);

                        let mut actual = underlying.withdraw(|element| element != &0);

                        // make head and tail meet.
                        _ = actual.next().expect("the element with value '1'");
                        _ = actual.next_back().expect("the element with value '2'");

                        assert_eq!(actual.next(), None);
                        assert_eq!(actual.next_back(), None);
                    }
                }

                mod fused {
                    use super::*;

                    #[test]
                    fn empty() {
                        let mut underlying = Dynamic::<usize>::default();
                        let mut actual = underlying.withdraw(|element| element % 2 == 0);

                        // Yields `None` at least once.
                        assert_eq!(actual.next(), None);
                        assert_eq!(actual.next_back(), None);

                        // Continues to yield `None`.
                        assert_eq!(actual.next(), None);
                        assert_eq!(actual.next_back(), None);
                    }

                    #[test]
                    fn exhausted() {
                        let mut underlying = Dynamic::from_iter([0]);
                        let mut actual = underlying.withdraw(|element| element % 2 == 0);

                        // Exhaust the elements.
                        _ = actual.next().expect("the one element");

                        // Yields `None` at least once.
                        assert_eq!(actual.next(), None);
                        assert_eq!(actual.next_back(), None);

                        // Continues to yield `None`.
                        assert_eq!(actual.next(), None);
                        assert_eq!(actual.next_back(), None);
                    }
                }
            }

            mod drop {
                use super::*;

                #[test]
                fn drops_unyielded_elements_when_advanced_from_front() {
                    use crate::test::mock::DropCounter;

                    const ELEMENTS: usize = 8;

                    for yielded in 0..ELEMENTS {
                        let dropped = DropCounter::new_counter();

                        let mut actual =
                            Dynamic::from_iter(core::array::from_fn::<_, ELEMENTS, _>(|_| {
                                DropCounter::new(&dropped)
                            }));

                        let mut actual = actual.withdraw(|_| true);

                        for _ in 0..yielded {
                            // Lifetime is passed to caller.
                            drop(actual.next());
                        }

                        // The above drops in caller scope, not the
                        // destructor being tested, so reset counter.
                        debug_assert_eq!(dropped.replace(0), yielded);

                        // Now we drop the iterator, so we expect all
                        // remaining elements to be dropped.
                        drop(actual);

                        assert_eq!(dropped.take(), ELEMENTS - yielded);
                    }
                }

                #[test]
                fn drops_unyielded_elements_when_advanced_from_back() {
                    use crate::test::mock::DropCounter;

                    const ELEMENTS: usize = 8;

                    for yielded in 0..ELEMENTS {
                        let dropped = DropCounter::new_counter();

                        let mut actual =
                            Dynamic::from_iter(core::array::from_fn::<_, ELEMENTS, _>(|_| {
                                DropCounter::new(&dropped)
                            }));

                        let mut actual = actual.withdraw(|_| true);

                        for _ in 0..yielded {
                            // Lifetime is passed to caller.
                            drop(actual.next_back());
                        }

                        // The above drops in caller scope, not the
                        // destructor being tested, so reset counter.
                        debug_assert_eq!(dropped.replace(0), yielded);

                        // Now we drop the iterator, so we expect all
                        // remaining elements to be dropped.
                        drop(actual);

                        assert_eq!(dropped.take(), ELEMENTS - yielded);
                    }
                }

                #[test]
                fn drops_unyielded_elements_when_advanced_from_both_ends() {
                    use crate::test::mock::DropCounter;

                    const ELEMENTS: usize = 8;

                    for front in 0..ELEMENTS {
                        for back in front..ELEMENTS {
                            let dropped = DropCounter::new_counter();

                            let mut actual =
                                Dynamic::from_iter(core::array::from_fn::<_, ELEMENTS, _>(|_| {
                                    DropCounter::new(&dropped)
                                }));

                            let mut actual = actual.withdraw(|_| true);

                            for _ in 0..front {
                                // Lifetime is passed to caller.
                                drop(actual.next());
                            }

                            for _ in front..back {
                                // Lifetime is passed to caller.
                                drop(actual.next_back());
                            }

                            // The above drops in caller scope, not the
                            // destructor being tested, so reset counter.
                            let expected = ELEMENTS - dropped.replace(0);

                            // Now we drop the iterator, so we expect all
                            // remaining elements to be dropped.
                            drop(actual);

                            assert_eq!(dropped.take(), expected);
                        }
                    }
                }

                #[test]
                fn can_withdraw_all_elements() {
                    let mut actual = Dynamic::from_iter([0, 1, 2, 3, 4, 5]);

                    drop(actual.withdraw(|_| true));

                    assert_eq!(actual.initialized, 0);
                }

                #[test]
                fn does_not_modify_retained_elements() {
                    let mut actual = Dynamic::from_iter([0, 1, 2, 3, 4, 5]);

                    drop(actual.withdraw(|element| element % 2 == 0));

                    assert!(actual.eq([1, 3, 5]));
                }

                #[test]
                fn increases_capacity_by_amount_of_removed_elements() {
                    const ELEMENTS: usize = 8;

                    for count in 0..=ELEMENTS {
                        let mut actual =
                            Dynamic::from_iter(core::array::from_fn::<_, ELEMENTS, _>(|index| {
                                index
                            }));
                        debug_assert_eq!(actual.capacity(), 0);

                        drop(actual.withdraw(|element| element < &count));

                        assert_eq!(actual.capacity(), count);
                    }
                }

                #[test]
                fn first_retained_element_is_not_repositioned() {
                    const ELEMENTS: usize = 8;

                    for retained in 0..ELEMENTS {
                        let mut actual =
                            Dynamic::from_iter(core::array::from_fn::<_, ELEMENTS, _>(|index| {
                                index
                            }));
                        debug_assert_eq!(actual.front_capacity, 0);
                        debug_assert_eq!(actual.back_capacity, 0);

                        drop(actual.withdraw(|element| element != &retained));

                        assert_eq!(actual.front_capacity, retained);
                        assert_eq!(actual.back_capacity, ELEMENTS - retained - 1);
                    }
                }

                #[test]
                fn combines_disjointed_retained_elements_after_exhaustion() {
                    let mut actual = Dynamic::from_iter([0, 1, 2, 3, 4, 5, 6, 7]);

                    let mut iter = actual.withdraw(|element| element == &3 || element == &4);

                    // Create two disjointed regions of retained elements.
                    // The first region contains `[0, 1, 2`.
                    // The second regions contains `[5, 6, 7]`.
                    // The following calls will remove elements 3 and 4,
                    // alongside exhausting both sides of the iterator.
                    // However, we know from the implementation that neither
                    // call will move any retained elements keeping the gap.
                    _ = iter.next_back().expect("the element with value '4'");
                    _ = iter.next().expect("the element with value '3'");

                    // The above means it is now the responsibility of `drop`
                    // to combine these two regions thereby fixing the state of
                    // the underlying buffer for future use.
                    drop(iter);

                    assert!(actual.eq([0, 1, 2, 5, 6, 7]));
                }
            }
        }

        mod clear {
            use super::*;

            #[test]
            fn drops_all_elements() {
                use crate::test::mock::DropCounter;

                const ELEMENTS: usize = 256;

                let dropped = DropCounter::new_counter();

                let mut actual =
                    Dynamic::<DropCounter>::with_capacity(ELEMENTS).expect("successful allocation");

                for _ in 0..ELEMENTS {
                    _ = actual
                        .append(DropCounter::new(&dropped))
                        .expect("uses capacity");
                }

                actual.clear();

                assert_eq!(actual.initialized, 0);
                assert_eq!(dropped.take(), ELEMENTS);
            }

            #[test]
            fn keeps_allocation() {
                let expected = [0, 1, 2, 3, 4, 5];
                let mut actual = Dynamic::from_iter(expected);

                actual.clear();

                assert_eq!(actual.capacity(), expected.len());
            }

            #[test]
            fn when_already_empty() {
                let mut actual = Dynamic::<usize>::default();

                // Ideally this will panic or something in case of logic error.
                actual.clear();
            }
        }
    }

    mod stack {
        use super::*;

        use super::super::super::super::Stack as _;

        mod push {
            use super::*;

            #[test]
            fn adds_element() {
                let expected = [1, 2, 3, 4, 5];
                let mut actual: Dynamic<_> = expected.iter().copied().collect();

                _ = actual.push(0).expect("successful allocation");

                assert_eq!(actual.len(), expected.len() + 1);
            }

            #[test]
            fn initializes_element() {
                let mut actual: Dynamic<_> = [1, 2, 3, 4, 5].into_iter().collect();

                _ = actual.push(0).expect("successful allocation");

                assert_eq!(actual[0], 0);
            }

            #[test]
            fn yields_element() {
                let expected = [1, 2, 3, 4, 5];
                let mut actual: Dynamic<_> = expected.iter().copied().collect();

                let actual = actual.push(0).expect("successful allocation");

                assert_eq!(actual, &mut 0);
            }

            #[test]
            fn returned_reference_is_mutable() {
                let expected = [1, 2, 3, 4, 5];
                let mut actual: Dynamic<_> = expected.iter().copied().collect();

                let actual = actual.push(0).expect("successful allocation");

                *actual = 12345;

                assert_eq!(actual, &mut 12345);
            }

            #[test]
            fn does_not_modify_trailing_elements() {
                let expected = [1, 2, 3, 4, 5];
                let mut actual: Dynamic<_> = expected.iter().copied().collect();

                _ = actual.push(0).expect("successful allocation");

                for index in 0..expected.len() {
                    assert_eq!(actual[index + 1], expected[index]);
                }
            }

            #[test]
            fn when_empty() {
                let mut actual = Dynamic::<usize>::default();

                _ = actual.push(0).expect("successful allocation");

                assert!(actual.eq([0]));
            }
        }

        mod pop {
            use super::*;

            #[test]
            fn subtracts_element() {
                let expected = [0, 1, 2, 3, 4, 5];
                let mut actual: Dynamic<_> = expected.iter().copied().collect();

                for remaining in (0..expected.len()).rev() {
                    _ = actual.pop();

                    assert_eq!(actual.len(), remaining);
                }
            }

            #[test]
            fn does_not_modify_trailing_elements() {
                let expected = [0, 1, 2, 3, 4, 5];
                let mut actual: Dynamic<_> = expected.iter().copied().collect();

                for offset in 1..=expected.len() {
                    _ = actual.pop();

                    assert!(actual.iter().eq(expected[offset..].iter()));
                }

                assert_eq!(actual.initialized, 0);
            }

            #[test]
            fn yields_element() {
                let expected = [0, 1, 2, 3, 4, 5];
                let mut actual: Dynamic<_> = expected.iter().copied().collect();

                for element in expected {
                    assert_eq!(actual.pop(), Some(element));
                }
            }

            #[test]
            fn none_when_empty() {
                let mut actual = Dynamic::<()>::default();

                assert_eq!(actual.pop(), None);
            }
        }

        mod peek {
            use super::*;

            #[test]
            fn correct_element() {
                let expected = [0, 1, 2, 3, 4, 5];

                let mut actual: Dynamic<_> = expected.iter().copied().collect();

                for element in expected {
                    assert_eq!(actual.peek(), Some(&element));

                    _ = actual.pop();
                }
            }

            #[test]
            fn none_when_empty() {
                let actual = Dynamic::<()>::default();

                assert_eq!(actual.peek(), None);
            }
        }
    }

    mod queue {
        use super::*;

        use super::super::super::super::Queue as _;

        mod push {
            use super::*;

            #[test]
            fn adds_element() {
                let expected = [1, 2, 3, 4, 5];
                let mut actual: Dynamic<_> = expected.iter().copied().collect();

                _ = actual.push(0).expect("successful allocation");

                assert_eq!(actual.len(), expected.len() + 1);
            }

            #[test]
            fn initializes_element() {
                let mut actual: Dynamic<_> = [0, 1, 2, 3, 4].into_iter().collect();

                _ = actual.push(5).expect("successful allocation");

                assert_eq!(actual[5], 5);
            }

            #[test]
            fn yields_element() {
                let expected = [0, 1, 2, 3, 4];
                let mut actual: Dynamic<_> = expected.iter().copied().collect();

                let actual = actual.push(5).expect("successful allocation");

                assert_eq!(actual, &mut 5);
            }

            #[test]
            fn returned_reference_is_mutable() {
                let expected = [0, 1, 2, 3, 4];
                let mut actual: Dynamic<_> = expected.iter().copied().collect();

                let actual = actual.push(5).expect("successful allocation");

                *actual = 12345;

                assert_eq!(actual, &mut 12345);
            }

            #[test]
            fn does_not_modify_leading_elements() {
                let expected = [0, 1, 2, 3, 4];
                let mut actual: Dynamic<_> = expected.iter().copied().collect();

                _ = actual.push(5).expect("successful allocation");

                for index in 0..expected.len() {
                    assert_eq!(actual[index], expected[index]);
                }
            }

            #[test]
            fn when_empty() {
                let mut actual = Dynamic::<usize>::default();

                _ = actual.push(0).expect("successful allocation");

                assert!(actual.eq([0]));
            }
        }

        mod pop {
            use super::*;

            #[test]
            fn subtracts_element() {
                let expected = [0, 1, 2, 3, 4, 5];
                let mut actual: Dynamic<_> = expected.iter().copied().collect();

                for remaining in (0..expected.len()).rev() {
                    _ = actual.pop();

                    assert_eq!(actual.len(), remaining);
                }
            }

            #[test]
            fn does_not_modify_trailing_elements() {
                let expected = [0, 1, 2, 3, 4, 5];
                let mut actual: Dynamic<_> = expected.iter().copied().collect();

                for offset in 1..=expected.len() {
                    _ = actual.pop();

                    assert!(actual.iter().eq(expected[offset..].iter()));
                }

                assert_eq!(actual.initialized, 0);
            }

            #[test]
            fn yields_element() {
                let expected = [0, 1, 2, 3, 4, 5];
                let mut actual: Dynamic<_> = expected.iter().copied().collect();

                for element in expected {
                    assert_eq!(actual.pop(), Some(element));
                }
            }

            #[test]
            fn none_when_empty() {
                let mut actual = Dynamic::<()>::default();

                assert_eq!(actual.pop(), None);
            }
        }

        mod peek {
            use super::*;

            #[test]
            fn correct_element() {
                let expected = [0, 1, 2, 3, 4, 5];

                let mut actual: Dynamic<_> = expected.iter().copied().collect();

                for element in expected {
                    assert_eq!(actual.peek(), Some(&element));

                    _ = actual.pop();
                }
            }

            #[test]
            fn none_when_empty() {
                let actual = Dynamic::<()>::default();

                assert_eq!(actual.peek(), None);
            }
        }
    }
}
